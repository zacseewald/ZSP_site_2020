{"ast":null,"code":"/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar util = require(\"util\");\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar intersect = require(\"./util/SetHelpers\").intersect;\n\nvar GraphHelpers = require(\"./GraphHelpers\");\n\nvar Entrypoint = require(\"./Entrypoint\");\n\nvar debugId = 1000;\nvar ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nvar ERR_CHUNK_INITIAL = \"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n// TODO use @callback\n\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nvar sortModuleById = function sortModuleById(a, b) {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\n\n\nvar sortChunkGroupById = function sortChunkGroupById(a, b) {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\n\n\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\n\n\nvar _getModulesIdent = function getModulesIdent(set) {\n  set.sort();\n  var str = \"\";\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = set[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var m = _step.value;\n      str += m.identifier() + \"#\";\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return str;\n};\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\n\n\nvar getArray = function getArray(set) {\n  return Array.from(set);\n};\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\n\n\nvar getModulesSize = function getModulesSize(set) {\n  var size = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = set[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _module = _step2.value;\n      size += _module.size();\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return size;\n};\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\n\n\nvar Chunk =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   */\n  function Chunk(name) {\n    _classCallCheck(this, Chunk);\n\n    /** @type {number | null} */\n    this.id = null;\n    /** @type {number[] | null} */\n\n    this.ids = null;\n    /** @type {number} */\n\n    this.debugId = debugId++;\n    /** @type {string} */\n\n    this.name = name;\n    /** @type {boolean} */\n\n    this.preventIntegration = false;\n    /** @type {Module=} */\n\n    this.entryModule = undefined;\n    /** @private @type {SortableSet<Module>} */\n\n    this._modules = new SortableSet(undefined, sortByIdentifier);\n    /** @type {string?} */\n\n    this.filenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n\n    this._groups = new SortableSet(undefined, sortChunkGroupById);\n    /** @type {string[]} */\n\n    this.files = [];\n    /** @type {boolean} */\n\n    this.rendered = false;\n    /** @type {string=} */\n\n    this.hash = undefined;\n    /** @type {Object} */\n\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n\n    this.renderedHash = undefined;\n    /** @type {string=} */\n\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n\n    this.extraAsync = false;\n    this.removedModules = undefined;\n  }\n  /**\n   * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n   * @returns {never} Throws an error trying to access this property\n   */\n\n\n  _createClass(Chunk, [{\n    key: \"hasRuntime\",\n\n    /**\n     * @returns {boolean} whether or not the Chunk will have a runtime\n     */\n    value: function hasRuntime() {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._groups[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var chunkGroup = _step3.value;\n\n          if (chunkGroup.isInitial() && chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @returns {boolean} whether or not this chunk can be an initial chunk\n     */\n\n  }, {\n    key: \"canBeInitial\",\n    value: function canBeInitial() {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this._groups[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var chunkGroup = _step4.value;\n          if (chunkGroup.isInitial()) return true;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * @returns {boolean} whether this chunk can only be an initial chunk\n     */\n\n  }, {\n    key: \"isOnlyInitial\",\n    value: function isOnlyInitial() {\n      if (this._groups.size <= 0) return false;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this._groups[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var chunkGroup = _step5.value;\n          if (!chunkGroup.isInitial()) return false;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * @returns {boolean} if this chunk contains the entry module\n     */\n\n  }, {\n    key: \"hasEntryModule\",\n    value: function hasEntryModule() {\n      return !!this.entryModule;\n    }\n    /**\n     * @param {Module} module the module that will be added to this chunk.\n     * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n     */\n\n  }, {\n    key: \"addModule\",\n    value: function addModule(module) {\n      if (!this._modules.has(module)) {\n        this._modules.add(module);\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {Module} module the module that will be removed from this chunk\n     * @returns {boolean} returns true if chunk exists and is successfully deleted\n     */\n\n  }, {\n    key: \"removeModule\",\n    value: function removeModule(module) {\n      if (this._modules.delete(module)) {\n        module.removeChunk(this);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {Module[]} modules the new modules to be set\n     * @returns {void} set new modules to this chunk and return nothing\n     */\n\n  }, {\n    key: \"setModules\",\n    value: function setModules(modules) {\n      this._modules = new SortableSet(modules, sortByIdentifier);\n    }\n    /**\n     * @returns {number} the amount of modules in chunk\n     */\n\n  }, {\n    key: \"getNumberOfModules\",\n    value: function getNumberOfModules() {\n      return this._modules.size;\n    }\n    /**\n     * @returns {SortableSet} return the modules SortableSet for this chunk\n     */\n\n  }, {\n    key: \"addGroup\",\n\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n     * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n     */\n    value: function addGroup(chunkGroup) {\n      if (this._groups.has(chunkGroup)) return false;\n\n      this._groups.add(chunkGroup);\n\n      return true;\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n     * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n     */\n\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(chunkGroup) {\n      if (!this._groups.has(chunkGroup)) return false;\n\n      this._groups.delete(chunkGroup);\n\n      return true;\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup to check\n     * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n     */\n\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(chunkGroup) {\n      return this._groups.has(chunkGroup);\n    }\n    /**\n     * @returns {number} the amount of groups said chunk is in\n     */\n\n  }, {\n    key: \"getNumberOfGroups\",\n    value: function getNumberOfGroups() {\n      return this._groups.size;\n    }\n    /**\n     * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n     */\n\n  }, {\n    key: \"compareTo\",\n\n    /**\n     * @param {Chunk} otherChunk the chunk to compare itself with\n     * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n     */\n    value: function compareTo(otherChunk) {\n      if (this.name && !otherChunk.name) return -1;\n      if (!this.name && otherChunk.name) return 1;\n      if (this.name < otherChunk.name) return -1;\n      if (this.name > otherChunk.name) return 1;\n      if (this._modules.size > otherChunk._modules.size) return -1;\n      if (this._modules.size < otherChunk._modules.size) return 1;\n\n      this._modules.sort();\n\n      otherChunk._modules.sort();\n\n      var a = this._modules[Symbol.iterator]();\n\n      var b = otherChunk._modules[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n\n      while (true) {\n        var aItem = a.next();\n        if (aItem.done) return 0;\n        var bItem = b.next();\n        var aModuleIdentifier = aItem.value.identifier();\n        var bModuleIdentifier = bItem.value.identifier();\n        if (aModuleIdentifier < bModuleIdentifier) return -1;\n        if (aModuleIdentifier > bModuleIdentifier) return 1;\n      }\n    }\n    /**\n     * @param {Module} module Module to check\n     * @returns {boolean} returns true if module does exist in this chunk\n     */\n\n  }, {\n    key: \"containsModule\",\n    value: function containsModule(module) {\n      return this._modules.has(module);\n    }\n    /**\n     * @returns {Module[]} an array of modules (do not modify)\n     */\n\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return this._modules.getFromCache(getArray);\n    }\n  }, {\n    key: \"getModulesIdent\",\n    value: function getModulesIdent() {\n      return this._modules.getFromUnorderedCache(_getModulesIdent);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      // cleanup modules\n      // Array.from is used here to create a clone, because removeChunk modifies this._modules\n      var _arr = Array.from(this._modules);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var _module2 = _arr[_i];\n\n        _module2.removeChunk(this);\n      }\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this._groups[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var chunkGroup = _step6.value;\n          chunkGroup.removeChunk(this);\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n    /**\n     *\n     * @param {Module} module module to move\n     * @param {Chunk} otherChunk other chunk to move it to\n     * @returns {void}\n     */\n\n  }, {\n    key: \"moveModule\",\n    value: function moveModule(module, otherChunk) {\n      GraphHelpers.disconnectChunkAndModule(this, module);\n      GraphHelpers.connectChunkAndModule(otherChunk, module);\n      module.rewriteChunkInReasons(this, [otherChunk]);\n    }\n    /**\n     *\n     * @param {Chunk} otherChunk the chunk to integrate with\n     * @param {ModuleReason} reason reason why the module is being integrated\n     * @returns {boolean} returns true or false if integration succeeds or fails\n     */\n\n  }, {\n    key: \"integrate\",\n    value: function integrate(otherChunk, reason) {\n      if (!this.canBeIntegrated(otherChunk)) {\n        return false;\n      } // Pick a new name for the integrated chunk\n\n\n      if (this.name && otherChunk.name) {\n        if (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n          // When both chunks have entry modules or none have one, use\n          // shortest name\n          if (this.name.length !== otherChunk.name.length) {\n            this.name = this.name.length < otherChunk.name.length ? this.name : otherChunk.name;\n          } else {\n            this.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n          }\n        } else if (otherChunk.hasEntryModule()) {\n          // Pick the name of the chunk with the entry module\n          this.name = otherChunk.name;\n        }\n      } else if (otherChunk.name) {\n        this.name = otherChunk.name;\n      } // Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n\n\n      var _arr2 = Array.from(otherChunk._modules);\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        var _module3 = _arr2[_i2];\n        otherChunk.moveModule(_module3, this);\n      }\n\n      otherChunk._modules.clear();\n\n      if (otherChunk.entryModule) {\n        this.entryModule = otherChunk.entryModule;\n      }\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = otherChunk._groups[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var chunkGroup = _step7.value;\n          chunkGroup.replaceChunk(otherChunk, this);\n          this.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      otherChunk._groups.clear();\n\n      return true;\n    }\n    /**\n     * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n     * @returns {void}\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(newChunk) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this._groups[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var chunkGroup = _step8.value;\n          chunkGroup.insertChunk(newChunk, this);\n          newChunk.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._modules.size === 0;\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"\".concat(this.id, \" \"));\n      hash.update(this.ids ? this.ids.join(\",\") : \"\");\n      hash.update(\"\".concat(this.name || \"\", \" \"));\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = this._modules[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var m = _step9.value;\n          hash.update(m.hash);\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"canBeIntegrated\",\n    value: function canBeIntegrated(otherChunk) {\n      if (this.preventIntegration || otherChunk.preventIntegration) {\n        return false;\n      }\n\n      var isAvailable = function isAvailable(a, b) {\n        var queue = new Set(b.groupsIterable);\n        var _iteratorNormalCompletion10 = true;\n        var _didIteratorError10 = false;\n        var _iteratorError10 = undefined;\n\n        try {\n          for (var _iterator10 = queue[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n            var chunkGroup = _step10.value;\n            if (a.isInGroup(chunkGroup)) continue;\n            if (chunkGroup.isInitial()) return false;\n            var _iteratorNormalCompletion11 = true;\n            var _didIteratorError11 = false;\n            var _iteratorError11 = undefined;\n\n            try {\n              for (var _iterator11 = chunkGroup.parentsIterable[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n                var parent = _step11.value;\n                queue.add(parent);\n              }\n            } catch (err) {\n              _didIteratorError11 = true;\n              _iteratorError11 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                  _iterator11.return();\n                }\n              } finally {\n                if (_didIteratorError11) {\n                  throw _iteratorError11;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError10 = true;\n          _iteratorError10 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n              _iterator10.return();\n            }\n          } finally {\n            if (_didIteratorError10) {\n              throw _iteratorError10;\n            }\n          }\n        }\n\n        return true;\n      };\n\n      var selfHasRuntime = this.hasRuntime();\n      var otherChunkHasRuntime = otherChunk.hasRuntime();\n\n      if (selfHasRuntime !== otherChunkHasRuntime) {\n        if (selfHasRuntime) {\n          return isAvailable(this, otherChunk);\n        } else if (otherChunkHasRuntime) {\n          return isAvailable(otherChunk, this);\n        } else {\n          return false;\n        }\n      }\n\n      if (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     *\n     * @param {number} size the size\n     * @param {Object} options the options passed in\n     * @returns {number} the multiplier returned\n     */\n\n  }, {\n    key: \"addMultiplierAndOverhead\",\n    value: function addMultiplierAndOverhead(size, options) {\n      var overhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n      var multiplicator = this.canBeInitial() ? options.entryChunkMultiplicator || 10 : 1;\n      return size * multiplicator + overhead;\n    }\n    /**\n     * @returns {number} the size of all modules\n     */\n\n  }, {\n    key: \"modulesSize\",\n    value: function modulesSize() {\n      return this._modules.getFromUnorderedCache(getModulesSize);\n    }\n    /**\n     * @param {Object} options the size display options\n     * @returns {number} the chunk size\n     */\n\n  }, {\n    key: \"size\",\n    value: function size(options) {\n      return this.addMultiplierAndOverhead(this.modulesSize(), options);\n    }\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @param {TODO} options the options for this function\n     * @returns {number | false} the size, or false if it can't be integrated\n     */\n\n  }, {\n    key: \"integratedSize\",\n    value: function integratedSize(otherChunk, options) {\n      // Chunk if it's possible to integrate this chunk\n      if (!this.canBeIntegrated(otherChunk)) {\n        return false;\n      }\n\n      var integratedModulesSize = this.modulesSize(); // only count modules that do not exist in this chunk!\n\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = otherChunk._modules[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var otherModule = _step12.value;\n\n          if (!this._modules.has(otherModule)) {\n            integratedModulesSize += otherModule.size();\n          }\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n\n      return this.addMultiplierAndOverhead(integratedModulesSize, options);\n    }\n    /**\n     * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n     * @returns {void}\n     */\n\n  }, {\n    key: \"sortModules\",\n    value: function sortModules(sortByFn) {\n      this._modules.sortWith(sortByFn || sortModuleById);\n    }\n  }, {\n    key: \"sortItems\",\n    value: function sortItems() {\n      this.sortModules();\n    }\n    /**\n     * @returns {Set<Chunk>} a set of all the async chunks\n     */\n\n  }, {\n    key: \"getAllAsyncChunks\",\n    value: function getAllAsyncChunks() {\n      var queue = new Set();\n      var chunks = new Set();\n      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {\n        return new Set(g.chunks);\n      }));\n      var _iteratorNormalCompletion13 = true;\n      var _didIteratorError13 = false;\n      var _iteratorError13 = undefined;\n\n      try {\n        for (var _iterator13 = this.groupsIterable[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n          var chunkGroup = _step13.value;\n          var _iteratorNormalCompletion15 = true;\n          var _didIteratorError15 = false;\n          var _iteratorError15 = undefined;\n\n          try {\n            for (var _iterator15 = chunkGroup.childrenIterable[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n              var child = _step15.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _didIteratorError15 = true;\n            _iteratorError15 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n                _iterator15.return();\n              }\n            } finally {\n              if (_didIteratorError15) {\n                throw _iteratorError15;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError13 = true;\n        _iteratorError13 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n            _iterator13.return();\n          }\n        } finally {\n          if (_didIteratorError13) {\n            throw _iteratorError13;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion14 = true;\n      var _didIteratorError14 = false;\n      var _iteratorError14 = undefined;\n\n      try {\n        for (var _iterator14 = queue[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n          var _chunkGroup = _step14.value;\n          var _iteratorNormalCompletion16 = true;\n          var _didIteratorError16 = false;\n          var _iteratorError16 = undefined;\n\n          try {\n            for (var _iterator16 = _chunkGroup.chunks[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n              var chunk = _step16.value;\n\n              if (!initialChunks.has(chunk)) {\n                chunks.add(chunk);\n              }\n            }\n          } catch (err) {\n            _didIteratorError16 = true;\n            _iteratorError16 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n                _iterator16.return();\n              }\n            } finally {\n              if (_didIteratorError16) {\n                throw _iteratorError16;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion17 = true;\n          var _didIteratorError17 = false;\n          var _iteratorError17 = undefined;\n\n          try {\n            for (var _iterator17 = _chunkGroup.childrenIterable[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n              var _child = _step17.value;\n              queue.add(_child);\n            }\n          } catch (err) {\n            _didIteratorError17 = true;\n            _iteratorError17 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n                _iterator17.return();\n              }\n            } finally {\n              if (_didIteratorError17) {\n                throw _iteratorError17;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError14 = true;\n        _iteratorError14 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n            _iterator14.return();\n          }\n        } finally {\n          if (_didIteratorError14) {\n            throw _iteratorError14;\n          }\n        }\n      }\n\n      return chunks;\n    }\n    /**\n     * @typedef {Object} ChunkMaps\n     * @property {Record<string|number, string>} hash\n     * @property {Record<string|number, Record<string, string>>} contentHash\n     * @property {Record<string|number, string>} name\n     */\n\n    /**\n     * @param {boolean} realHash should the full hash or the rendered hash be used\n     * @returns {ChunkMaps} the chunk map information\n     */\n\n  }, {\n    key: \"getChunkMaps\",\n    value: function getChunkMaps(realHash) {\n      /** @type {Record<string|number, string>} */\n      var chunkHashMap = Object.create(null);\n      /** @type {Record<string|number, Record<string, string>>} */\n\n      var chunkContentHashMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n\n      var chunkNameMap = Object.create(null);\n      var _iteratorNormalCompletion18 = true;\n      var _didIteratorError18 = false;\n      var _iteratorError18 = undefined;\n\n      try {\n        for (var _iterator18 = this.getAllAsyncChunks()[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n          var chunk = _step18.value;\n          chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\n          var _arr3 = Object.keys(chunk.contentHash);\n\n          for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n            var key = _arr3[_i3];\n\n            if (!chunkContentHashMap[key]) {\n              chunkContentHashMap[key] = Object.create(null);\n            }\n\n            chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n          }\n\n          if (chunk.name) {\n            chunkNameMap[chunk.id] = chunk.name;\n          }\n        }\n      } catch (err) {\n        _didIteratorError18 = true;\n        _iteratorError18 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n            _iterator18.return();\n          }\n        } finally {\n          if (_didIteratorError18) {\n            throw _iteratorError18;\n          }\n        }\n      }\n\n      return {\n        hash: chunkHashMap,\n        contentHash: chunkContentHashMap,\n        name: chunkNameMap\n      };\n    }\n    /**\n     * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n     */\n\n  }, {\n    key: \"getChildIdsByOrders\",\n    value: function getChildIdsByOrders() {\n      var lists = new Map();\n      var _iteratorNormalCompletion19 = true;\n      var _didIteratorError19 = false;\n      var _iteratorError19 = undefined;\n\n      try {\n        for (var _iterator19 = this.groupsIterable[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n          var group = _step19.value;\n\n          if (group.chunks[group.chunks.length - 1] === this) {\n            var _iteratorNormalCompletion21 = true;\n            var _didIteratorError21 = false;\n            var _iteratorError21 = undefined;\n\n            try {\n              for (var _iterator21 = group.childrenIterable[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n                var childGroup = _step21.value;\n\n                // TODO webpack 5 remove this check for options\n                if (typeof childGroup.options === \"object\") {\n                  var _arr4 = Object.keys(childGroup.options);\n\n                  for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n                    var key = _arr4[_i4];\n\n                    if (key.endsWith(\"Order\")) {\n                      var name = key.substr(0, key.length - \"Order\".length);\n                      var list = lists.get(name);\n                      if (list === undefined) lists.set(name, list = []);\n                      list.push({\n                        order: childGroup.options[key],\n                        group: childGroup\n                      });\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _didIteratorError21 = true;\n              _iteratorError21 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n                  _iterator21.return();\n                }\n              } finally {\n                if (_didIteratorError21) {\n                  throw _iteratorError21;\n                }\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError19 = true;\n        _iteratorError19 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n            _iterator19.return();\n          }\n        } finally {\n          if (_didIteratorError19) {\n            throw _iteratorError19;\n          }\n        }\n      }\n\n      var result = Object.create(null);\n      var _iteratorNormalCompletion20 = true;\n      var _didIteratorError20 = false;\n      var _iteratorError20 = undefined;\n\n      try {\n        for (var _iterator20 = lists[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n          var _step20$value = _slicedToArray(_step20.value, 2),\n              _name = _step20$value[0],\n              _list = _step20$value[1];\n\n          _list.sort(function (a, b) {\n            var cmp = b.order - a.order;\n            if (cmp !== 0) return cmp; // TODO webpack 5 remove this check of compareTo\n\n            if (a.group.compareTo) {\n              return a.group.compareTo(b.group);\n            }\n\n            return 0;\n          });\n\n          result[_name] = Array.from(_list.reduce(function (set, item) {\n            var _iteratorNormalCompletion22 = true;\n            var _didIteratorError22 = false;\n            var _iteratorError22 = undefined;\n\n            try {\n              for (var _iterator22 = item.group.chunks[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n                var chunk = _step22.value;\n                set.add(chunk.id);\n              }\n            } catch (err) {\n              _didIteratorError22 = true;\n              _iteratorError22 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n                  _iterator22.return();\n                }\n              } finally {\n                if (_didIteratorError22) {\n                  throw _iteratorError22;\n                }\n              }\n            }\n\n            return set;\n          }, new Set()));\n        }\n      } catch (err) {\n        _didIteratorError20 = true;\n        _iteratorError20 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n            _iterator20.return();\n          }\n        } finally {\n          if (_didIteratorError20) {\n            throw _iteratorError20;\n          }\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getChildIdsByOrdersMap\",\n    value: function getChildIdsByOrdersMap(includeDirectChildren) {\n      var chunkMaps = Object.create(null);\n\n      var addChildIdsByOrdersToMap = function addChildIdsByOrdersToMap(chunk) {\n        var data = chunk.getChildIdsByOrders();\n\n        var _arr5 = Object.keys(data);\n\n        for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n          var key = _arr5[_i5];\n          var chunkMap = chunkMaps[key];\n\n          if (chunkMap === undefined) {\n            chunkMaps[key] = chunkMap = Object.create(null);\n          }\n\n          chunkMap[chunk.id] = data[key];\n        }\n      };\n\n      if (includeDirectChildren) {\n        addChildIdsByOrdersToMap(this);\n      }\n\n      var _iteratorNormalCompletion23 = true;\n      var _didIteratorError23 = false;\n      var _iteratorError23 = undefined;\n\n      try {\n        for (var _iterator23 = this.getAllAsyncChunks()[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {\n          var chunk = _step23.value;\n          addChildIdsByOrdersToMap(chunk);\n        }\n      } catch (err) {\n        _didIteratorError23 = true;\n        _iteratorError23 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion23 && _iterator23.return != null) {\n            _iterator23.return();\n          }\n        } finally {\n          if (_didIteratorError23) {\n            throw _iteratorError23;\n          }\n        }\n      }\n\n      return chunkMaps;\n    }\n    /**\n     * @typedef {Object} ChunkModuleMaps\n     * @property {Record<string|number, (string|number)[]>} id\n     * @property {Record<string|number, string>} hash\n     */\n\n    /**\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @returns {ChunkModuleMaps} module map information\n     */\n\n  }, {\n    key: \"getChunkModuleMaps\",\n    value: function getChunkModuleMaps(filterFn) {\n      /** @type {Record<string|number, (string|number)[]>} */\n      var chunkModuleIdMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n\n      var chunkModuleHashMap = Object.create(null);\n      var _iteratorNormalCompletion24 = true;\n      var _didIteratorError24 = false;\n      var _iteratorError24 = undefined;\n\n      try {\n        for (var _iterator24 = this.getAllAsyncChunks()[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {\n          var chunk = _step24.value;\n\n          /** @type {(string|number)[]} */\n          var array = void 0;\n          var _iteratorNormalCompletion25 = true;\n          var _didIteratorError25 = false;\n          var _iteratorError25 = undefined;\n\n          try {\n            for (var _iterator25 = chunk.modulesIterable[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {\n              var _module4 = _step25.value;\n\n              if (filterFn(_module4)) {\n                if (array === undefined) {\n                  array = [];\n                  chunkModuleIdMap[chunk.id] = array;\n                }\n\n                array.push(_module4.id);\n                chunkModuleHashMap[_module4.id] = _module4.renderedHash;\n              }\n            }\n          } catch (err) {\n            _didIteratorError25 = true;\n            _iteratorError25 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion25 && _iterator25.return != null) {\n                _iterator25.return();\n              }\n            } finally {\n              if (_didIteratorError25) {\n                throw _iteratorError25;\n              }\n            }\n          }\n\n          if (array !== undefined) {\n            array.sort();\n          }\n        }\n      } catch (err) {\n        _didIteratorError24 = true;\n        _iteratorError24 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion24 && _iterator24.return != null) {\n            _iterator24.return();\n          }\n        } finally {\n          if (_didIteratorError24) {\n            throw _iteratorError24;\n          }\n        }\n      }\n\n      return {\n        id: chunkModuleIdMap,\n        hash: chunkModuleHashMap\n      };\n    }\n    /**\n     *\n     * @param {function(Module): boolean} filterFn predicate function used to filter modules\n     * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n     * @returns {boolean} return true if module exists in graph\n     */\n\n  }, {\n    key: \"hasModuleInGraph\",\n    value: function hasModuleInGraph(filterFn, filterChunkFn) {\n      var queue = new Set(this.groupsIterable);\n      var chunksProcessed = new Set();\n      var _iteratorNormalCompletion26 = true;\n      var _didIteratorError26 = false;\n      var _iteratorError26 = undefined;\n\n      try {\n        for (var _iterator26 = queue[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {\n          var chunkGroup = _step26.value;\n          var _iteratorNormalCompletion27 = true;\n          var _didIteratorError27 = false;\n          var _iteratorError27 = undefined;\n\n          try {\n            for (var _iterator27 = chunkGroup.chunks[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {\n              var chunk = _step27.value;\n\n              if (!chunksProcessed.has(chunk)) {\n                chunksProcessed.add(chunk);\n\n                if (!filterChunkFn || filterChunkFn(chunk)) {\n                  var _iteratorNormalCompletion29 = true;\n                  var _didIteratorError29 = false;\n                  var _iteratorError29 = undefined;\n\n                  try {\n                    for (var _iterator29 = chunk.modulesIterable[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {\n                      var _module5 = _step29.value;\n\n                      if (filterFn(_module5)) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _didIteratorError29 = true;\n                    _iteratorError29 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion29 && _iterator29.return != null) {\n                        _iterator29.return();\n                      }\n                    } finally {\n                      if (_didIteratorError29) {\n                        throw _iteratorError29;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError27 = true;\n            _iteratorError27 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion27 && _iterator27.return != null) {\n                _iterator27.return();\n              }\n            } finally {\n              if (_didIteratorError27) {\n                throw _iteratorError27;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion28 = true;\n          var _didIteratorError28 = false;\n          var _iteratorError28 = undefined;\n\n          try {\n            for (var _iterator28 = chunkGroup.childrenIterable[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {\n              var child = _step28.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _didIteratorError28 = true;\n            _iteratorError28 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion28 && _iterator28.return != null) {\n                _iterator28.return();\n              }\n            } finally {\n              if (_didIteratorError28) {\n                throw _iteratorError28;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError26 = true;\n        _iteratorError26 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion26 && _iterator26.return != null) {\n            _iterator26.return();\n          }\n        } finally {\n          if (_didIteratorError26) {\n            throw _iteratorError26;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Chunk[\".concat(Array.from(this._modules).join(), \"]\");\n    }\n  }, {\n    key: \"entry\",\n    get: function get() {\n      throw new Error(ERR_CHUNK_ENTRY);\n    }\n    /**\n     * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n     * @param {never} data The data that was attempting to be set\n     * @returns {never} Throws an error trying to access this property\n     */\n    ,\n    set: function set(data) {\n      throw new Error(ERR_CHUNK_ENTRY);\n    }\n    /**\n     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n     * @returns {never} Throws an error trying to access this property\n     */\n\n  }, {\n    key: \"initial\",\n    get: function get() {\n      throw new Error(ERR_CHUNK_INITIAL);\n    }\n    /**\n     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n     * @param {never} data The data attempting to be set\n     * @returns {never} Throws an error trying to access this property\n     */\n    ,\n    set: function set(data) {\n      throw new Error(ERR_CHUNK_INITIAL);\n    }\n  }, {\n    key: \"modulesIterable\",\n    get: function get() {\n      return this._modules;\n    }\n  }, {\n    key: \"groupsIterable\",\n    get: function get() {\n      return this._groups;\n    }\n  }]);\n\n  return Chunk;\n}(); // TODO remove in webpack 5\n\n\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n   * @param {ForEachModuleCallback} fn Callback function\n   * @returns {void}\n   */\n  function (fn) {\n    this._modules.forEach(fn);\n  }, \"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, number): any} MapModulesCallback\n   * @param {MapModulesCallback} fn Callback function\n   * @returns {TODO[]} result of mapped modules\n   */\n  function (fn) {\n    return Array.from(this._modules, fn);\n  }, \"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"parents\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n  }\n});\nmodule.exports = Chunk;","map":null,"metadata":{},"sourceType":"script"}