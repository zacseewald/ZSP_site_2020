{"ast":null,"code":"// parse a 512-byte header block to a data object, or vice-versa\n// If the data won't fit nicely in a simple header, then generate\n// the appropriate extended header file, and return that.\nmodule.exports = TarHeader;\n\nvar tar = require(\"../tar.js\"),\n    fields = tar.fields,\n    fieldOffs = tar.fieldOffs,\n    fieldEnds = tar.fieldEnds,\n    fieldSize = tar.fieldSize,\n    numeric = tar.numeric,\n    assert = require(\"assert\").ok,\n    space = \" \".charCodeAt(0),\n    slash = \"/\".charCodeAt(0),\n    bslash = process.platform === \"win32\" ? \"\\\\\".charCodeAt(0) : null;\n\nfunction TarHeader(block) {\n  if (!(this instanceof TarHeader)) return new TarHeader(block);\n  if (block) this.decode(block);\n}\n\nTarHeader.prototype = {\n  decode: decode,\n  encode: encode,\n  calcSum: calcSum,\n  checkSum: checkSum\n};\nTarHeader.parseNumeric = parseNumeric;\nTarHeader.encode = encode;\nTarHeader.decode = decode; // note that this will only do the normal ustar header, not any kind\n// of extended posix header file.  If something doesn't fit comfortably,\n// then it will set obj.needExtended = true, and set the block to\n// the closest approximation.\n\nfunction encode(obj) {\n  if (!obj && !(this instanceof TarHeader)) throw new Error(\"encode must be called on a TarHeader, or supplied an object\");\n  obj = obj || this;\n  var block = obj.block = new Buffer(512); // if the object has a \"prefix\", then that's actually an extension of\n  // the path field.\n\n  if (obj.prefix) {\n    // console.error(\"%% header encoding, got a prefix\", obj.prefix)\n    obj.path = obj.prefix + \"/\" + obj.path; // console.error(\"%% header encoding, prefixed path\", obj.path)\n\n    obj.prefix = \"\";\n  }\n\n  obj.needExtended = false;\n\n  if (obj.mode) {\n    if (typeof obj.mode === \"string\") obj.mode = parseInt(obj.mode, 8);\n    obj.mode = obj.mode & 0777;\n  }\n\n  for (var f = 0; fields[f] !== null; f++) {\n    var field = fields[f],\n        off = fieldOffs[f],\n        end = fieldEnds[f],\n        ret;\n\n    switch (field) {\n      case \"cksum\":\n        // special, done below, after all the others\n        break;\n\n      case \"prefix\":\n        // special, this is an extension of the \"path\" field.\n        // console.error(\"%% header encoding, skip prefix later\")\n        break;\n\n      case \"type\":\n        // convert from long name to a single char.\n        var type = obj.type || \"0\";\n\n        if (type.length > 1) {\n          type = tar.types[obj.type];\n          if (!type) type = \"0\";\n        }\n\n        writeText(block, off, end, type);\n        break;\n\n      case \"path\":\n        // uses the \"prefix\" field if > 100 bytes, but <= 255\n        var pathLen = Buffer.byteLength(obj.path),\n            pathFSize = fieldSize[fields.path],\n            prefFSize = fieldSize[fields.prefix]; // paths between 100 and 255 should use the prefix field.\n        // longer than 255\n\n        if (pathLen > pathFSize && pathLen <= pathFSize + prefFSize) {\n          // need to find a slash somewhere in the middle so that\n          // path and prefix both fit in their respective fields\n          var searchStart = pathLen - 1 - pathFSize,\n              searchEnd = prefFSize,\n              found = false,\n              pathBuf = new Buffer(obj.path);\n\n          for (var s = searchStart; s <= searchEnd; s++) {\n            if (pathBuf[s] === slash || pathBuf[s] === bslash) {\n              found = s;\n              break;\n            }\n          }\n\n          if (found !== false) {\n            prefix = pathBuf.slice(0, found).toString(\"utf8\");\n            path = pathBuf.slice(found + 1).toString(\"utf8\");\n            ret = writeText(block, off, end, path);\n            off = fieldOffs[fields.prefix];\n            end = fieldEnds[fields.prefix]; // console.error(\"%% header writing prefix\", off, end, prefix)\n\n            ret = writeText(block, off, end, prefix) || ret;\n            break;\n          }\n        } // paths less than 100 chars don't need a prefix\n        // and paths longer than 255 need an extended header and will fail\n        // on old implementations no matter what we do here.\n        // Null out the prefix, and fallthrough to default.\n        // console.error(\"%% header writing no prefix\")\n\n\n        var poff = fieldOffs[fields.prefix],\n            pend = fieldEnds[fields.prefix];\n        writeText(block, poff, pend, \"\");\n      // fallthrough\n      // all other fields are numeric or text\n\n      default:\n        ret = numeric[field] ? writeNumeric(block, off, end, obj[field]) : writeText(block, off, end, obj[field] || \"\");\n        break;\n    }\n\n    obj.needExtended = obj.needExtended || ret;\n  }\n\n  var off = fieldOffs[fields.cksum],\n      end = fieldEnds[fields.cksum];\n  writeNumeric(block, off, end, calcSum.call(this, block));\n  return block;\n} // if it's a negative number, or greater than will fit,\n// then use write256.\n\n\nvar MAXNUM = {\n  12: 077777777777,\n  11: 07777777777,\n  8: 07777777,\n  7: 0777777\n};\n\nfunction writeNumeric(block, off, end, num) {\n  var writeLen = end - off,\n      maxNum = MAXNUM[writeLen] || 0;\n  num = num || 0; // console.error(\"  numeric\", num)\n\n  if (num instanceof Date || Object.prototype.toString.call(num) === \"[object Date]\") {\n    num = num.getTime() / 1000;\n  }\n\n  if (num > maxNum || num < 0) {\n    write256(block, off, end, num); // need an extended header if negative or too big.\n\n    return true;\n  } // god, tar is so annoying\n  // if the string is small enough, you should put a space\n  // between the octal string and the \\0, but if it doesn't\n  // fit, then don't.\n\n\n  var numStr = Math.floor(num).toString(8);\n  if (num < MAXNUM[writeLen - 1]) numStr += \" \"; // pad with \"0\" chars\n\n  if (numStr.length < writeLen) {\n    numStr = new Array(writeLen - numStr.length).join(\"0\") + numStr;\n  }\n\n  if (numStr.length !== writeLen - 1) {\n    throw new Error(\"invalid length: \" + JSON.stringify(numStr) + \"\\n\" + \"expected: \" + writeLen);\n  }\n\n  block.write(numStr, off, writeLen, \"utf8\");\n  block[end - 1] = 0;\n}\n\nfunction write256(block, off, end, num) {\n  var buf = block.slice(off, end);\n  var positive = num >= 0;\n  buf[0] = positive ? 0x80 : 0xFF; // get the number as a base-256 tuple\n\n  if (!positive) num *= -1;\n  var tuple = [];\n\n  do {\n    var n = num % 256;\n    tuple.push(n);\n    num = (num - n) / 256;\n  } while (num);\n\n  var bytes = tuple.length;\n  var fill = buf.length - bytes;\n\n  for (var i = 1; i < fill; i++) {\n    buf[i] = positive ? 0 : 0xFF;\n  } // tuple is a base256 number, with [0] as the *least* significant byte\n  // if it's negative, then we need to flip all the bits once we hit the\n  // first non-zero bit.  The 2's-complement is (0x100 - n), and the 1's-\n  // complement is (0xFF - n).\n\n\n  var zero = true;\n\n  for (i = bytes; i > 0; i--) {\n    var byte = tuple[bytes - i];\n    if (positive) buf[fill + i] = byte;else if (zero && byte === 0) buf[fill + i] = 0;else if (zero) {\n      zero = false;\n      buf[fill + i] = 0x100 - byte;\n    } else buf[fill + i] = 0xFF - byte;\n  }\n}\n\nfunction writeText(block, off, end, str) {\n  // strings are written as utf8, then padded with \\0\n  var strLen = Buffer.byteLength(str),\n      writeLen = Math.min(strLen, end - off) // non-ascii fields need extended headers\n  // long fields get truncated\n  ,\n      needExtended = strLen !== str.length || strLen > writeLen; // write the string, and null-pad\n\n  if (writeLen > 0) block.write(str, off, writeLen, \"utf8\");\n\n  for (var i = off + writeLen; i < end; i++) {\n    block[i] = 0;\n  }\n\n  return needExtended;\n}\n\nfunction calcSum(block) {\n  block = block || this.block;\n  assert(Buffer.isBuffer(block) && block.length === 512);\n  if (!block) throw new Error(\"Need block to checksum\"); // now figure out what it would be if the cksum was \"        \"\n\n  var sum = 0,\n      start = fieldOffs[fields.cksum],\n      end = fieldEnds[fields.cksum];\n\n  for (var i = 0; i < fieldOffs[fields.cksum]; i++) {\n    sum += block[i];\n  }\n\n  for (var i = start; i < end; i++) {\n    sum += space;\n  }\n\n  for (var i = end; i < 512; i++) {\n    sum += block[i];\n  }\n\n  return sum;\n}\n\nfunction checkSum(block) {\n  var sum = calcSum.call(this, block);\n  block = block || this.block;\n  var cksum = block.slice(fieldOffs[fields.cksum], fieldEnds[fields.cksum]);\n  cksum = parseNumeric(cksum);\n  return cksum === sum;\n}\n\nfunction decode(block) {\n  block = block || this.block;\n  assert(Buffer.isBuffer(block) && block.length === 512);\n  this.block = block;\n  this.cksumValid = this.checkSum();\n  var prefix = null; // slice off each field.\n\n  for (var f = 0; fields[f] !== null; f++) {\n    var field = fields[f],\n        val = block.slice(fieldOffs[f], fieldEnds[f]);\n\n    switch (field) {\n      case \"ustar\":\n        // if not ustar, then everything after that is just padding.\n        if (val.toString() !== \"ustar\\0\") {\n          this.ustar = false;\n          return;\n        } else {\n          // console.error(\"ustar:\", val, val.toString())\n          this.ustar = val.toString();\n        }\n\n        break;\n      // prefix is special, since it might signal the xstar header\n\n      case \"prefix\":\n        var atime = parseNumeric(val.slice(131, 131 + 12)),\n            ctime = parseNumeric(val.slice(131 + 12, 131 + 12 + 12));\n\n        if ((val[130] === 0 || val[130] === space) && typeof atime === \"number\" && typeof ctime === \"number\" && val[131 + 12] === space && val[131 + 12 + 12] === space) {\n          this.atime = atime;\n          this.ctime = ctime;\n          val = val.slice(0, 130);\n        }\n\n        prefix = val.toString(\"utf8\").replace(/\\0+$/, \"\"); // console.error(\"%% header reading prefix\", prefix)\n\n        break;\n      // all other fields are null-padding text\n      // or a number.\n\n      default:\n        if (numeric[field]) {\n          this[field] = parseNumeric(val);\n        } else {\n          this[field] = val.toString(\"utf8\").replace(/\\0+$/, \"\");\n        }\n\n        break;\n    }\n  } // if we got a prefix, then prepend it to the path.\n\n\n  if (prefix) {\n    this.path = prefix + \"/\" + this.path; // console.error(\"%% header got a prefix\", this.path)\n  }\n}\n\nfunction parse256(buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive;\n  if (buf[0] === 0x80) positive = true;else if (buf[0] === 0xFF) positive = false;else return null; // build up a base-256 tuple from the least sig to the highest\n\n  var zero = false,\n      tuple = [];\n\n  for (var i = buf.length - 1; i > 0; i--) {\n    var byte = buf[i];\n    if (positive) tuple.push(byte);else if (zero && byte === 0) tuple.push(0);else if (zero) {\n      zero = false;\n      tuple.push(0x100 - byte);\n    } else tuple.push(0xFF - byte);\n  }\n\n  for (var sum = 0, i = 0, l = tuple.length; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i);\n  }\n\n  return positive ? sum : -1 * sum;\n}\n\nfunction parseNumeric(f) {\n  if (f[0] & 0x80) return parse256(f);\n  var str = f.toString(\"utf8\").split(\"\\0\")[0].trim(),\n      res = parseInt(str, 8);\n  return isNaN(res) ? null : res;\n}","map":null,"metadata":{},"sourceType":"script"}