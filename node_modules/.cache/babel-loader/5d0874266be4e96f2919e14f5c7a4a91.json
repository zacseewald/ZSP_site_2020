{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n\n\nvar LimitChunkCountPlugin =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  function LimitChunkCountPlugin(options) {\n    _classCallCheck(this, LimitChunkCountPlugin);\n\n    if (!options) options = {};\n    validateOptions(schema, options, \"Limit Chunk Count Plugin\");\n    this.options = options;\n  }\n\n  _createClass(LimitChunkCountPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", function (compilation) {\n        compilation.hooks.optimizeChunksAdvanced.tap(\"LimitChunkCountPlugin\", function (chunks) {\n          var maxChunks = options.maxChunks;\n          if (!maxChunks) return;\n          if (maxChunks < 1) return;\n          if (chunks.length <= maxChunks) return;\n          var orderedChunks = chunks.slice().sort(function (a, b) {\n            return a.compareTo(b);\n          });\n          var sortedExtendedPairCombinations = orderedChunks.reduce(function (combinations, a, idx) {\n            // create combination pairs\n            for (var i = 0; i < idx; i++) {\n              var b = orderedChunks[i];\n              combinations.push([b, a]);\n            }\n\n            return combinations;\n          }, []).map(function (pair) {\n            // extend combination pairs with size and integrated size\n            var a = pair[0].size(options);\n            var b = pair[1].size(options);\n            var ab = pair[0].integratedSize(pair[1], options);\n            return [a + b - ab, ab, pair[0], pair[1], a, b];\n          }).filter(function (extendedPair) {\n            // filter pairs that do not have an integratedSize\n            // meaning they can NOT be integrated!\n            return extendedPair[1] !== false;\n          }).sort(function (a, b) {\n            // sadly javascript does an inplace sort here\n            // sort them by size\n            var diff1 = b[0] - a[0];\n            if (diff1 !== 0) return diff1;\n            var diff2 = a[1] - b[1];\n            if (diff2 !== 0) return diff2;\n            var diff3 = a[2].compareTo(b[2]);\n            if (diff3 !== 0) return diff3;\n            return a[3].compareTo(b[3]);\n          });\n          var pair = sortedExtendedPairCombinations[0];\n\n          if (pair && pair[2].integrate(pair[3], \"limit\")) {\n            chunks.splice(chunks.indexOf(pair[3]), 1);\n            return true;\n          }\n        });\n      });\n    }\n  }]);\n\n  return LimitChunkCountPlugin;\n}();\n\nmodule.exports = LimitChunkCountPlugin;","map":null,"metadata":{},"sourceType":"script"}