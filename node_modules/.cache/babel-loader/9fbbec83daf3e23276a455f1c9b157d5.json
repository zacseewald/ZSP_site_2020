{"ast":null,"code":"// Basically just a wrapper around an fs.ReadStream\nmodule.exports = FileReader;\n\nvar fs = require('graceful-fs');\n\nvar inherits = require('inherits');\n\nvar Reader = require('./reader.js');\n\nvar EOF = {\n  EOF: true\n};\nvar CLOSE = {\n  CLOSE: true\n};\ninherits(FileReader, Reader);\n\nfunction FileReader(props) {\n  // console.error(\"    FR create\", props.path, props.size, new Error().stack)\n  var self = this;\n\n  if (!(self instanceof FileReader)) {\n    throw new Error('FileReader must be called as constructor.');\n  } // should already be established as a File type\n  // XXX Todo: preserve hardlinks by tracking dev+inode+nlink,\n  // with a HardLinkReader class.\n\n\n  if (!(props.type === 'Link' && props.Link || props.type === 'File' && props.File)) {\n    throw new Error('Non-file type ' + props.type);\n  }\n\n  self._buffer = [];\n  self._bytesEmitted = 0;\n  Reader.call(self, props);\n}\n\nFileReader.prototype._getStream = function () {\n  var self = this;\n  var stream = self._stream = fs.createReadStream(self._path, self.props);\n\n  if (self.props.blksize) {\n    stream.bufferSize = self.props.blksize;\n  }\n\n  stream.on('open', self.emit.bind(self, 'open'));\n  stream.on('data', function (c) {\n    // console.error('\\t\\t%d %s', c.length, self.basename)\n    self._bytesEmitted += c.length; // no point saving empty chunks\n\n    if (!c.length) {\n      return;\n    } else if (self._paused || self._buffer.length) {\n      self._buffer.push(c);\n\n      self._read();\n    } else self.emit('data', c);\n  });\n  stream.on('end', function () {\n    if (self._paused || self._buffer.length) {\n      // console.error('FR Buffering End', self._path)\n      self._buffer.push(EOF);\n\n      self._read();\n    } else {\n      self.emit('end');\n    }\n\n    if (self._bytesEmitted !== self.props.size) {\n      self.error(\"Didn't get expected byte count\\n\" + 'expect: ' + self.props.size + '\\n' + 'actual: ' + self._bytesEmitted);\n    }\n  });\n  stream.on('close', function () {\n    if (self._paused || self._buffer.length) {\n      // console.error('FR Buffering Close', self._path)\n      self._buffer.push(CLOSE);\n\n      self._read();\n    } else {\n      // console.error('FR close 1', self._path)\n      self.emit('close');\n    }\n  });\n  stream.on('error', function (e) {\n    self.emit('error', e);\n  });\n\n  self._read();\n};\n\nFileReader.prototype._read = function () {\n  var self = this; // console.error('FR _read', self._path)\n\n  if (self._paused) {\n    // console.error('FR _read paused', self._path)\n    return;\n  }\n\n  if (!self._stream) {\n    // console.error('FR _getStream calling', self._path)\n    return self._getStream();\n  } // clear out the buffer, if there is one.\n\n\n  if (self._buffer.length) {\n    // console.error('FR _read has buffer', self._buffer.length, self._path)\n    var buf = self._buffer;\n\n    for (var i = 0, l = buf.length; i < l; i++) {\n      var c = buf[i];\n\n      if (c === EOF) {\n        // console.error('FR Read emitting buffered end', self._path)\n        self.emit('end');\n      } else if (c === CLOSE) {\n        // console.error('FR Read emitting buffered close', self._path)\n        self.emit('close');\n      } else {\n        // console.error('FR Read emitting buffered data', self._path)\n        self.emit('data', c);\n      }\n\n      if (self._paused) {\n        // console.error('FR Read Re-pausing at '+i, self._path)\n        self._buffer = buf.slice(i);\n        return;\n      }\n    }\n\n    self._buffer.length = 0;\n  } // console.error(\"FR _read done\")\n  // that's about all there is to it.\n\n};\n\nFileReader.prototype.pause = function (who) {\n  var self = this; // console.error('FR Pause', self._path)\n\n  if (self._paused) return;\n  who = who || self;\n  self._paused = true;\n  if (self._stream) self._stream.pause();\n  self.emit('pause', who);\n};\n\nFileReader.prototype.resume = function (who) {\n  var self = this; // console.error('FR Resume', self._path)\n\n  if (!self._paused) return;\n  who = who || self;\n  self.emit('resume', who);\n  self._paused = false;\n  if (self._stream) self._stream.resume();\n\n  self._read();\n};","map":null,"metadata":{},"sourceType":"script"}