{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n\t*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar asyncLib = require(\"neo-async\");\n\nvar util = require(\"util\");\n\nvar _require = require(\"webpack-sources\"),\n    CachedSource = _require.CachedSource;\n\nvar _require2 = require(\"tapable\"),\n    Tapable = _require2.Tapable,\n    SyncHook = _require2.SyncHook,\n    SyncBailHook = _require2.SyncBailHook,\n    SyncWaterfallHook = _require2.SyncWaterfallHook,\n    AsyncSeriesHook = _require2.AsyncSeriesHook;\n\nvar EntryModuleNotFoundError = require(\"./EntryModuleNotFoundError\");\n\nvar ModuleNotFoundError = require(\"./ModuleNotFoundError\");\n\nvar ModuleDependencyWarning = require(\"./ModuleDependencyWarning\");\n\nvar ModuleDependencyError = require(\"./ModuleDependencyError\");\n\nvar ChunkGroup = require(\"./ChunkGroup\");\n\nvar Chunk = require(\"./Chunk\");\n\nvar Entrypoint = require(\"./Entrypoint\");\n\nvar MainTemplate = require(\"./MainTemplate\");\n\nvar ChunkTemplate = require(\"./ChunkTemplate\");\n\nvar HotUpdateChunkTemplate = require(\"./HotUpdateChunkTemplate\");\n\nvar ModuleTemplate = require(\"./ModuleTemplate\");\n\nvar RuntimeTemplate = require(\"./RuntimeTemplate\");\n\nvar ChunkRenderError = require(\"./ChunkRenderError\");\n\nvar AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nvar Stats = require(\"./Stats\");\n\nvar Semaphore = require(\"./util/Semaphore\");\n\nvar _createHash = require(\"./util/createHash\");\n\nvar Queue = require(\"./util/Queue\");\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar GraphHelpers = require(\"./GraphHelpers\");\n\nvar ModuleDependency = require(\"./dependencies/ModuleDependency\");\n\nvar compareLocations = require(\"./compareLocations\");\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n\n/** @typedef {import(\"./dependencies/SingleEntryDependency\")} SingleEntryDependency */\n\n/** @typedef {import(\"./dependencies/MultiEntryDependency\")} MultiEntryDependency */\n\n/** @typedef {import(\"./dependencies/DllEntryDependency\")} DllEntryDependency */\n\n/** @typedef {import(\"./dependencies/DependencyReference\")} DependencyReference */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n// TODO use @callback\n\n/** @typedef {{[assetName: string]: Source}} CompilationAssets */\n\n/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */\n\n/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */\n\n/** @typedef {(module: Module) => void} OnModuleCallback */\n\n/** @typedef {(err?: Error|null) => void} Callback */\n\n/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */\n\n/** @typedef {new (...args: any[]) => Dependency} DepConstructor */\n\n/** @typedef {{apply: () => void}} Plugin */\n\n/**\n * @typedef {Object} ModuleFactoryCreateDataContextInfo\n * @property {string} issuer\n * @property {string} compiler\n */\n\n/**\n * @typedef {Object} ModuleFactoryCreateData\n * @property {ModuleFactoryCreateDataContextInfo} contextInfo\n * @property {any=} resolveOptions\n * @property {string} context\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} ModuleFactory\n * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create\n */\n\n/**\n * @typedef {Object} SortedDependency\n * @property {ModuleFactory} factory\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} DependenciesBlockLike\n * @property {Dependency[]} dependencies\n * @property {AsyncDependenciesBlock[]} blocks\n * @property {DependenciesBlockVariable[]} variables\n */\n\n/**\n * @param {Chunk} a first chunk to sort by id\n * @param {Chunk} b second chunk to sort by id\n * @returns {-1|0|1} sort value\n */\n\n\nvar byId = function byId(a, b) {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  return 0;\n};\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nvar byIdOrIdentifier = function byIdOrIdentifier(a, b) {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  var identA = a.identifier();\n  var identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nvar byIndexOrIdentifier = function byIndexOrIdentifier(a, b) {\n  if (a.index < b.index) return -1;\n  if (a.index > b.index) return 1;\n  var identA = a.identifier();\n  var identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n/**\n * @param {Compilation} a first compilation to sort by\n * @param {Compilation} b second compilation to sort by\n * @returns {-1|0|1} sort value\n */\n\n\nvar byNameOrHash = function byNameOrHash(a, b) {\n  if (a.name < b.name) return -1;\n  if (a.name > b.name) return 1;\n  if (a.fullHash < b.fullHash) return -1;\n  if (a.fullHash > b.fullHash) return 1;\n  return 0;\n};\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\n\n\nvar bySetSize = function bySetSize(a, b) {\n  return a.size - b.size;\n};\n/**\n * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over\n * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements\n * @returns {void}\n */\n\n\nvar iterationBlockVariable = function iterationBlockVariable(variables, fn) {\n  for (var indexVariable = 0; indexVariable < variables.length; indexVariable++) {\n    var varDep = variables[indexVariable].dependencies;\n\n    for (var indexVDep = 0; indexVDep < varDep.length; indexVDep++) {\n      fn(varDep[indexVDep]);\n    }\n  }\n};\n/**\n * @template T\n * @param {T[]} arr array of elements to iterate over\n * @param {function(T): void} fn callback applied to each element\n * @returns {void}\n */\n\n\nvar iterationOfArrayCallback = function iterationOfArrayCallback(arr, fn) {\n  for (var index = 0; index < arr.length; index++) {\n    fn(arr[index]);\n  }\n};\n/**\n * @template T\n * @param {Set<T>} set set to add items to\n * @param {Set<T>} otherSet set to add items from\n * @returns {void}\n */\n\n\nvar addAllToSet = function addAllToSet(set, otherSet) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = otherSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var item = _step.value;\n      set.add(item);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n};\n\nvar Compilation =\n/*#__PURE__*/\nfunction (_Tapable) {\n  _inherits(Compilation, _Tapable);\n\n  /**\n   * Creates an instance of Compilation.\n   * @param {Compiler} compiler the compiler which created the compilation\n   */\n  function Compilation(compiler) {\n    var _this;\n\n    _classCallCheck(this, Compilation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Compilation).call(this));\n    _this.hooks = {\n      /** @type {SyncHook<Module>} */\n      buildModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Module>} */\n      rebuildModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Module, Error>} */\n      failedModule: new SyncHook([\"module\", \"error\"]),\n\n      /** @type {SyncHook<Module>} */\n      succeedModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook<Dependency, string>} */\n      addEntry: new SyncHook([\"entry\", \"name\"]),\n\n      /** @type {SyncHook<Dependency, string, Error>} */\n      failedEntry: new SyncHook([\"entry\", \"name\", \"error\"]),\n\n      /** @type {SyncHook<Dependency, string, Module>} */\n      succeedEntry: new SyncHook([\"entry\", \"name\", \"module\"]),\n\n      /** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */\n      dependencyReference: new SyncWaterfallHook([\"dependencyReference\", \"dependency\", \"module\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      finishModules: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module>} */\n      finishRebuildingModule: new SyncHook([\"module\"]),\n\n      /** @type {SyncHook} */\n      unseal: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      seal: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      beforeChunks: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterChunks: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesBasic: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependencies: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesAdvanced: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      afterOptimizeDependencies: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook} */\n      optimize: new SyncHook([]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesBasic: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModules: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesAdvanced: new SyncBailHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModules: new SyncHook([\"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksBasic: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunks: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksAdvanced: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {SyncHook<Chunk[], ChunkGroup[]>} */\n      afterOptimizeChunks: new SyncHook([\"chunks\", \"chunkGroups\"]),\n\n      /** @type {AsyncSeriesHook<Chunk[], Module[]>} */\n      optimizeTree: new AsyncSeriesHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeTree: new SyncHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesBasic: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModules: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesAdvanced: new SyncBailHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeChunkModules: new SyncHook([\"chunks\", \"modules\"]),\n\n      /** @type {SyncBailHook} */\n      shouldRecord: new SyncBailHook([]),\n\n      /** @type {SyncHook<Module[], any>} */\n      reviveModules: new SyncHook([\"modules\", \"records\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleOrder: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      advancedOptimizeModuleOrder: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      beforeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      moduleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModuleIds: new SyncHook([\"modules\"]),\n\n      /** @type {SyncHook<Chunk[], any>} */\n      reviveChunks: new SyncHook([\"chunks\", \"records\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkOrder: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      beforeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkIds: new SyncHook([\"chunks\"]),\n\n      /** @type {SyncHook<Module[], any>} */\n      recordModules: new SyncHook([\"modules\", \"records\"]),\n\n      /** @type {SyncHook<Chunk[], any>} */\n      recordChunks: new SyncHook([\"chunks\", \"records\"]),\n\n      /** @type {SyncHook} */\n      beforeHash: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk>} */\n      contentHash: new SyncHook([\"chunk\"]),\n\n      /** @type {SyncHook} */\n      afterHash: new SyncHook([]),\n\n      /** @type {SyncHook<any>} */\n      recordHash: new SyncHook([\"records\"]),\n\n      /** @type {SyncHook<Compilation, any>} */\n      record: new SyncHook([\"compilation\", \"records\"]),\n\n      /** @type {SyncHook} */\n      beforeModuleAssets: new SyncHook([]),\n\n      /** @type {SyncBailHook} */\n      shouldGenerateChunkAssets: new SyncBailHook([]),\n\n      /** @type {SyncHook} */\n      beforeChunkAssets: new SyncHook([]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      additionalChunkAssets: new SyncHook([\"chunks\"]),\n\n      /** @type {AsyncSeriesHook} */\n      additionalAssets: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<Chunk[]>} */\n      optimizeChunkAssets: new AsyncSeriesHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkAssets: new SyncHook([\"chunks\"]),\n\n      /** @type {AsyncSeriesHook<CompilationAssets>} */\n      optimizeAssets: new AsyncSeriesHook([\"assets\"]),\n\n      /** @type {SyncHook<CompilationAssets>} */\n      afterOptimizeAssets: new SyncHook([\"assets\"]),\n\n      /** @type {SyncBailHook} */\n      needAdditionalSeal: new SyncBailHook([]),\n\n      /** @type {AsyncSeriesHook} */\n      afterSeal: new AsyncSeriesHook([]),\n\n      /** @type {SyncHook<Chunk, Hash>} */\n      chunkHash: new SyncHook([\"chunk\", \"chunkHash\"]),\n\n      /** @type {SyncHook<Module, string>} */\n      moduleAsset: new SyncHook([\"module\", \"filename\"]),\n\n      /** @type {SyncHook<Chunk, string>} */\n      chunkAsset: new SyncHook([\"chunk\", \"filename\"]),\n\n      /** @type {SyncWaterfallHook<string, TODO>} */\n      assetPath: new SyncWaterfallHook([\"filename\", \"data\"]),\n      // TODO MainTemplate\n\n      /** @type {SyncBailHook} */\n      needAdditionalPass: new SyncBailHook([]),\n\n      /** @type {SyncHook<Compiler, string, number>} */\n      childCompiler: new SyncHook([\"childCompiler\", \"compilerName\", \"compilerIndex\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook<object, Module>} */\n      normalModuleLoader: new SyncHook([\"loaderContext\", \"module\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksBasic: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunks: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksAdvanced: new SyncBailHook([\"chunks\"]),\n\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeExtractedChunks: new SyncHook([\"chunks\"])\n    };\n\n    _this._pluginCompat.tap(\"Compilation\", function (options) {\n      switch (options.name) {\n        case \"optimize-tree\":\n        case \"additional-assets\":\n        case \"optimize-chunk-assets\":\n        case \"optimize-assets\":\n        case \"after-seal\":\n          options.async = true;\n          break;\n      }\n    });\n    /** @type {string=} */\n\n\n    _this.name = undefined;\n    /** @type {Compiler} */\n\n    _this.compiler = compiler;\n    _this.resolverFactory = compiler.resolverFactory;\n    _this.inputFileSystem = compiler.inputFileSystem;\n    _this.requestShortener = compiler.requestShortener;\n    var options = compiler.options;\n    _this.options = options;\n    _this.outputOptions = options && options.output;\n    /** @type {boolean=} */\n\n    _this.bail = options && options.bail;\n    _this.profile = options && options.profile;\n    _this.performance = options && options.performance;\n    _this.mainTemplate = new MainTemplate(_this.outputOptions);\n    _this.chunkTemplate = new ChunkTemplate(_this.outputOptions);\n    _this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(_this.outputOptions);\n    _this.runtimeTemplate = new RuntimeTemplate(_this.outputOptions, _this.requestShortener);\n    _this.moduleTemplates = {\n      javascript: new ModuleTemplate(_this.runtimeTemplate, \"javascript\"),\n      webassembly: new ModuleTemplate(_this.runtimeTemplate, \"webassembly\")\n    };\n    _this.semaphore = new Semaphore(options.parallelism || 100);\n    _this.entries = [];\n    /** @private @type {{name: string, request: string, module: Module}[]} */\n\n    _this._preparedEntrypoints = [];\n    _this.entrypoints = new Map();\n    /** @type {Chunk[]} */\n\n    _this.chunks = [];\n    /** @type {ChunkGroup[]} */\n\n    _this.chunkGroups = [];\n    /** @type {Map<string, ChunkGroup>} */\n\n    _this.namedChunkGroups = new Map();\n    /** @type {Map<string, Chunk>} */\n\n    _this.namedChunks = new Map();\n    /** @type {Module[]} */\n\n    _this.modules = [];\n    /** @private @type {Map<string, Module>} */\n\n    _this._modules = new Map();\n    _this.cache = null;\n    _this.records = null;\n    /** @type {string[]} */\n\n    _this.additionalChunkAssets = [];\n    /** @type {CompilationAssets} */\n\n    _this.assets = {};\n    /** @type {WebpackError[]} */\n\n    _this.errors = [];\n    /** @type {WebpackError[]} */\n\n    _this.warnings = [];\n    /** @type {Compilation[]} */\n\n    _this.children = [];\n    /** @type {Map<DepConstructor, ModuleFactory>} */\n\n    _this.dependencyFactories = new Map();\n    /** @type {Map<DepConstructor, DependencyTemplate>} */\n\n    _this.dependencyTemplates = new Map(); // TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property\n    // @ts-ignore\n\n    _this.dependencyTemplates.set(\"hash\", \"\");\n\n    _this.childrenCounters = {};\n    /** @type {Set<number|string>} */\n\n    _this.usedChunkIds = null;\n    /** @type {Set<number>} */\n\n    _this.usedModuleIds = null;\n    /** @type {Map<string, number>=} */\n\n    _this.fileTimestamps = undefined;\n    /** @type {Map<string, number>=} */\n\n    _this.contextTimestamps = undefined;\n    /** @type {Set<string>=} */\n\n    _this.compilationDependencies = undefined;\n    /** @private @type {Map<Module, Callback[]>} */\n\n    _this._buildingModules = new Map();\n    /** @private @type {Map<Module, Callback[]>} */\n\n    _this._rebuildingModules = new Map();\n    return _this;\n  }\n\n  _createClass(Compilation, [{\n    key: \"getStats\",\n    value: function getStats() {\n      return new Stats(this);\n    }\n    /**\n     * @typedef {Object} AddModuleResult\n     * @property {Module} module the added or existing module\n     * @property {boolean} issuer was this the first request for this module\n     * @property {boolean} build should the module be build\n     * @property {boolean} dependencies should dependencies be walked\n     */\n\n    /**\n     * @param {Module} module module to be added that was created\n     * @param {any=} cacheGroup cacheGroup it is apart of\n     * @returns {AddModuleResult} returns meta about whether or not the module had built\n     * had an issuer, or any dependnecies\n     */\n\n  }, {\n    key: \"addModule\",\n    value: function addModule(module, cacheGroup) {\n      var identifier = module.identifier();\n\n      var alreadyAddedModule = this._modules.get(identifier);\n\n      if (alreadyAddedModule) {\n        return {\n          module: alreadyAddedModule,\n          issuer: false,\n          build: false,\n          dependencies: false\n        };\n      }\n\n      var cacheName = (cacheGroup || \"m\") + identifier;\n\n      if (this.cache && this.cache[cacheName]) {\n        var cacheModule = this.cache[cacheName];\n\n        if (typeof cacheModule.updateCacheModule === \"function\") {\n          cacheModule.updateCacheModule(module);\n        }\n\n        var rebuild = true;\n\n        if (this.fileTimestamps && this.contextTimestamps) {\n          rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);\n        }\n\n        if (!rebuild) {\n          cacheModule.disconnect();\n\n          this._modules.set(identifier, cacheModule);\n\n          this.modules.push(cacheModule);\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = cacheModule.errors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var err = _step2.value;\n              this.errors.push(err);\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = cacheModule.warnings[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var _err = _step3.value;\n              this.warnings.push(_err);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          return {\n            module: cacheModule,\n            issuer: true,\n            build: false,\n            dependencies: true\n          };\n        }\n\n        cacheModule.unbuild();\n        module = cacheModule;\n      }\n\n      this._modules.set(identifier, module);\n\n      if (this.cache) {\n        this.cache[cacheName] = module;\n      }\n\n      this.modules.push(module);\n      return {\n        module: module,\n        issuer: true,\n        build: true,\n        dependencies: true\n      };\n    }\n    /**\n     * Fetches a module from a compilation by its identifier\n     * @param {Module} module the module provided\n     * @returns {Module} the module requested\n     */\n\n  }, {\n    key: \"getModule\",\n    value: function getModule(module) {\n      var identifier = module.identifier();\n      return this._modules.get(identifier);\n    }\n    /**\n     * Attempts to search for a module by its identifier\n     * @param {string} identifier identifier (usually path) for module\n     * @returns {Module|undefined} attempt to search for module and return it, else undefined\n     */\n\n  }, {\n    key: \"findModule\",\n    value: function findModule(identifier) {\n      return this._modules.get(identifier);\n    }\n    /**\n     * @param {Module} module module with its callback list\n     * @param {Callback} callback the callback function\n     * @returns {void}\n     */\n\n  }, {\n    key: \"waitForBuildingFinished\",\n    value: function waitForBuildingFinished(module, callback) {\n      var callbackList = this._buildingModules.get(module);\n\n      if (callbackList) {\n        callbackList.push(function () {\n          return callback();\n        });\n      } else {\n        process.nextTick(callback);\n      }\n    }\n    /**\n     * Builds the module object\n     *\n     * @param {Module} module module to be built\n     * @param {boolean} optional optional flag\n     * @param {Module=} origin origin module this module build was requested from\n     * @param {Dependency[]=} dependencies optional dependencies from the module to be built\n     * @param {TODO} thisCallback the callback\n     * @returns {TODO} returns the callback function with results\n     */\n\n  }, {\n    key: \"buildModule\",\n    value: function buildModule(module, optional, origin, dependencies, thisCallback) {\n      var _this2 = this;\n\n      var callbackList = this._buildingModules.get(module);\n\n      if (callbackList) {\n        callbackList.push(thisCallback);\n        return;\n      }\n\n      this._buildingModules.set(module, callbackList = [thisCallback]);\n\n      var callback = function callback(err) {\n        _this2._buildingModules.delete(module);\n\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = callbackList[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var cb = _step4.value;\n            cb(err);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      };\n\n      this.hooks.buildModule.call(module);\n      module.build(this.options, this, this.resolverFactory.get(\"normal\", module.resolveOptions), this.inputFileSystem, function (error) {\n        var errors = module.errors;\n\n        for (var indexError = 0; indexError < errors.length; indexError++) {\n          var err = errors[indexError];\n          err.origin = origin;\n          err.dependencies = dependencies;\n\n          if (optional) {\n            _this2.warnings.push(err);\n          } else {\n            _this2.errors.push(err);\n          }\n        }\n\n        var warnings = module.warnings;\n\n        for (var indexWarning = 0; indexWarning < warnings.length; indexWarning++) {\n          var war = warnings[indexWarning];\n          war.origin = origin;\n          war.dependencies = dependencies;\n\n          _this2.warnings.push(war);\n        }\n\n        var originalMap = module.dependencies.reduce(function (map, v, i) {\n          map.set(v, i);\n          return map;\n        }, new Map());\n        module.dependencies.sort(function (a, b) {\n          var cmp = compareLocations(a.loc, b.loc);\n          if (cmp) return cmp;\n          return originalMap.get(a) - originalMap.get(b);\n        });\n\n        if (error) {\n          _this2.hooks.failedModule.call(module, error);\n\n          return callback(error);\n        }\n\n        _this2.hooks.succeedModule.call(module);\n\n        return callback();\n      });\n    }\n    /**\n     * @param {Module} module to be processed for deps\n     * @param {ModuleCallback} callback callback to be triggered\n     * @returns {void}\n     */\n\n  }, {\n    key: \"processModuleDependencies\",\n    value: function processModuleDependencies(module, callback) {\n      var _this3 = this;\n\n      var dependencies = new Map();\n\n      var addDependency = function addDependency(dep) {\n        var resourceIdent = dep.getResourceIdentifier();\n\n        if (resourceIdent) {\n          var factory = _this3.dependencyFactories.get(dep.constructor);\n\n          if (factory === undefined) {\n            throw new Error(\"No module factory available for dependency type: \".concat(dep.constructor.name));\n          }\n\n          var innerMap = dependencies.get(factory);\n\n          if (innerMap === undefined) {\n            dependencies.set(factory, innerMap = new Map());\n          }\n\n          var list = innerMap.get(resourceIdent);\n          if (list === undefined) innerMap.set(resourceIdent, list = []);\n          list.push(dep);\n        }\n      };\n\n      var addDependenciesBlock = function addDependenciesBlock(block) {\n        if (block.dependencies) {\n          iterationOfArrayCallback(block.dependencies, addDependency);\n        }\n\n        if (block.blocks) {\n          iterationOfArrayCallback(block.blocks, addDependenciesBlock);\n        }\n\n        if (block.variables) {\n          iterationBlockVariable(block.variables, addDependency);\n        }\n      };\n\n      try {\n        addDependenciesBlock(module);\n      } catch (e) {\n        callback(e);\n      }\n\n      var sortedDependencies = [];\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = dependencies[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var pair1 = _step5.value;\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = pair1[1][Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var pair2 = _step6.value;\n              sortedDependencies.push({\n                factory: pair1[0],\n                dependencies: pair2[1]\n              });\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      this.addModuleDependencies(module, sortedDependencies, this.bail, null, true, callback);\n    }\n    /**\n     * @param {Module} module module to add deps to\n     * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through\n     * @param {(boolean|null)=} bail whether to bail or not\n     * @param {TODO} cacheGroup optional cacheGroup\n     * @param {boolean} recursive whether it is recursive traversal\n     * @param {function} callback callback for when dependencies are finished being added\n     * @returns {void}\n     */\n\n  }, {\n    key: \"addModuleDependencies\",\n    value: function addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) {\n      var _this4 = this;\n\n      var start = this.profile && Date.now();\n      var currentProfile = this.profile && {};\n      asyncLib.forEach(dependencies, function (item, callback) {\n        var dependencies = item.dependencies;\n\n        var errorAndCallback = function errorAndCallback(err) {\n          err.origin = module;\n          err.dependencies = dependencies;\n\n          _this4.errors.push(err);\n\n          if (bail) {\n            callback(err);\n          } else {\n            callback();\n          }\n        };\n\n        var warningAndCallback = function warningAndCallback(err) {\n          err.origin = module;\n\n          _this4.warnings.push(err);\n\n          callback();\n        };\n\n        var semaphore = _this4.semaphore;\n        semaphore.acquire(function () {\n          var factory = item.factory;\n          factory.create({\n            contextInfo: {\n              issuer: module.nameForCondition && module.nameForCondition(),\n              compiler: _this4.compiler.name\n            },\n            resolveOptions: module.resolveOptions,\n            context: module.context,\n            dependencies: dependencies\n          }, function (err, dependentModule) {\n            var afterFactory;\n\n            var isOptional = function isOptional() {\n              return dependencies.every(function (d) {\n                return d.optional;\n              });\n            };\n\n            var errorOrWarningAndCallback = function errorOrWarningAndCallback(err) {\n              if (isOptional()) {\n                return warningAndCallback(err);\n              } else {\n                return errorAndCallback(err);\n              }\n            };\n\n            if (err) {\n              semaphore.release();\n              return errorOrWarningAndCallback(new ModuleNotFoundError(module, err));\n            }\n\n            if (!dependentModule) {\n              semaphore.release();\n              return process.nextTick(callback);\n            }\n\n            if (currentProfile) {\n              afterFactory = Date.now();\n              currentProfile.factory = afterFactory - start;\n            }\n\n            var iterationDependencies = function iterationDependencies(depend) {\n              for (var index = 0; index < depend.length; index++) {\n                var dep = depend[index];\n                dep.module = dependentModule;\n                dependentModule.addReason(module, dep);\n              }\n            };\n\n            var addModuleResult = _this4.addModule(dependentModule, cacheGroup);\n\n            dependentModule = addModuleResult.module;\n            iterationDependencies(dependencies);\n\n            var afterBuild = function afterBuild() {\n              if (currentProfile) {\n                var afterBuilding = Date.now();\n                currentProfile.building = afterBuilding - afterFactory;\n              }\n\n              if (recursive && addModuleResult.dependencies) {\n                _this4.processModuleDependencies(dependentModule, callback);\n              } else {\n                return callback();\n              }\n            };\n\n            if (addModuleResult.issuer) {\n              if (currentProfile) {\n                dependentModule.profile = currentProfile;\n              }\n\n              dependentModule.issuer = module;\n            } else {\n              if (_this4.profile) {\n                if (module.profile) {\n                  var time = Date.now() - start;\n\n                  if (!module.profile.dependencies || time > module.profile.dependencies) {\n                    module.profile.dependencies = time;\n                  }\n                }\n              }\n            }\n\n            if (addModuleResult.build) {\n              _this4.buildModule(dependentModule, isOptional(), module, dependencies, function (err) {\n                if (err) {\n                  semaphore.release();\n                  return errorOrWarningAndCallback(err);\n                }\n\n                if (currentProfile) {\n                  var afterBuilding = Date.now();\n                  currentProfile.building = afterBuilding - afterFactory;\n                }\n\n                semaphore.release();\n                afterBuild();\n              });\n            } else {\n              semaphore.release();\n\n              _this4.waitForBuildingFinished(dependentModule, afterBuild);\n            }\n          });\n        });\n      }, function (err) {\n        // In V8, the Error objects keep a reference to the functions on the stack. These warnings &\n        // errors are created inside closures that keep a reference to the Compilation, so errors are\n        // leaking the Compilation object.\n        if (err) {\n          // eslint-disable-next-line no-self-assign\n          err.stack = err.stack;\n          return callback(err);\n        }\n\n        return process.nextTick(callback);\n      });\n    }\n    /**\n     *\n     * @param {string} context context string path\n     * @param {Dependency} dependency dependency used to create Module chain\n     * @param {OnModuleCallback} onModule function invoked on modules creation\n     * @param {ModuleChainCallback} callback callback for when module chain is complete\n     * @returns {void} will throw if dependency instance is not a valid Dependency\n     */\n\n  }, {\n    key: \"_addModuleChain\",\n    value: function _addModuleChain(context, dependency, onModule, callback) {\n      var _this5 = this;\n\n      var start = this.profile && Date.now();\n      var currentProfile = this.profile && {};\n      var errorAndCallback = this.bail ? function (err) {\n        callback(err);\n      } : function (err) {\n        err.dependencies = [dependency];\n\n        _this5.errors.push(err);\n\n        callback();\n      };\n\n      if (typeof dependency !== \"object\" || dependency === null || !dependency.constructor) {\n        throw new Error(\"Parameter 'dependency' must be a Dependency\");\n      }\n\n      var Dep =\n      /** @type {DepConstructor} */\n      dependency.constructor;\n      var moduleFactory = this.dependencyFactories.get(Dep);\n\n      if (!moduleFactory) {\n        throw new Error(\"No dependency factory available for this dependency type: \".concat(dependency.constructor.name));\n      }\n\n      this.semaphore.acquire(function () {\n        moduleFactory.create({\n          contextInfo: {\n            issuer: \"\",\n            compiler: _this5.compiler.name\n          },\n          context: context,\n          dependencies: [dependency]\n        }, function (err, module) {\n          if (err) {\n            _this5.semaphore.release();\n\n            return errorAndCallback(new EntryModuleNotFoundError(err));\n          }\n\n          var afterFactory;\n\n          if (currentProfile) {\n            afterFactory = Date.now();\n            currentProfile.factory = afterFactory - start;\n          }\n\n          var addModuleResult = _this5.addModule(module);\n\n          module = addModuleResult.module;\n          onModule(module);\n          dependency.module = module;\n          module.addReason(null, dependency);\n\n          var afterBuild = function afterBuild() {\n            if (currentProfile) {\n              var afterBuilding = Date.now();\n              currentProfile.building = afterBuilding - afterFactory;\n            }\n\n            if (addModuleResult.dependencies) {\n              _this5.processModuleDependencies(module, function (err) {\n                if (err) return callback(err);\n                callback(null, module);\n              });\n            } else {\n              return callback(null, module);\n            }\n          };\n\n          if (addModuleResult.issuer) {\n            if (currentProfile) {\n              module.profile = currentProfile;\n            }\n          }\n\n          if (addModuleResult.build) {\n            _this5.buildModule(module, false, null, null, function (err) {\n              if (err) {\n                _this5.semaphore.release();\n\n                return errorAndCallback(err);\n              }\n\n              if (currentProfile) {\n                var afterBuilding = Date.now();\n                currentProfile.building = afterBuilding - afterFactory;\n              }\n\n              _this5.semaphore.release();\n\n              afterBuild();\n            });\n          } else {\n            _this5.semaphore.release();\n\n            _this5.waitForBuildingFinished(module, afterBuild);\n          }\n        });\n      });\n    }\n    /**\n     *\n     * @param {string} context context path for entry\n     * @param {Dependency} entry entry dependency being created\n     * @param {string} name name of entry\n     * @param {ModuleCallback} callback callback function\n     * @returns {void} returns\n     */\n\n  }, {\n    key: \"addEntry\",\n    value: function addEntry(context, entry, name, callback) {\n      var _this6 = this;\n\n      this.hooks.addEntry.call(entry, name);\n      var slot = {\n        name: name,\n        // TODO webpack 5 remove `request`\n        request: null,\n        module: null\n      };\n\n      if (entry instanceof ModuleDependency) {\n        slot.request = entry.request;\n      } // TODO webpack 5: merge modules instead when multiple entry modules are supported\n\n\n      var idx = this._preparedEntrypoints.findIndex(function (slot) {\n        return slot.name === name;\n      });\n\n      if (idx >= 0) {\n        // Overwrite existing entrypoint\n        this._preparedEntrypoints[idx] = slot;\n      } else {\n        this._preparedEntrypoints.push(slot);\n      }\n\n      this._addModuleChain(context, entry, function (module) {\n        _this6.entries.push(module);\n      }, function (err, module) {\n        if (err) {\n          _this6.hooks.failedEntry.call(entry, name, err);\n\n          return callback(err);\n        }\n\n        if (module) {\n          slot.module = module;\n        } else {\n          var _idx = _this6._preparedEntrypoints.indexOf(slot);\n\n          if (_idx >= 0) {\n            _this6._preparedEntrypoints.splice(_idx, 1);\n          }\n        }\n\n        _this6.hooks.succeedEntry.call(entry, name, module);\n\n        return callback(null, module);\n      });\n    }\n    /**\n     * @param {string} context context path string\n     * @param {Dependency} dependency dep used to create module\n     * @param {ModuleCallback} callback module callback sending module up a level\n     * @returns {void}\n     */\n\n  }, {\n    key: \"prefetch\",\n    value: function prefetch(context, dependency, callback) {\n      this._addModuleChain(context, dependency, function (module) {\n        module.prefetched = true;\n      }, callback);\n    }\n    /**\n     * @param {Module} module module to be rebuilt\n     * @param {Callback} thisCallback callback when module finishes rebuilding\n     * @returns {void}\n     */\n\n  }, {\n    key: \"rebuildModule\",\n    value: function rebuildModule(module, thisCallback) {\n      var _this7 = this;\n\n      var callbackList = this._rebuildingModules.get(module);\n\n      if (callbackList) {\n        callbackList.push(thisCallback);\n        return;\n      }\n\n      this._rebuildingModules.set(module, callbackList = [thisCallback]);\n\n      var callback = function callback(err) {\n        _this7._rebuildingModules.delete(module);\n\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = callbackList[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var cb = _step7.value;\n            cb(err);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      };\n\n      this.hooks.rebuildModule.call(module);\n      var oldDependencies = module.dependencies.slice();\n      var oldVariables = module.variables.slice();\n      var oldBlocks = module.blocks.slice();\n      module.unbuild();\n      this.buildModule(module, false, module, null, function (err) {\n        if (err) {\n          _this7.hooks.finishRebuildingModule.call(module);\n\n          return callback(err);\n        }\n\n        _this7.processModuleDependencies(module, function (err) {\n          if (err) return callback(err);\n\n          _this7.removeReasonsOfDependencyBlock(module, {\n            dependencies: oldDependencies,\n            variables: oldVariables,\n            blocks: oldBlocks\n          });\n\n          _this7.hooks.finishRebuildingModule.call(module);\n\n          callback();\n        });\n      });\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      var modules = this.modules;\n      this.hooks.finishModules.call(modules);\n\n      for (var index = 0; index < modules.length; index++) {\n        var _module = modules[index];\n        this.reportDependencyErrorsAndWarnings(_module, [_module]);\n      }\n    }\n  }, {\n    key: \"unseal\",\n    value: function unseal() {\n      this.hooks.unseal.call();\n      this.chunks.length = 0;\n      this.chunkGroups.length = 0;\n      this.namedChunks.clear();\n      this.namedChunkGroups.clear();\n      this.additionalChunkAssets.length = 0;\n      this.assets = {};\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this.modules[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var _module2 = _step8.value;\n\n          _module2.unseal();\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n    }\n    /**\n     * @param {Callback} callback signals when the seal method is finishes\n     * @returns {void}\n     */\n\n  }, {\n    key: \"seal\",\n    value: function seal(callback) {\n      var _this8 = this;\n\n      this.hooks.seal.call();\n\n      while (this.hooks.optimizeDependenciesBasic.call(this.modules) || this.hooks.optimizeDependencies.call(this.modules) || this.hooks.optimizeDependenciesAdvanced.call(this.modules)) {\n        /* empty */\n      }\n\n      this.hooks.afterOptimizeDependencies.call(this.modules);\n      this.hooks.beforeChunks.call();\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = this._preparedEntrypoints[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var preparedEntrypoint = _step9.value;\n          var _module3 = preparedEntrypoint.module;\n          var name = preparedEntrypoint.name;\n          var chunk = this.addChunk(name);\n          var entrypoint = new Entrypoint(name);\n          entrypoint.setRuntimeChunk(chunk);\n          entrypoint.addOrigin(null, name, preparedEntrypoint.request);\n          this.namedChunkGroups.set(name, entrypoint);\n          this.entrypoints.set(name, entrypoint);\n          this.chunkGroups.push(entrypoint);\n          GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);\n          GraphHelpers.connectChunkAndModule(chunk, _module3);\n          chunk.entryModule = _module3;\n          chunk.name = name;\n          this.assignDepth(_module3);\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      this.processDependenciesBlocksForChunkGroups(this.chunkGroups.slice());\n      this.sortModules(this.modules);\n      this.hooks.afterChunks.call(this.chunks);\n      this.hooks.optimize.call();\n\n      while (this.hooks.optimizeModulesBasic.call(this.modules) || this.hooks.optimizeModules.call(this.modules) || this.hooks.optimizeModulesAdvanced.call(this.modules)) {\n        /* empty */\n      }\n\n      this.hooks.afterOptimizeModules.call(this.modules);\n\n      while (this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)) {\n        /* empty */\n      }\n\n      this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);\n      this.hooks.optimizeTree.callAsync(this.chunks, this.modules, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        _this8.hooks.afterOptimizeTree.call(_this8.chunks, _this8.modules);\n\n        while (_this8.hooks.optimizeChunkModulesBasic.call(_this8.chunks, _this8.modules) || _this8.hooks.optimizeChunkModules.call(_this8.chunks, _this8.modules) || _this8.hooks.optimizeChunkModulesAdvanced.call(_this8.chunks, _this8.modules)) {\n          /* empty */\n        }\n\n        _this8.hooks.afterOptimizeChunkModules.call(_this8.chunks, _this8.modules);\n\n        var shouldRecord = _this8.hooks.shouldRecord.call() !== false;\n\n        _this8.hooks.reviveModules.call(_this8.modules, _this8.records);\n\n        _this8.hooks.optimizeModuleOrder.call(_this8.modules);\n\n        _this8.hooks.advancedOptimizeModuleOrder.call(_this8.modules);\n\n        _this8.hooks.beforeModuleIds.call(_this8.modules);\n\n        _this8.hooks.moduleIds.call(_this8.modules);\n\n        _this8.applyModuleIds();\n\n        _this8.hooks.optimizeModuleIds.call(_this8.modules);\n\n        _this8.hooks.afterOptimizeModuleIds.call(_this8.modules);\n\n        _this8.sortItemsWithModuleIds();\n\n        _this8.hooks.reviveChunks.call(_this8.chunks, _this8.records);\n\n        _this8.hooks.optimizeChunkOrder.call(_this8.chunks);\n\n        _this8.hooks.beforeChunkIds.call(_this8.chunks);\n\n        _this8.applyChunkIds();\n\n        _this8.hooks.optimizeChunkIds.call(_this8.chunks);\n\n        _this8.hooks.afterOptimizeChunkIds.call(_this8.chunks);\n\n        _this8.sortItemsWithChunkIds();\n\n        if (shouldRecord) {\n          _this8.hooks.recordModules.call(_this8.modules, _this8.records);\n\n          _this8.hooks.recordChunks.call(_this8.chunks, _this8.records);\n        }\n\n        _this8.hooks.beforeHash.call();\n\n        _this8.createHash();\n\n        _this8.hooks.afterHash.call();\n\n        if (shouldRecord) {\n          _this8.hooks.recordHash.call(_this8.records);\n        }\n\n        _this8.hooks.beforeModuleAssets.call();\n\n        _this8.createModuleAssets();\n\n        if (_this8.hooks.shouldGenerateChunkAssets.call() !== false) {\n          _this8.hooks.beforeChunkAssets.call();\n\n          _this8.createChunkAssets();\n        }\n\n        _this8.hooks.additionalChunkAssets.call(_this8.chunks);\n\n        _this8.summarizeDependencies();\n\n        if (shouldRecord) {\n          _this8.hooks.record.call(_this8, _this8.records);\n        }\n\n        _this8.hooks.additionalAssets.callAsync(function (err) {\n          if (err) {\n            return callback(err);\n          }\n\n          _this8.hooks.optimizeChunkAssets.callAsync(_this8.chunks, function (err) {\n            if (err) {\n              return callback(err);\n            }\n\n            _this8.hooks.afterOptimizeChunkAssets.call(_this8.chunks);\n\n            _this8.hooks.optimizeAssets.callAsync(_this8.assets, function (err) {\n              if (err) {\n                return callback(err);\n              }\n\n              _this8.hooks.afterOptimizeAssets.call(_this8.assets);\n\n              if (_this8.hooks.needAdditionalSeal.call()) {\n                _this8.unseal();\n\n                return _this8.seal(callback);\n              }\n\n              return _this8.hooks.afterSeal.callAsync(callback);\n            });\n          });\n        });\n      });\n    }\n    /**\n     * @param {Module[]} modules the modules array on compilation to perform the sort for\n     * @returns {void}\n     */\n\n  }, {\n    key: \"sortModules\",\n    value: function sortModules(modules) {\n      // TODO webpack 5: this should only be enabled when `moduleIds: \"natural\"`\n      // TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply\n      // TODO remove this method\n      modules.sort(byIndexOrIdentifier);\n    }\n    /**\n     * @param {Module} module moulde to report from\n     * @param {DependenciesBlock[]} blocks blocks to report from\n     * @returns {void}\n     */\n\n  }, {\n    key: \"reportDependencyErrorsAndWarnings\",\n    value: function reportDependencyErrorsAndWarnings(module, blocks) {\n      for (var indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n        var block = blocks[indexBlock];\n        var dependencies = block.dependencies;\n\n        for (var indexDep = 0; indexDep < dependencies.length; indexDep++) {\n          var d = dependencies[indexDep];\n          var warnings = d.getWarnings();\n\n          if (warnings) {\n            for (var indexWar = 0; indexWar < warnings.length; indexWar++) {\n              var w = warnings[indexWar];\n              var warning = new ModuleDependencyWarning(module, w, d.loc);\n              this.warnings.push(warning);\n            }\n          }\n\n          var errors = d.getErrors();\n\n          if (errors) {\n            for (var indexErr = 0; indexErr < errors.length; indexErr++) {\n              var e = errors[indexErr];\n              var error = new ModuleDependencyError(module, e, d.loc);\n              this.errors.push(error);\n            }\n          }\n        }\n\n        this.reportDependencyErrorsAndWarnings(module, block.blocks);\n      }\n    }\n    /**\n     * @param {TODO} groupOptions options for the chunk group\n     * @param {Module} module the module the references the chunk group\n     * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)\n     * @param {string} request the request from which the the chunk group is referenced\n     * @returns {ChunkGroup} the new or existing chunk group\n     */\n\n  }, {\n    key: \"addChunkInGroup\",\n    value: function addChunkInGroup(groupOptions, module, loc, request) {\n      if (typeof groupOptions === \"string\") {\n        groupOptions = {\n          name: groupOptions\n        };\n      }\n\n      var name = groupOptions.name;\n\n      if (name) {\n        var _chunkGroup = this.namedChunkGroups.get(name);\n\n        if (_chunkGroup !== undefined) {\n          _chunkGroup.addOptions(groupOptions);\n\n          if (module) {\n            _chunkGroup.addOrigin(module, loc, request);\n          }\n\n          return _chunkGroup;\n        }\n      }\n\n      var chunkGroup = new ChunkGroup(groupOptions);\n      if (module) chunkGroup.addOrigin(module, loc, request);\n      var chunk = this.addChunk(name);\n      GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);\n      this.chunkGroups.push(chunkGroup);\n\n      if (name) {\n        this.namedChunkGroups.set(name, chunkGroup);\n      }\n\n      return chunkGroup;\n    }\n    /**\n     * This method first looks to see if a name is provided for a new chunk,\n     * and first looks to see if any named chunks already exist and reuse that chunk instead.\n     *\n     * @param {string=} name optional chunk name to be provided\n     * @returns {Chunk} create a chunk (invoked during seal event)\n     */\n\n  }, {\n    key: \"addChunk\",\n    value: function addChunk(name) {\n      if (name) {\n        var _chunk = this.namedChunks.get(name);\n\n        if (_chunk !== undefined) {\n          return _chunk;\n        }\n      }\n\n      var chunk = new Chunk(name);\n      this.chunks.push(chunk);\n\n      if (name) {\n        this.namedChunks.set(name, chunk);\n      }\n\n      return chunk;\n    }\n    /**\n     * @param {Module} module module to assign depth\n     * @returns {void}\n     */\n\n  }, {\n    key: \"assignDepth\",\n    value: function assignDepth(module) {\n      var queue = new Set([module]);\n      var depth;\n      module.depth = 0;\n      /**\n       * @param {Module} module module for processeing\n       * @returns {void}\n       */\n\n      var enqueueJob = function enqueueJob(module) {\n        var d = module.depth;\n        if (typeof d === \"number\" && d <= depth) return;\n        queue.add(module);\n        module.depth = depth;\n      };\n      /**\n       * @param {Dependency} dependency dependency to assign depth to\n       * @returns {void}\n       */\n\n\n      var assignDepthToDependency = function assignDepthToDependency(dependency) {\n        if (dependency.module) {\n          enqueueJob(dependency.module);\n        }\n      };\n      /**\n       * @param {DependenciesBlock} block block to assign depth to\n       * @returns {void}\n       */\n\n\n      var assignDepthToDependencyBlock = function assignDepthToDependencyBlock(block) {\n        if (block.variables) {\n          iterationBlockVariable(block.variables, assignDepthToDependency);\n        }\n\n        if (block.dependencies) {\n          iterationOfArrayCallback(block.dependencies, assignDepthToDependency);\n        }\n\n        if (block.blocks) {\n          iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);\n        }\n      };\n\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = queue[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          module = _step10.value;\n          queue.delete(module);\n          depth = module.depth;\n          depth++;\n          assignDepthToDependencyBlock(module);\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n    /**\n     * @param {Module} module the module containing the dependency\n     * @param {Dependency} dependency the dependency\n     * @returns {DependencyReference} a reference for the dependency\n     */\n\n  }, {\n    key: \"getDependencyReference\",\n    value: function getDependencyReference(module, dependency) {\n      // TODO remove dep.getReference existence check in webpack 5\n      if (typeof dependency.getReference !== \"function\") return null;\n      var ref = dependency.getReference();\n      if (!ref) return null;\n      return this.hooks.dependencyReference.call(ref, dependency, module);\n    }\n    /**\n     * This method creates the Chunk graph from the Module graph\n     * @private\n     * @param {TODO[]} inputChunkGroups chunk groups which are processed\n     * @returns {void}\n     */\n\n  }, {\n    key: \"processDependenciesBlocksForChunkGroups\",\n    value: function processDependenciesBlocksForChunkGroups(inputChunkGroups) {\n      var _this9 = this;\n\n      // Process is splitting into two parts:\n      // Part one traverse the module graph and builds a very basic chunks graph\n      //   in chunkDependencies.\n      // Part two traverse every possible way through the basic chunk graph and\n      //   tracks the available modules. While traversing it connects chunks with\n      //   eachother and Blocks with Chunks. It stops traversing when all modules\n      //   for a chunk are already available. So it doesn't connect unneeded chunks.\n\n      /** @type {Map<ChunkGroup, {block: AsyncDependenciesBlock, chunkGroup: ChunkGroup, couldBeFiltered: boolean}[]>} */\n      var chunkDependencies = new Map();\n      var allCreatedChunkGroups = new Set(); // PREPARE\n\n      /** @type {Map<DependenciesBlock, { modules: Module[], blocks: AsyncDependenciesBlock[]}>} */\n\n      var blockInfoMap = new Map();\n      /**\n       * @param {Dependency} d dependency to iterate over\n       * @returns {void}\n       */\n\n      var iteratorDependency = function iteratorDependency(d) {\n        // We skip Dependencies without Reference\n        var ref = _this9.getDependencyReference(currentModule, d);\n\n        if (!ref) {\n          return;\n        } // We skip Dependencies without Module pointer\n\n\n        var refModule = ref.module;\n\n        if (!refModule) {\n          return;\n        } // We skip weak Dependencies\n\n\n        if (ref.weak) {\n          return;\n        }\n\n        blockInfoModules.add(refModule);\n      };\n      /**\n       * @param {AsyncDependenciesBlock} b blocks to prepare\n       * @returns {void}\n       */\n\n\n      var iteratorBlockPrepare = function iteratorBlockPrepare(b) {\n        blockInfoBlocks.push(b);\n        blockQueue.push(b);\n      };\n      /** @type {Module} */\n\n\n      var currentModule;\n      /** @type {DependenciesBlock} */\n\n      var block;\n      /** @type {DependenciesBlock[]} */\n\n      var blockQueue;\n      /** @type {Set<Module>} */\n\n      var blockInfoModules;\n      /** @type {AsyncDependenciesBlock[]} */\n\n      var blockInfoBlocks;\n      var _iteratorNormalCompletion11 = true;\n      var _didIteratorError11 = false;\n      var _iteratorError11 = undefined;\n\n      try {\n        for (var _iterator11 = this.modules[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n          var _module5 = _step11.value;\n          blockQueue = [_module5];\n          currentModule = _module5;\n\n          while (blockQueue.length > 0) {\n            block = blockQueue.pop();\n            blockInfoModules = new Set();\n            blockInfoBlocks = [];\n\n            if (block.variables) {\n              iterationBlockVariable(block.variables, iteratorDependency);\n            }\n\n            if (block.dependencies) {\n              iterationOfArrayCallback(block.dependencies, iteratorDependency);\n            }\n\n            if (block.blocks) {\n              iterationOfArrayCallback(block.blocks, iteratorBlockPrepare);\n            }\n\n            var _blockInfo = {\n              modules: Array.from(blockInfoModules),\n              blocks: blockInfoBlocks\n            };\n            blockInfoMap.set(block, _blockInfo);\n          }\n        } // PART ONE\n\n        /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\n      } catch (err) {\n        _didIteratorError11 = true;\n        _iteratorError11 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n            _iterator11.return();\n          }\n        } finally {\n          if (_didIteratorError11) {\n            throw _iteratorError11;\n          }\n        }\n      }\n\n      var chunkGroupCounters = new Map();\n      var _iteratorNormalCompletion12 = true;\n      var _didIteratorError12 = false;\n      var _iteratorError12 = undefined;\n\n      try {\n        for (var _iterator12 = inputChunkGroups[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n          var _chunkGroup2 = _step12.value;\n          chunkGroupCounters.set(_chunkGroup2, {\n            index: 0,\n            index2: 0\n          });\n        }\n      } catch (err) {\n        _didIteratorError12 = true;\n        _iteratorError12 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n            _iterator12.return();\n          }\n        } finally {\n          if (_didIteratorError12) {\n            throw _iteratorError12;\n          }\n        }\n      }\n\n      var nextFreeModuleIndex = 0;\n      var nextFreeModuleIndex2 = 0;\n      /** @type {Map<DependenciesBlock, ChunkGroup>} */\n\n      var blockChunkGroups = new Map();\n      /** @type {Set<DependenciesBlock>} */\n\n      var blocksWithNestedBlocks = new Set();\n      var ADD_AND_ENTER_MODULE = 0;\n      var ENTER_MODULE = 1;\n      var PROCESS_BLOCK = 2;\n      var LEAVE_MODULE = 3;\n      /**\n       * @typedef {Object} QueueItem\n       * @property {number} action\n       * @property {DependenciesBlock} block\n       * @property {Module} module\n       * @property {Chunk} chunk\n       * @property {ChunkGroup} chunkGroup\n       */\n\n      /**\n       * @param {ChunkGroup} chunkGroup chunk group\n       * @returns {QueueItem} queue item\n       */\n\n      var chunkGroupToQueueItem = function chunkGroupToQueueItem(chunkGroup) {\n        return {\n          action: ENTER_MODULE,\n          block: chunkGroup.chunks[0].entryModule,\n          module: chunkGroup.chunks[0].entryModule,\n          chunk: chunkGroup.chunks[0],\n          chunkGroup: chunkGroup\n        };\n      }; // Start with the provided modules/chunks\n\n      /** @type {QueueItem[]} */\n\n\n      var queue = inputChunkGroups.map(chunkGroupToQueueItem).reverse();\n      /** @type {QueueItem[]} */\n\n      var queueDelayed = [];\n      /** @type {Module} */\n\n      var module;\n      /** @type {Chunk} */\n\n      var chunk;\n      /** @type {ChunkGroup} */\n\n      var chunkGroup; // For each async Block in graph\n\n      /**\n       * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n       * @returns {void}\n       */\n\n      var iteratorBlock = function iteratorBlock(b) {\n        // 1. We create a chunk for this Block\n        // but only once (blockChunkGroups map)\n        var c = blockChunkGroups.get(b);\n\n        if (c === undefined) {\n          c = _this9.namedChunkGroups.get(b.chunkName);\n\n          if (c && c.isInitial()) {\n            _this9.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n\n            c = chunkGroup;\n          } else {\n            c = _this9.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n            chunkGroupCounters.set(c, {\n              index: 0,\n              index2: 0\n            });\n            blockChunkGroups.set(b, c);\n            allCreatedChunkGroups.add(c);\n          }\n        } else {\n          // TODO webpack 5 remove addOptions check\n          if (c.addOptions) c.addOptions(b.groupOptions);\n          c.addOrigin(module, b.loc, b.request);\n        } // 2. We store the Block+Chunk mapping as dependency for the chunk\n\n\n        var deps = chunkDependencies.get(chunkGroup);\n        if (!deps) chunkDependencies.set(chunkGroup, deps = []);\n        deps.push({\n          block: b,\n          chunkGroup: c,\n          couldBeFiltered: true\n        }); // 3. We enqueue the DependenciesBlock for traversal\n\n        queueDelayed.push({\n          action: PROCESS_BLOCK,\n          block: b,\n          module: module,\n          chunk: c.chunks[0],\n          chunkGroup: c\n        });\n      }; // Iterative traversal of the Module graph\n      // Recursive would be simpler to write but could result in Stack Overflows\n\n\n      while (queue.length) {\n        while (queue.length) {\n          var queueItem = queue.pop();\n          module = queueItem.module;\n          block = queueItem.block;\n          chunk = queueItem.chunk;\n          chunkGroup = queueItem.chunkGroup;\n\n          switch (queueItem.action) {\n            case ADD_AND_ENTER_MODULE:\n              {\n                // We connect Module and Chunk when not already done\n                if (chunk.addModule(module)) {\n                  module.addChunk(chunk);\n                } else {\n                  // already connected, skip it\n                  break;\n                }\n              }\n            // fallthrough\n\n            case ENTER_MODULE:\n              {\n                if (chunkGroup !== undefined) {\n                  var index = chunkGroup.getModuleIndex(module);\n\n                  if (index === undefined) {\n                    chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n                  }\n                }\n\n                if (module.index === null) {\n                  module.index = nextFreeModuleIndex++;\n                }\n\n                queue.push({\n                  action: LEAVE_MODULE,\n                  block: block,\n                  module: module,\n                  chunk: chunk,\n                  chunkGroup: chunkGroup\n                });\n              }\n            // fallthrough\n\n            case PROCESS_BLOCK:\n              {\n                // get prepared block info\n                var blockInfo = blockInfoMap.get(block); // Traverse all referenced modules\n\n                for (var i = blockInfo.modules.length - 1; i >= 0; i--) {\n                  var refModule = blockInfo.modules[i];\n\n                  if (chunk.containsModule(refModule)) {\n                    // skip early if already connected\n                    continue;\n                  } // enqueue the add and enter to enter in the correct order\n                  // this is relevant with circular dependencies\n\n\n                  queue.push({\n                    action: ADD_AND_ENTER_MODULE,\n                    block: refModule,\n                    module: refModule,\n                    chunk: chunk,\n                    chunkGroup: chunkGroup\n                  });\n                } // Traverse all Blocks\n\n\n                iterationOfArrayCallback(blockInfo.blocks, iteratorBlock);\n\n                if (blockInfo.blocks.length > 0 && module !== block) {\n                  blocksWithNestedBlocks.add(block);\n                }\n\n                break;\n              }\n\n            case LEAVE_MODULE:\n              {\n                if (chunkGroup !== undefined) {\n                  var _index = chunkGroup.getModuleIndex2(module);\n\n                  if (_index === undefined) {\n                    chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n                  }\n                }\n\n                if (module.index2 === null) {\n                  module.index2 = nextFreeModuleIndex2++;\n                }\n\n                break;\n              }\n          }\n        }\n\n        var tempQueue = queue;\n        queue = queueDelayed.reverse();\n        queueDelayed = tempQueue;\n      } // PART TWO\n\n      /** @type {Set<Module>} */\n\n\n      var newAvailableModules;\n      /**\n       * @typedef {Object} ChunkGroupInfo\n       * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n       * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n       */\n\n      /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n      var chunkGroupInfoMap = new Map();\n      /** @type {Queue<ChunkGroup>} */\n\n      var queue2 = new Queue(inputChunkGroups);\n      var _iteratorNormalCompletion13 = true;\n      var _didIteratorError13 = false;\n      var _iteratorError13 = undefined;\n\n      try {\n        for (var _iterator13 = inputChunkGroups[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n          var _chunkGroup3 = _step13.value;\n          chunkGroupInfoMap.set(_chunkGroup3, {\n            minAvailableModules: undefined,\n            availableModulesToBeMerged: [new Set()]\n          });\n        }\n        /**\n         * Helper function to check if all modules of a chunk are available\n         *\n         * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n         * @param {Set<Module>} availableModules the comparitor set\n         * @returns {boolean} return true if all modules of a chunk are available\n         */\n\n      } catch (err) {\n        _didIteratorError13 = true;\n        _iteratorError13 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n            _iterator13.return();\n          }\n        } finally {\n          if (_didIteratorError13) {\n            throw _iteratorError13;\n          }\n        }\n      }\n\n      var areModulesAvailable = function areModulesAvailable(chunkGroup, availableModules) {\n        var _iteratorNormalCompletion14 = true;\n        var _didIteratorError14 = false;\n        var _iteratorError14 = undefined;\n\n        try {\n          for (var _iterator14 = chunkGroup.chunks[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n            var _chunk2 = _step14.value;\n            var _iteratorNormalCompletion15 = true;\n            var _didIteratorError15 = false;\n            var _iteratorError15 = undefined;\n\n            try {\n              for (var _iterator15 = _chunk2.modulesIterable[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                var _module4 = _step15.value;\n                if (!availableModules.has(_module4)) return false;\n              }\n            } catch (err) {\n              _didIteratorError15 = true;\n              _iteratorError15 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n                  _iterator15.return();\n                }\n              } finally {\n                if (_didIteratorError15) {\n                  throw _iteratorError15;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError14 = true;\n          _iteratorError14 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n              _iterator14.return();\n            }\n          } finally {\n            if (_didIteratorError14) {\n              throw _iteratorError14;\n            }\n          }\n        }\n\n        return true;\n      }; // For each edge in the basic chunk graph\n\n      /**\n       * @param {TODO} dep the dependency used for filtering\n       * @returns {boolean} used to filter \"edges\" (aka Dependencies) that were pointing\n       * to modules that are already available. Also filters circular dependencies in the chunks graph\n       */\n\n\n      var filterFn = function filterFn(dep) {\n        var depChunkGroup = dep.chunkGroup;\n        if (!dep.couldBeFiltered) return true;\n        if (blocksWithNestedBlocks.has(dep.block)) return true;\n\n        if (areModulesAvailable(depChunkGroup, newAvailableModules)) {\n          return false; // break all modules are already available\n        }\n\n        dep.couldBeFiltered = false;\n        return true;\n      }; // Iterative traversing of the basic chunk graph\n\n\n      while (queue2.length) {\n        chunkGroup = queue2.dequeue();\n        var info = chunkGroupInfoMap.get(chunkGroup);\n        var availableModulesToBeMerged = info.availableModulesToBeMerged;\n        var minAvailableModules = info.minAvailableModules; // 1. Get minimal available modules\n        // It doesn't make sense to traverse a chunk again with more available modules.\n        // This step calculates the minimal available modules and skips traversal when\n        // the list didn't shrink.\n\n        availableModulesToBeMerged.sort(bySetSize);\n        var changed = false;\n        var _iteratorNormalCompletion16 = true;\n        var _didIteratorError16 = false;\n        var _iteratorError16 = undefined;\n\n        try {\n          for (var _iterator16 = availableModulesToBeMerged[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n            var availableModules = _step16.value;\n\n            if (minAvailableModules === undefined) {\n              minAvailableModules = new Set(availableModules);\n              info.minAvailableModules = minAvailableModules;\n              changed = true;\n            } else {\n              var _iteratorNormalCompletion19 = true;\n              var _didIteratorError19 = false;\n              var _iteratorError19 = undefined;\n\n              try {\n                for (var _iterator19 = minAvailableModules[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n                  var m = _step19.value;\n\n                  if (!availableModules.has(m)) {\n                    minAvailableModules.delete(m);\n                    changed = true;\n                  }\n                }\n              } catch (err) {\n                _didIteratorError19 = true;\n                _iteratorError19 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n                    _iterator19.return();\n                  }\n                } finally {\n                  if (_didIteratorError19) {\n                    throw _iteratorError19;\n                  }\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError16 = true;\n          _iteratorError16 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n              _iterator16.return();\n            }\n          } finally {\n            if (_didIteratorError16) {\n              throw _iteratorError16;\n            }\n          }\n        }\n\n        availableModulesToBeMerged.length = 0;\n        if (!changed) continue; // 2. Get the edges at this point of the graph\n\n        var deps = chunkDependencies.get(chunkGroup);\n        if (!deps) continue;\n        if (deps.length === 0) continue; // 3. Create a new Set of available modules at this points\n\n        newAvailableModules = new Set(minAvailableModules);\n        var _iteratorNormalCompletion17 = true;\n        var _didIteratorError17 = false;\n        var _iteratorError17 = undefined;\n\n        try {\n          for (var _iterator17 = chunkGroup.chunks[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n            var _chunk3 = _step17.value;\n            var _iteratorNormalCompletion20 = true;\n            var _didIteratorError20 = false;\n            var _iteratorError20 = undefined;\n\n            try {\n              for (var _iterator20 = _chunk3.modulesIterable[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n                var _m = _step20.value;\n                newAvailableModules.add(_m);\n              }\n            } catch (err) {\n              _didIteratorError20 = true;\n              _iteratorError20 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n                  _iterator20.return();\n                }\n              } finally {\n                if (_didIteratorError20) {\n                  throw _iteratorError20;\n                }\n              }\n            }\n          } // 4. Foreach remaining edge\n\n        } catch (err) {\n          _didIteratorError17 = true;\n          _iteratorError17 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n              _iterator17.return();\n            }\n          } finally {\n            if (_didIteratorError17) {\n              throw _iteratorError17;\n            }\n          }\n        }\n\n        var nextChunkGroups = new Set();\n\n        for (var _i = 0; _i < deps.length; _i++) {\n          var dep = deps[_i]; // Filter inline, rather than creating a new array from `.filter()`\n\n          if (!filterFn(dep)) {\n            continue;\n          }\n\n          var depChunkGroup = dep.chunkGroup;\n          var depBlock = dep.block; // 5. Connect block with chunk\n\n          GraphHelpers.connectDependenciesBlockAndChunkGroup(depBlock, depChunkGroup); // 6. Connect chunk with parent\n\n          GraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup);\n          nextChunkGroups.add(depChunkGroup);\n        } // 7. Enqueue further traversal\n\n\n        var _iteratorNormalCompletion18 = true;\n        var _didIteratorError18 = false;\n        var _iteratorError18 = undefined;\n\n        try {\n          for (var _iterator18 = nextChunkGroups[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n            var nextChunkGroup = _step18.value;\n            var nextInfo = chunkGroupInfoMap.get(nextChunkGroup);\n\n            if (nextInfo === undefined) {\n              nextInfo = {\n                minAvailableModules: undefined,\n                availableModulesToBeMerged: []\n              };\n              chunkGroupInfoMap.set(nextChunkGroup, nextInfo);\n            }\n\n            nextInfo.availableModulesToBeMerged.push(newAvailableModules); // As queue deduplicates enqueued items this makes sure that a ChunkGroup\n            // is not enqueued twice\n\n            queue2.enqueue(nextChunkGroup);\n          }\n        } catch (err) {\n          _didIteratorError18 = true;\n          _iteratorError18 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n              _iterator18.return();\n            }\n          } finally {\n            if (_didIteratorError18) {\n              throw _iteratorError18;\n            }\n          }\n        }\n      } // Remove all unconnected chunk groups\n\n\n      var _iteratorNormalCompletion21 = true;\n      var _didIteratorError21 = false;\n      var _iteratorError21 = undefined;\n\n      try {\n        for (var _iterator21 = allCreatedChunkGroups[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n          var _chunkGroup4 = _step21.value;\n\n          if (_chunkGroup4.getNumberOfParents() === 0) {\n            var _iteratorNormalCompletion22 = true;\n            var _didIteratorError22 = false;\n            var _iteratorError22 = undefined;\n\n            try {\n              for (var _iterator22 = _chunkGroup4.chunks[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n                var _chunk4 = _step22.value;\n                var idx = this.chunks.indexOf(_chunk4);\n                if (idx >= 0) this.chunks.splice(idx, 1);\n\n                _chunk4.remove(\"unconnected\");\n              }\n            } catch (err) {\n              _didIteratorError22 = true;\n              _iteratorError22 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n                  _iterator22.return();\n                }\n              } finally {\n                if (_didIteratorError22) {\n                  throw _iteratorError22;\n                }\n              }\n            }\n\n            _chunkGroup4.remove(\"unconnected\");\n          }\n        }\n      } catch (err) {\n        _didIteratorError21 = true;\n        _iteratorError21 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n            _iterator21.return();\n          }\n        } finally {\n          if (_didIteratorError21) {\n            throw _iteratorError21;\n          }\n        }\n      }\n    }\n    /**\n     *\n     * @param {Module} module module relationship for removal\n     * @param {DependenciesBlockLike} block //TODO: good description\n     * @returns {void}\n     */\n\n  }, {\n    key: \"removeReasonsOfDependencyBlock\",\n    value: function removeReasonsOfDependencyBlock(module, block) {\n      var _this10 = this;\n\n      var iteratorDependency = function iteratorDependency(d) {\n        if (!d.module) {\n          return;\n        }\n\n        if (d.module.removeReason(module, d)) {\n          var _iteratorNormalCompletion23 = true;\n          var _didIteratorError23 = false;\n          var _iteratorError23 = undefined;\n\n          try {\n            for (var _iterator23 = d.module.chunksIterable[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {\n              var chunk = _step23.value;\n\n              _this10.patchChunksAfterReasonRemoval(d.module, chunk);\n            }\n          } catch (err) {\n            _didIteratorError23 = true;\n            _iteratorError23 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion23 && _iterator23.return != null) {\n                _iterator23.return();\n              }\n            } finally {\n              if (_didIteratorError23) {\n                throw _iteratorError23;\n              }\n            }\n          }\n        }\n      };\n\n      if (block.blocks) {\n        iterationOfArrayCallback(block.blocks, function (block) {\n          return _this10.removeReasonsOfDependencyBlock(module, block);\n        });\n      }\n\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, iteratorDependency);\n      }\n\n      if (block.variables) {\n        iterationBlockVariable(block.variables, iteratorDependency);\n      }\n    }\n    /**\n     * @param {Module} module module to patch tie\n     * @param {Chunk} chunk chunk to patch tie\n     * @returns {void}\n     */\n\n  }, {\n    key: \"patchChunksAfterReasonRemoval\",\n    value: function patchChunksAfterReasonRemoval(module, chunk) {\n      if (!module.hasReasons()) {\n        this.removeReasonsOfDependencyBlock(module, module);\n      }\n\n      if (!module.hasReasonForChunk(chunk)) {\n        if (module.removeChunk(chunk)) {\n          this.removeChunkFromDependencies(module, chunk);\n        }\n      }\n    }\n    /**\n     *\n     * @param {DependenciesBlock} block block tie for Chunk\n     * @param {Chunk} chunk chunk to remove from dep\n     * @returns {void}\n     */\n\n  }, {\n    key: \"removeChunkFromDependencies\",\n    value: function removeChunkFromDependencies(block, chunk) {\n      var _this11 = this;\n\n      var iteratorDependency = function iteratorDependency(d) {\n        if (!d.module) {\n          return;\n        }\n\n        _this11.patchChunksAfterReasonRemoval(d.module, chunk);\n      };\n\n      var blocks = block.blocks;\n\n      for (var indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n        var asyncBlock = blocks[indexBlock]; // Grab all chunks from the first Block's AsyncDepBlock\n\n        var chunks = asyncBlock.chunkGroup.chunks; // For each chunk in chunkGroup\n\n        for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n          var iteratedChunk = chunks[indexChunk];\n          asyncBlock.chunkGroup.removeChunk(iteratedChunk);\n          asyncBlock.chunkGroup.removeParent(iteratedChunk); // Recurse\n\n          this.removeChunkFromDependencies(block, iteratedChunk);\n        }\n      }\n\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, iteratorDependency);\n      }\n\n      if (block.variables) {\n        iterationBlockVariable(block.variables, iteratorDependency);\n      }\n    }\n  }, {\n    key: \"applyModuleIds\",\n    value: function applyModuleIds() {\n      var unusedIds = [];\n      var nextFreeModuleId = 0;\n      var usedIds = new Set();\n\n      if (this.usedModuleIds) {\n        var _iteratorNormalCompletion24 = true;\n        var _didIteratorError24 = false;\n        var _iteratorError24 = undefined;\n\n        try {\n          for (var _iterator24 = this.usedModuleIds[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {\n            var id = _step24.value;\n            usedIds.add(id);\n          }\n        } catch (err) {\n          _didIteratorError24 = true;\n          _iteratorError24 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion24 && _iterator24.return != null) {\n              _iterator24.return();\n            }\n          } finally {\n            if (_didIteratorError24) {\n              throw _iteratorError24;\n            }\n          }\n        }\n      }\n\n      var modules1 = this.modules;\n\n      for (var indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {\n        var module1 = modules1[indexModule1];\n\n        if (module1.id !== null) {\n          usedIds.add(module1.id);\n        }\n      }\n\n      if (usedIds.size > 0) {\n        var usedIdMax = -1;\n        var _iteratorNormalCompletion25 = true;\n        var _didIteratorError25 = false;\n        var _iteratorError25 = undefined;\n\n        try {\n          for (var _iterator25 = usedIds[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {\n            var usedIdKey = _step25.value;\n\n            if (typeof usedIdKey !== \"number\") {\n              continue;\n            }\n\n            usedIdMax = Math.max(usedIdMax, usedIdKey);\n          }\n        } catch (err) {\n          _didIteratorError25 = true;\n          _iteratorError25 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion25 && _iterator25.return != null) {\n              _iterator25.return();\n            }\n          } finally {\n            if (_didIteratorError25) {\n              throw _iteratorError25;\n            }\n          }\n        }\n\n        var lengthFreeModules = nextFreeModuleId = usedIdMax + 1;\n\n        while (lengthFreeModules--) {\n          if (!usedIds.has(lengthFreeModules)) {\n            unusedIds.push(lengthFreeModules);\n          }\n        }\n      }\n\n      var modules2 = this.modules;\n\n      for (var indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {\n        var module2 = modules2[indexModule2];\n\n        if (module2.id === null) {\n          if (unusedIds.length > 0) {\n            module2.id = unusedIds.pop();\n          } else {\n            module2.id = nextFreeModuleId++;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"applyChunkIds\",\n    value: function applyChunkIds() {\n      /** @type {Set<number>} */\n      var usedIds = new Set(); // Get used ids from usedChunkIds property (i. e. from records)\n\n      if (this.usedChunkIds) {\n        var _iteratorNormalCompletion26 = true;\n        var _didIteratorError26 = false;\n        var _iteratorError26 = undefined;\n\n        try {\n          for (var _iterator26 = this.usedChunkIds[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {\n            var id = _step26.value;\n\n            if (typeof id !== \"number\") {\n              continue;\n            }\n\n            usedIds.add(id);\n          }\n        } catch (err) {\n          _didIteratorError26 = true;\n          _iteratorError26 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion26 && _iterator26.return != null) {\n              _iterator26.return();\n            }\n          } finally {\n            if (_didIteratorError26) {\n              throw _iteratorError26;\n            }\n          }\n        }\n      } // Get used ids from existing chunks\n\n\n      var chunks = this.chunks;\n\n      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n        var chunk = chunks[indexChunk];\n        var usedIdValue = chunk.id;\n\n        if (typeof usedIdValue !== \"number\") {\n          continue;\n        }\n\n        usedIds.add(usedIdValue);\n      } // Calculate maximum assigned chunk id\n\n\n      var nextFreeChunkId = -1;\n      var _iteratorNormalCompletion27 = true;\n      var _didIteratorError27 = false;\n      var _iteratorError27 = undefined;\n\n      try {\n        for (var _iterator27 = usedIds[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {\n          var _id = _step27.value;\n          nextFreeChunkId = Math.max(nextFreeChunkId, _id);\n        }\n      } catch (err) {\n        _didIteratorError27 = true;\n        _iteratorError27 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion27 && _iterator27.return != null) {\n            _iterator27.return();\n          }\n        } finally {\n          if (_didIteratorError27) {\n            throw _iteratorError27;\n          }\n        }\n      }\n\n      nextFreeChunkId++; // Determine free chunk ids from 0 to maximum\n\n      /** @type {number[]} */\n\n      var unusedIds = [];\n\n      if (nextFreeChunkId > 0) {\n        var index = nextFreeChunkId;\n\n        while (index--) {\n          if (!usedIds.has(index)) {\n            unusedIds.push(index);\n          }\n        }\n      } // Assign ids to chunk which has no id\n\n\n      for (var _indexChunk = 0; _indexChunk < chunks.length; _indexChunk++) {\n        var _chunk5 = chunks[_indexChunk];\n\n        if (_chunk5.id === null) {\n          if (unusedIds.length > 0) {\n            _chunk5.id = unusedIds.pop();\n          } else {\n            _chunk5.id = nextFreeChunkId++;\n          }\n        }\n\n        if (!_chunk5.ids) {\n          _chunk5.ids = [_chunk5.id];\n        }\n      }\n    }\n  }, {\n    key: \"sortItemsWithModuleIds\",\n    value: function sortItemsWithModuleIds() {\n      this.modules.sort(byIdOrIdentifier);\n      var modules = this.modules;\n\n      for (var indexModule = 0; indexModule < modules.length; indexModule++) {\n        modules[indexModule].sortItems(false);\n      }\n\n      var chunks = this.chunks;\n\n      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n        chunks[indexChunk].sortItems();\n      }\n\n      chunks.sort(function (a, b) {\n        return a.compareTo(b);\n      });\n    }\n  }, {\n    key: \"sortItemsWithChunkIds\",\n    value: function sortItemsWithChunkIds() {\n      var _iteratorNormalCompletion28 = true;\n      var _didIteratorError28 = false;\n      var _iteratorError28 = undefined;\n\n      try {\n        for (var _iterator28 = this.chunkGroups[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {\n          var chunkGroup = _step28.value;\n          chunkGroup.sortItems();\n        }\n      } catch (err) {\n        _didIteratorError28 = true;\n        _iteratorError28 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion28 && _iterator28.return != null) {\n            _iterator28.return();\n          }\n        } finally {\n          if (_didIteratorError28) {\n            throw _iteratorError28;\n          }\n        }\n      }\n\n      this.chunks.sort(byId);\n\n      for (var indexModule = 0; indexModule < this.modules.length; indexModule++) {\n        this.modules[indexModule].sortItems(true);\n      }\n\n      var chunks = this.chunks;\n\n      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n        chunks[indexChunk].sortItems();\n      }\n      /**\n       * Used to sort errors and warnings in compilation. this.warnings, and\n       * this.errors contribute to the compilation hash and therefore should be\n       * updated whenever other references (having a chunk id) are sorted. This preserves the hash\n       * integrity\n       *\n       * @param {WebpackError} a first WebpackError instance (including subclasses)\n       * @param {WebpackError} b second WebpackError instance (including subclasses)\n       * @returns {-1|0|1} sort order index\n       */\n\n\n      var byMessage = function byMessage(a, b) {\n        var ma = \"\".concat(a.message);\n        var mb = \"\".concat(b.message);\n        if (ma < mb) return -1;\n        if (mb < ma) return 1;\n        return 0;\n      };\n\n      this.errors.sort(byMessage);\n      this.warnings.sort(byMessage);\n      this.children.sort(byNameOrHash);\n    }\n  }, {\n    key: \"summarizeDependencies\",\n    value: function summarizeDependencies() {\n      this.fileDependencies = new SortableSet(this.compilationDependencies);\n      this.contextDependencies = new SortableSet();\n      this.missingDependencies = new SortableSet();\n\n      for (var indexChildren = 0; indexChildren < this.children.length; indexChildren++) {\n        var child = this.children[indexChildren];\n        addAllToSet(this.fileDependencies, child.fileDependencies);\n        addAllToSet(this.contextDependencies, child.contextDependencies);\n        addAllToSet(this.missingDependencies, child.missingDependencies);\n      }\n\n      for (var indexModule = 0; indexModule < this.modules.length; indexModule++) {\n        var _module6 = this.modules[indexModule];\n\n        if (_module6.buildInfo.fileDependencies) {\n          addAllToSet(this.fileDependencies, _module6.buildInfo.fileDependencies);\n        }\n\n        if (_module6.buildInfo.contextDependencies) {\n          addAllToSet(this.contextDependencies, _module6.buildInfo.contextDependencies);\n        }\n      }\n\n      var _iteratorNormalCompletion29 = true;\n      var _didIteratorError29 = false;\n      var _iteratorError29 = undefined;\n\n      try {\n        for (var _iterator29 = this.errors[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {\n          var error = _step29.value;\n\n          if (typeof error.missing === \"object\" && error.missing && error.missing[Symbol.iterator]) {\n            addAllToSet(this.missingDependencies, error.missing);\n          }\n        }\n      } catch (err) {\n        _didIteratorError29 = true;\n        _iteratorError29 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion29 && _iterator29.return != null) {\n            _iterator29.return();\n          }\n        } finally {\n          if (_didIteratorError29) {\n            throw _iteratorError29;\n          }\n        }\n      }\n\n      this.fileDependencies.sort();\n      this.contextDependencies.sort();\n      this.missingDependencies.sort();\n    }\n  }, {\n    key: \"createHash\",\n    value: function createHash() {\n      var outputOptions = this.outputOptions;\n      var hashFunction = outputOptions.hashFunction;\n      var hashDigest = outputOptions.hashDigest;\n      var hashDigestLength = outputOptions.hashDigestLength;\n\n      var hash = _createHash(hashFunction);\n\n      if (outputOptions.hashSalt) {\n        hash.update(outputOptions.hashSalt);\n      }\n\n      this.mainTemplate.updateHash(hash);\n      this.chunkTemplate.updateHash(hash);\n      var _iteratorNormalCompletion30 = true;\n      var _didIteratorError30 = false;\n      var _iteratorError30 = undefined;\n\n      try {\n        for (var _iterator30 = Object.keys(this.moduleTemplates).sort()[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {\n          var key = _step30.value;\n          this.moduleTemplates[key].updateHash(hash);\n        }\n      } catch (err) {\n        _didIteratorError30 = true;\n        _iteratorError30 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion30 && _iterator30.return != null) {\n            _iterator30.return();\n          }\n        } finally {\n          if (_didIteratorError30) {\n            throw _iteratorError30;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion31 = true;\n      var _didIteratorError31 = false;\n      var _iteratorError31 = undefined;\n\n      try {\n        for (var _iterator31 = this.children[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {\n          var child = _step31.value;\n          hash.update(child.hash);\n        }\n      } catch (err) {\n        _didIteratorError31 = true;\n        _iteratorError31 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion31 && _iterator31.return != null) {\n            _iterator31.return();\n          }\n        } finally {\n          if (_didIteratorError31) {\n            throw _iteratorError31;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion32 = true;\n      var _didIteratorError32 = false;\n      var _iteratorError32 = undefined;\n\n      try {\n        for (var _iterator32 = this.warnings[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {\n          var warning = _step32.value;\n          hash.update(\"\".concat(warning.message));\n        }\n      } catch (err) {\n        _didIteratorError32 = true;\n        _iteratorError32 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion32 && _iterator32.return != null) {\n            _iterator32.return();\n          }\n        } finally {\n          if (_didIteratorError32) {\n            throw _iteratorError32;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion33 = true;\n      var _didIteratorError33 = false;\n      var _iteratorError33 = undefined;\n\n      try {\n        for (var _iterator33 = this.errors[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {\n          var error = _step33.value;\n          hash.update(\"\".concat(error.message));\n        }\n      } catch (err) {\n        _didIteratorError33 = true;\n        _iteratorError33 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion33 && _iterator33.return != null) {\n            _iterator33.return();\n          }\n        } finally {\n          if (_didIteratorError33) {\n            throw _iteratorError33;\n          }\n        }\n      }\n\n      var modules = this.modules;\n\n      for (var i = 0; i < modules.length; i++) {\n        var _module7 = modules[i];\n\n        var moduleHash = _createHash(hashFunction);\n\n        _module7.updateHash(moduleHash);\n\n        _module7.hash = moduleHash.digest(hashDigest);\n        _module7.renderedHash = _module7.hash.substr(0, hashDigestLength);\n      } // clone needed as sort below is inplace mutation\n\n\n      var chunks = this.chunks.slice();\n      /**\n       * sort here will bring all \"falsy\" values to the beginning\n       * this is needed as the \"hasRuntime()\" chunks are dependent on the\n       * hashes of the non-runtime chunks.\n       */\n\n      chunks.sort(function (a, b) {\n        var aEntry = a.hasRuntime();\n        var bEntry = b.hasRuntime();\n        if (aEntry && !bEntry) return 1;\n        if (!aEntry && bEntry) return -1;\n        return byId(a, b);\n      });\n\n      for (var _i2 = 0; _i2 < chunks.length; _i2++) {\n        var chunk = chunks[_i2];\n\n        var chunkHash = _createHash(hashFunction);\n\n        try {\n          if (outputOptions.hashSalt) {\n            chunkHash.update(outputOptions.hashSalt);\n          }\n\n          chunk.updateHash(chunkHash);\n          var template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n          template.updateHashForChunk(chunkHash, chunk, this.moduleTemplates.javascript, this.dependencyTemplates);\n          this.hooks.chunkHash.call(chunk, chunkHash);\n          chunk.hash = chunkHash.digest(hashDigest);\n          hash.update(chunk.hash);\n          chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);\n          this.hooks.contentHash.call(chunk);\n        } catch (err) {\n          this.errors.push(new ChunkRenderError(chunk, \"\", err));\n        }\n      }\n\n      this.fullHash = hash.digest(hashDigest);\n      this.hash = this.fullHash.substr(0, hashDigestLength);\n    }\n    /**\n     * @param {string} update extra information\n     * @returns {void}\n     */\n\n  }, {\n    key: \"modifyHash\",\n    value: function modifyHash(update) {\n      var outputOptions = this.outputOptions;\n      var hashFunction = outputOptions.hashFunction;\n      var hashDigest = outputOptions.hashDigest;\n      var hashDigestLength = outputOptions.hashDigestLength;\n\n      var hash = _createHash(hashFunction);\n\n      hash.update(this.fullHash);\n      hash.update(update);\n      this.fullHash = hash.digest(hashDigest);\n      this.hash = this.fullHash.substr(0, hashDigestLength);\n    }\n  }, {\n    key: \"createModuleAssets\",\n    value: function createModuleAssets() {\n      for (var i = 0; i < this.modules.length; i++) {\n        var _module8 = this.modules[i];\n\n        if (_module8.buildInfo.assets) {\n          var _arr = Object.keys(_module8.buildInfo.assets);\n\n          for (var _i3 = 0; _i3 < _arr.length; _i3++) {\n            var assetName = _arr[_i3];\n            var fileName = this.getPath(assetName);\n            this.assets[fileName] = _module8.buildInfo.assets[assetName];\n            this.hooks.moduleAsset.call(_module8, fileName);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"createChunkAssets\",\n    value: function createChunkAssets() {\n      var outputOptions = this.outputOptions;\n      var cachedSourceMap = new Map();\n      /** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */\n\n      var alreadyWrittenFiles = new Map();\n\n      for (var i = 0; i < this.chunks.length; i++) {\n        var chunk = this.chunks[i];\n        chunk.files = [];\n        var source = void 0;\n        var file = void 0;\n        var filenameTemplate = void 0;\n\n        try {\n          var template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n          var manifest = template.getRenderManifest({\n            chunk: chunk,\n            hash: this.hash,\n            fullHash: this.fullHash,\n            outputOptions: outputOptions,\n            moduleTemplates: this.moduleTemplates,\n            dependencyTemplates: this.dependencyTemplates\n          }); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]\n\n          var _iteratorNormalCompletion34 = true;\n          var _didIteratorError34 = false;\n          var _iteratorError34 = undefined;\n\n          try {\n            for (var _iterator34 = manifest[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {\n              var fileManifest = _step34.value;\n              var cacheName = fileManifest.identifier;\n              var usedHash = fileManifest.hash;\n              filenameTemplate = fileManifest.filenameTemplate;\n              file = this.getPath(filenameTemplate, fileManifest.pathOptions); // check if the same filename was already written by another chunk\n\n              var alreadyWritten = alreadyWrittenFiles.get(file);\n\n              if (alreadyWritten !== undefined) {\n                if (alreadyWritten.hash === usedHash) {\n                  if (this.cache) {\n                    this.cache[cacheName] = {\n                      hash: usedHash,\n                      source: alreadyWritten.source\n                    };\n                  }\n\n                  chunk.files.push(file);\n                  this.hooks.chunkAsset.call(chunk, file);\n                  continue;\n                } else {\n                  throw new Error(\"Conflict: Multiple chunks emit assets to the same filename \".concat(file) + \" (chunks \".concat(alreadyWritten.chunk.id, \" and \").concat(chunk.id, \")\"));\n                }\n              }\n\n              if (this.cache && this.cache[cacheName] && this.cache[cacheName].hash === usedHash) {\n                source = this.cache[cacheName].source;\n              } else {\n                source = fileManifest.render(); // Ensure that source is a cached source to avoid additional cost because of repeated access\n\n                if (!(source instanceof CachedSource)) {\n                  var cacheEntry = cachedSourceMap.get(source);\n\n                  if (cacheEntry) {\n                    source = cacheEntry;\n                  } else {\n                    var cachedSource = new CachedSource(source);\n                    cachedSourceMap.set(source, cachedSource);\n                    source = cachedSource;\n                  }\n                }\n\n                if (this.cache) {\n                  this.cache[cacheName] = {\n                    hash: usedHash,\n                    source: source\n                  };\n                }\n              }\n\n              if (this.assets[file] && this.assets[file] !== source) {\n                throw new Error(\"Conflict: Multiple assets emit to the same filename \".concat(file));\n              }\n\n              this.assets[file] = source;\n              chunk.files.push(file);\n              this.hooks.chunkAsset.call(chunk, file);\n              alreadyWrittenFiles.set(file, {\n                hash: usedHash,\n                source: source,\n                chunk: chunk\n              });\n            }\n          } catch (err) {\n            _didIteratorError34 = true;\n            _iteratorError34 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion34 && _iterator34.return != null) {\n                _iterator34.return();\n              }\n            } finally {\n              if (_didIteratorError34) {\n                throw _iteratorError34;\n              }\n            }\n          }\n        } catch (err) {\n          this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));\n        }\n      }\n    }\n    /**\n     * @param {string} filename used to get asset path with hash\n     * @param {TODO=} data // TODO: figure out this param type\n     * @returns {string} interpolated path\n     */\n\n  }, {\n    key: \"getPath\",\n    value: function getPath(filename, data) {\n      data = data || {};\n      data.hash = data.hash || this.hash;\n      return this.mainTemplate.getAssetPath(filename, data);\n    }\n    /**\n     * This function allows you to run another instance of webpack inside of webpack however as\n     * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins\n     * from parent (or top level compiler) and creates a child Compilation\n     *\n     * @param {string} name name of the child compiler\n     * @param {TODO} outputOptions // Need to convert config schema to types for this\n     * @param {Plugin[]} plugins webpack plugins that will be applied\n     * @returns {Compiler} creates a child Compiler instance\n     */\n\n  }, {\n    key: \"createChildCompiler\",\n    value: function createChildCompiler(name, outputOptions, plugins) {\n      var idx = this.childrenCounters[name] || 0;\n      this.childrenCounters[name] = idx + 1;\n      return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);\n    }\n  }, {\n    key: \"checkConstraints\",\n    value: function checkConstraints() {\n      /** @type {Set<number|string>} */\n      var usedIds = new Set();\n      var modules = this.modules;\n\n      for (var indexModule = 0; indexModule < modules.length; indexModule++) {\n        var moduleId = modules[indexModule].id;\n        if (moduleId === null) continue;\n\n        if (usedIds.has(moduleId)) {\n          throw new Error(\"checkConstraints: duplicate module id \".concat(moduleId));\n        }\n\n        usedIds.add(moduleId);\n      }\n\n      var chunks = this.chunks;\n\n      for (var indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n        var chunk = chunks[indexChunk];\n\n        if (chunks.indexOf(chunk) !== indexChunk) {\n          throw new Error(\"checkConstraints: duplicate chunk in compilation \".concat(chunk.debugId));\n        }\n      }\n\n      var _iteratorNormalCompletion35 = true;\n      var _didIteratorError35 = false;\n      var _iteratorError35 = undefined;\n\n      try {\n        for (var _iterator35 = this.chunkGroups[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {\n          var chunkGroup = _step35.value;\n          chunkGroup.checkConstraints();\n        }\n      } catch (err) {\n        _didIteratorError35 = true;\n        _iteratorError35 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion35 && _iterator35.return != null) {\n            _iterator35.return();\n          }\n        } finally {\n          if (_didIteratorError35) {\n            throw _iteratorError35;\n          }\n        }\n      }\n    }\n  }]);\n\n  return Compilation;\n}(Tapable); // TODO remove in webpack 5\n\n\nCompilation.prototype.applyPlugins = util.deprecate(\n/**\n * @deprecated\n * @param {string} name Name\n * @param {any[]} args Other arguments\n * @returns {void}\n * @this {Compilation}\n */\nfunction (name) {\n  var _this$hooks$name$repl;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  (_this$hooks$name$repl = this.hooks[name.replace(/[- ]([a-z])/g, function (match) {\n    return match[1].toUpperCase();\n  })]).call.apply(_this$hooks$name$repl, args);\n}, \"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead\"); // TODO remove in webpack 5\n\nObject.defineProperty(Compilation.prototype, \"moduleTemplate\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Compilation}\n   * @returns {TODO} module template\n   */\n  function () {\n    return this.moduleTemplates.javascript;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {ModuleTemplate} value Template value\n   * @this {Compilation}\n   * @returns {void}\n   */\n  function (value) {\n    this.moduleTemplates.javascript = value;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.\")\n});\nmodule.exports = Compilation;","map":null,"metadata":{},"sourceType":"script"}