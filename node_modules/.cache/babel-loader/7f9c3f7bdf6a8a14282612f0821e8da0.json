{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar path = require(\"path\");\n\nvar _require = require(\"webpack-sources\"),\n    ConcatSource = _require.ConcatSource,\n    RawSource = _require.RawSource;\n\nvar ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\n\nvar SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\n\nvar createHash = require(\"./util/createHash\");\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n\n\nvar basename = function basename(name) {\n  if (!name.includes(\"/\")) return name;\n  return name.substr(name.lastIndexOf(\"/\") + 1);\n};\n\nvar assetsCache = new WeakMap();\n\nvar getTaskForFile = function getTaskForFile(file, chunk, options, compilation) {\n  var asset = compilation.assets[file];\n  var cache = assetsCache.get(asset);\n\n  if (cache && cache.file === file) {\n    for (var cachedFile in cache.assets) {\n      compilation.assets[cachedFile] = cache.assets[cachedFile];\n      if (cachedFile !== file) chunk.files.push(cachedFile);\n    }\n\n    return;\n  }\n\n  var source, sourceMap;\n\n  if (asset.sourceAndMap) {\n    var sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = asset.map(options);\n    source = asset.source();\n  }\n\n  if (sourceMap) {\n    return {\n      chunk: chunk,\n      file: file,\n      asset: asset,\n      source: source,\n      sourceMap: sourceMap,\n      modules: undefined\n    };\n  }\n};\n\nvar SourceMapDevToolPlugin =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {SourceMapDevToolPluginOptions=} options options object\n   */\n  function SourceMapDevToolPlugin(options) {\n    _classCallCheck(this, SourceMapDevToolPlugin);\n\n    if (arguments.length > 1) {\n      throw new Error(\"SourceMapDevToolPlugin only takes one argument (pass an options object)\");\n    }\n\n    if (!options) options = {};\n    validateOptions(schema, options, \"SourceMap DevTool Plugin\");\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# sourceMappingURL=[url]\";\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    this.namespace = options.namespace || \"\";\n    this.options = options;\n  }\n\n  _createClass(SourceMapDevToolPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var sourceMapFilename = this.sourceMapFilename;\n      var sourceMappingURLComment = this.sourceMappingURLComment;\n      var moduleFilenameTemplate = this.moduleFilenameTemplate;\n      var namespace = this.namespace;\n      var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n      var requestShortener = compiler.requestShortener;\n      var options = this.options;\n      options.test = options.test || /\\.(m?js|css)($|\\?)/i;\n      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n      compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", function (compilation) {\n        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n        compilation.hooks.afterOptimizeChunkAssets.tap({\n          name: \"SourceMapDevToolPlugin\",\n          context: true\n        }, function (context, chunks) {\n          var moduleToSourceNameMapping = new Map();\n          var reportProgress = context && context.reportProgress ? context.reportProgress : function () {};\n          var files = [];\n          var _iteratorNormalCompletion = true;\n          var _didIteratorError = false;\n          var _iteratorError = undefined;\n\n          try {\n            for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n              var chunk = _step.value;\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n\n              try {\n                for (var _iterator2 = chunk.files[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  var file = _step2.value;\n\n                  if (matchObject(file)) {\n                    files.push({\n                      file: file,\n                      chunk: chunk\n                    });\n                  }\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion && _iterator.return != null) {\n                _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n\n          reportProgress(0.0);\n          var tasks = [];\n          files.forEach(function (_ref, idx) {\n            var file = _ref.file,\n                chunk = _ref.chunk;\n            reportProgress(0.5 * idx / files.length, file, \"generate SourceMap\");\n            var task = getTaskForFile(file, chunk, options, compilation);\n\n            if (task) {\n              var modules = task.sourceMap.sources.map(function (source) {\n                var module = compilation.findModule(source);\n                return module || source;\n              });\n\n              for (var _idx = 0; _idx < modules.length; _idx++) {\n                var _module = modules[_idx];\n\n                if (!moduleToSourceNameMapping.get(_module)) {\n                  moduleToSourceNameMapping.set(_module, ModuleFilenameHelpers.createFilename(_module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, requestShortener));\n                }\n              }\n\n              task.modules = modules;\n              tasks.push(task);\n            }\n          });\n          reportProgress(0.5, \"resolve sources\");\n          var usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          var conflictDetectionSet = new Set(); // all modules in defined order (longest identifier first)\n\n          var allModules = Array.from(moduleToSourceNameMapping.keys()).sort(function (a, b) {\n            var ai = typeof a === \"string\" ? a : a.identifier();\n            var bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          }); // find modules with conflicting source names\n\n          for (var idx = 0; idx < allModules.length; idx++) {\n            var _module2 = allModules[idx];\n            var sourceName = moduleToSourceNameMapping.get(_module2);\n            var hasName = conflictDetectionSet.has(sourceName);\n\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            } // try the fallback name first\n\n\n            sourceName = ModuleFilenameHelpers.createFilename(_module2, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, requestShortener);\n            hasName = usedNamesSet.has(sourceName);\n\n            if (!hasName) {\n              moduleToSourceNameMapping.set(_module2, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            } // elsewise just append stars until we have a valid name\n\n\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n\n            moduleToSourceNameMapping.set(_module2, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n\n          tasks.forEach(function (task, index) {\n            reportProgress(0.5 + 0.5 * index / tasks.length, task.file, \"attach SourceMap\");\n            var assets = Object.create(null);\n            var chunk = task.chunk;\n            var file = task.file;\n            var asset = task.asset;\n            var sourceMap = task.sourceMap;\n            var source = task.source;\n            var modules = task.modules;\n            var moduleFilenames = modules.map(function (m) {\n              return moduleToSourceNameMapping.get(m);\n            });\n            sourceMap.sources = moduleFilenames;\n\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            assetsCache.set(asset, {\n              file: file,\n              assets: assets\n            });\n            /** @type {string | false} */\n\n            var currentSourceMappingURLComment = sourceMappingURLComment;\n\n            if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n            }\n\n            var sourceMapString = JSON.stringify(sourceMap);\n\n            if (sourceMapFilename) {\n              var filename = file;\n              var query = \"\";\n\n              var _idx2 = filename.indexOf(\"?\");\n\n              if (_idx2 >= 0) {\n                query = filename.substr(_idx2);\n                filename = filename.substr(0, _idx2);\n              }\n\n              var sourceMapFile = compilation.getPath(sourceMapFilename, {\n                chunk: chunk,\n                filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,\n                query: query,\n                basename: basename(filename),\n                contentHash: createHash(\"md4\").update(sourceMapString).digest(\"hex\")\n              });\n              var sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\") : path.relative(path.dirname(file), sourceMapFile).replace(/\\\\/g, \"/\");\n\n              if (currentSourceMappingURLComment !== false) {\n                assets[file] = compilation.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[url\\]/g, sourceMapUrl));\n              }\n\n              assets[sourceMapFile] = compilation.assets[sourceMapFile] = new RawSource(sourceMapString);\n              chunk.files.push(sourceMapFile);\n            } else {\n              if (currentSourceMappingURLComment === false) {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n              }\n\n              assets[file] = compilation.assets[file] = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, function () {\n                return sourceMapString;\n              }).replace(/\\[url\\]/g, function () {\n                return \"data:application/json;charset=utf-8;base64,\".concat(Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\"));\n              }));\n            }\n          });\n          reportProgress(1.0);\n        });\n      });\n    }\n  }]);\n\n  return SourceMapDevToolPlugin;\n}();\n\nmodule.exports = SourceMapDevToolPlugin;","map":null,"metadata":{},"sourceType":"script"}