{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n/** @typedef {import(\"../Module\")} Module */\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DependencyReference =\n/*#__PURE__*/\nfunction () {\n  // TODO webpack 5: module must be dynamic, you must pass a function returning a module\n  // This is needed to remove the hack in ConcatenatedModule\n  // The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {string[] | boolean} importedNames imported named from the module\n   * @param {boolean=} weak if this is a weak reference\n   * @param {number} order the order information or NaN if don't care\n   */\n  function DependencyReference(module, importedNames) {\n    var weak = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;\n\n    _classCallCheck(this, DependencyReference);\n\n    // TODO webpack 5: make it a getter\n    this.module = module; // true: full object\n    // false: only sideeffects/no export\n    // array of strings: the exports with this names\n\n    this.importedNames = importedNames;\n    this.weak = !!weak;\n    this.order = order;\n  }\n  /**\n   * @param {DependencyReference[]} array an array (will be modified)\n   * @returns {DependencyReference[]} the array again\n   */\n\n\n  _createClass(DependencyReference, null, [{\n    key: \"sort\",\n    value: function sort(array) {\n      /** @type {WeakMap<DependencyReference, number>} */\n      var originalOrder = new WeakMap();\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var ref = _step.value;\n          originalOrder.set(ref, i++);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return array.sort(function (a, b) {\n        var aOrder = a.order;\n        var bOrder = b.order;\n\n        if (isNaN(aOrder)) {\n          if (!isNaN(bOrder)) {\n            return 1;\n          }\n        } else {\n          if (isNaN(bOrder)) {\n            return -1;\n          }\n\n          if (aOrder !== bOrder) {\n            return aOrder - bOrder;\n          }\n        }\n\n        var aOrg = originalOrder.get(a);\n        var bOrg = originalOrder.get(b);\n        return aOrg - bOrg;\n      });\n    }\n  }]);\n\n  return DependencyReference;\n}();\n\nmodule.exports = DependencyReference;","map":null,"metadata":{},"sourceType":"script"}