{"ast":null,"code":"module.exports = exports = build;\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs'),\n    rm = require('rimraf'),\n    path = require('path'),\n    glob = require('glob'),\n    log = require('npmlog'),\n    which = require('which'),\n    exec = require('child_process').exec,\n    processRelease = require('./process-release'),\n    win = process.platform === 'win32';\n\nexports.usage = 'Invokes `' + (win ? 'msbuild' : 'make') + '` and builds the module';\n\nfunction build(gyp, argv, callback) {\n  var platformMake = 'make';\n\n  if (process.platform === 'aix') {\n    platformMake = 'gmake';\n  } else if (process.platform.indexOf('bsd') !== -1) {\n    platformMake = 'gmake';\n  } else if (win && argv.length > 0) {\n    argv = argv.map(function (target) {\n      return '/t:' + target;\n    });\n  }\n\n  var release = processRelease(argv, gyp, process.version, process.release),\n      makeCommand = gyp.opts.make || process.env.MAKE || platformMake,\n      command = win ? 'msbuild' : makeCommand,\n      buildDir = path.resolve('build'),\n      configPath = path.resolve(buildDir, 'config.gypi'),\n      jobs = gyp.opts.jobs || process.env.JOBS,\n      buildType,\n      config,\n      arch,\n      nodeDir;\n  loadConfigGypi();\n  /**\n   * Load the \"config.gypi\" file that was generated during \"configure\".\n   */\n\n  function loadConfigGypi() {\n    fs.readFile(configPath, 'utf8', function (err, data) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          callback(new Error('You must run `node-gyp configure` first!'));\n        } else {\n          callback(err);\n        }\n\n        return;\n      }\n\n      config = JSON.parse(data.replace(/\\#.+\\n/, '')); // get the 'arch', 'buildType', and 'nodeDir' vars from the config\n\n      buildType = config.target_defaults.default_configuration;\n      arch = config.variables.target_arch;\n      nodeDir = config.variables.nodedir;\n\n      if ('debug' in gyp.opts) {\n        buildType = gyp.opts.debug ? 'Debug' : 'Release';\n      }\n\n      if (!buildType) {\n        buildType = 'Release';\n      }\n\n      log.verbose('build type', buildType);\n      log.verbose('architecture', arch);\n      log.verbose('node dev dir', nodeDir);\n\n      if (win) {\n        findSolutionFile();\n      } else {\n        doWhich();\n      }\n    });\n  }\n  /**\n   * On Windows, find the first build/*.sln file.\n   */\n\n\n  function findSolutionFile() {\n    glob('build/*.sln', function (err, files) {\n      if (err) return callback(err);\n\n      if (files.length === 0) {\n        return callback(new Error('Could not find *.sln file. Did you run \"configure\"?'));\n      }\n\n      guessedSolution = files[0];\n      log.verbose('found first Solution file', guessedSolution);\n      doWhich();\n    });\n  }\n  /**\n   * Uses node-which to locate the msbuild / make executable.\n   */\n\n\n  function doWhich() {\n    // First make sure we have the build command in the PATH\n    which(command, function (err, execPath) {\n      if (err) {\n        if (win && /not found/.test(err.message)) {\n          // On windows and no 'msbuild' found. Let's guess where it is\n          findMsbuild();\n        } else {\n          // Some other error or 'make' not found on Unix, report that to the user\n          callback(err);\n        }\n\n        return;\n      }\n\n      log.verbose('`which` succeeded for `' + command + '`', execPath);\n      doBuild();\n    });\n  }\n  /**\n   * Search for the location of \"msbuild.exe\" file on Windows.\n   */\n\n\n  function findMsbuild() {\n    if (config.variables.msbuild_path) {\n      command = config.variables.msbuild_path;\n      log.verbose('using MSBuild:', command);\n      doBuild();\n      return;\n    }\n\n    log.verbose('could not find \"msbuild.exe\" in PATH - finding location in registry');\n    var notfoundErr = 'Can\\'t find \"msbuild.exe\". Do you have Microsoft Visual Studio C++ 2008+ installed?';\n    var cmd = 'reg query \"HKLM\\\\Software\\\\Microsoft\\\\MSBuild\\\\ToolsVersions\" /s';\n    if (process.arch !== 'ia32') cmd += ' /reg:32';\n    exec(cmd, function (err, stdout, stderr) {\n      if (err) {\n        return callback(new Error(err.message + '\\n' + notfoundErr));\n      }\n\n      var reVers = /ToolsVersions\\\\([^\\\\]+)$/i,\n          rePath = /\\r\\n[ \\t]+MSBuildToolsPath[ \\t]+REG_SZ[ \\t]+([^\\r]+)/i,\n          msbuilds = [],\n          r,\n          msbuildPath;\n      stdout.split('\\r\\n\\r\\n').forEach(function (l) {\n        if (!l) return;\n        l = l.trim();\n\n        if (r = reVers.exec(l.substring(0, l.indexOf('\\r\\n')))) {\n          var ver = parseFloat(r[1], 10);\n\n          if (ver >= 3.5) {\n            if (r = rePath.exec(l)) {\n              msbuilds.push({\n                version: ver,\n                path: r[1]\n              });\n            }\n          }\n        }\n      });\n      msbuilds.sort(function (x, y) {\n        return x.version < y.version ? -1 : 1;\n      });\n\n      (function verifyMsbuild() {\n        if (!msbuilds.length) return callback(new Error(notfoundErr));\n        msbuildPath = path.resolve(msbuilds.pop().path, 'msbuild.exe');\n        fs.stat(msbuildPath, function (err, stat) {\n          if (err) {\n            if (err.code == 'ENOENT') {\n              if (msbuilds.length) {\n                return verifyMsbuild();\n              } else {\n                callback(new Error(notfoundErr));\n              }\n            } else {\n              callback(err);\n            }\n\n            return;\n          }\n\n          command = msbuildPath;\n          doBuild();\n        });\n      })();\n    });\n  }\n  /**\n   * Actually spawn the process and compile the module.\n   */\n\n\n  function doBuild() {\n    // Enable Verbose build\n    var verbose = log.levels[log.level] <= log.levels.verbose;\n\n    if (!win && verbose) {\n      argv.push('V=1');\n    }\n\n    if (win && !verbose) {\n      argv.push('/clp:Verbosity=minimal');\n    }\n\n    if (win) {\n      // Turn off the Microsoft logo on Windows\n      argv.push('/nologo');\n    } // Specify the build type, Release by default\n\n\n    if (win) {\n      var archLower = arch.toLowerCase();\n      var p = archLower === 'x64' ? 'x64' : archLower === 'arm' ? 'ARM' : 'Win32';\n      argv.push('/p:Configuration=' + buildType + ';Platform=' + p);\n\n      if (jobs) {\n        var j = parseInt(jobs, 10);\n\n        if (!isNaN(j) && j > 0) {\n          argv.push('/m:' + j);\n        } else if (jobs.toUpperCase() === 'MAX') {\n          argv.push('/m:' + require('os').cpus().length);\n        }\n      }\n    } else {\n      argv.push('BUILDTYPE=' + buildType); // Invoke the Makefile in the 'build' dir.\n\n      argv.push('-C');\n      argv.push('build');\n\n      if (jobs) {\n        var j = parseInt(jobs, 10);\n\n        if (!isNaN(j) && j > 0) {\n          argv.push('--jobs');\n          argv.push(j);\n        } else if (jobs.toUpperCase() === 'MAX') {\n          argv.push('--jobs');\n          argv.push(require('os').cpus().length);\n        }\n      }\n    }\n\n    if (win) {\n      // did the user specify their own .sln file?\n      var hasSln = argv.some(function (arg) {\n        return path.extname(arg) == '.sln';\n      });\n\n      if (!hasSln) {\n        argv.unshift(gyp.opts.solution || guessedSolution);\n      }\n    }\n\n    var proc = gyp.spawn(command, argv);\n    proc.on('exit', onExit);\n  }\n  /**\n   * Invoked after the make/msbuild command exits.\n   */\n\n\n  function onExit(code, signal) {\n    if (code !== 0) {\n      return callback(new Error('`' + command + '` failed with exit code: ' + code));\n    }\n\n    if (signal) {\n      return callback(new Error('`' + command + '` got signal: ' + signal));\n    }\n\n    callback();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}