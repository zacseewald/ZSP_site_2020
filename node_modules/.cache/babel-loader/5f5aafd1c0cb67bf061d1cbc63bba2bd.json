{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _toConsumableArray = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar Template = require(\"../Template\");\n\nvar WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../MainTemplate\")} MainTemplate */\n// Get all wasm modules\n\n\nvar getAllWasmModules = function getAllWasmModules(chunk) {\n  var wasmModules = chunk.getAllAsyncChunks();\n  var array = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = wasmModules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _chunk = _step.value;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = _chunk.modulesIterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var m = _step2.value;\n\n          if (m.type.startsWith(\"webassembly\")) {\n            array.push(m);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return array;\n};\n/**\n * generates the import object function for a module\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @returns {string} source code\n */\n\n\nvar generateImportObject = function generateImportObject(module, mangle) {\n  var waitForInstances = new Map();\n  var properties = [];\n  var usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(module, mangle);\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = usedWasmDependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var usedDep = _step3.value;\n      var dep = usedDep.dependency;\n      var importedModule = dep.module;\n      var exportName = dep.name;\n      var usedName = importedModule && importedModule.isUsed(exportName);\n      var description = dep.description;\n      var direct = dep.onlyDirectImport;\n      var _module = usedDep.module;\n      var name = usedDep.name;\n\n      if (direct) {\n        var instanceVar = \"m\".concat(waitForInstances.size);\n        waitForInstances.set(instanceVar, importedModule.id);\n        properties.push({\n          module: _module,\n          name: name,\n          value: \"\".concat(instanceVar, \"[\").concat(JSON.stringify(usedName), \"]\")\n        });\n      } else {\n        var params = description.signature.params.map(function (param, k) {\n          return \"p\" + k + param.valtype;\n        });\n        var mod = \"installedModules[\".concat(JSON.stringify(importedModule.id), \"]\");\n        var func = \"\".concat(mod, \".exports[\").concat(JSON.stringify(usedName), \"]\");\n        properties.push({\n          module: _module,\n          name: name,\n          value: Template.asString([(importedModule.type.startsWith(\"webassembly\") ? \"\".concat(mod, \" ? \").concat(func, \" : \") : \"\") + \"function(\".concat(params, \") {\"), Template.indent([\"return \".concat(func, \"(\").concat(params, \");\")]), \"}\"])\n        });\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var importObject;\n\n  if (mangle) {\n    importObject = [\"return {\", Template.indent([properties.map(function (p) {\n      return \"\".concat(JSON.stringify(p.name), \": \").concat(p.value);\n    }).join(\",\\n\")]), \"};\"];\n  } else {\n    var propertiesByModule = new Map();\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = properties[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var p = _step4.value;\n        var list = propertiesByModule.get(p.module);\n\n        if (list === undefined) {\n          propertiesByModule.set(p.module, list = []);\n        }\n\n        list.push(p);\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    importObject = [\"return {\", Template.indent([Array.from(propertiesByModule, function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          module = _ref2[0],\n          list = _ref2[1];\n\n      return Template.asString([\"\".concat(JSON.stringify(module), \": {\"), Template.indent([list.map(function (p) {\n        return \"\".concat(JSON.stringify(p.name), \": \").concat(p.value);\n      }).join(\",\\n\")]), \"}\"]);\n    }).join(\",\\n\")]), \"};\"];\n  }\n\n  if (waitForInstances.size === 1) {\n    var moduleId = Array.from(waitForInstances.values())[0];\n    var promise = \"installedWasmModules[\".concat(JSON.stringify(moduleId), \"]\");\n    var variable = Array.from(waitForInstances.keys())[0];\n    return Template.asString([\"\".concat(JSON.stringify(module.id), \": function() {\"), Template.indent([\"return promiseResolve().then(function() { return \".concat(promise, \"; }).then(function(\").concat(variable, \") {\"), Template.indent(importObject), \"});\"]), \"},\"]);\n  } else if (waitForInstances.size > 0) {\n    var promises = Array.from(waitForInstances.values(), function (id) {\n      return \"installedWasmModules[\".concat(JSON.stringify(id), \"]\");\n    }).join(\", \");\n    var variables = Array.from(waitForInstances.keys(), function (name, i) {\n      return \"\".concat(name, \" = array[\").concat(i, \"]\");\n    }).join(\", \");\n    return Template.asString([\"\".concat(JSON.stringify(module.id), \": function() {\"), Template.indent([\"return promiseResolve().then(function() { return Promise.all([\".concat(promises, \"]); }).then(function(array) {\"), Template.indent([\"var \".concat(variables, \";\")].concat(_toConsumableArray(importObject))), \"});\"]), \"},\"]);\n  } else {\n    return Template.asString([\"\".concat(JSON.stringify(module.id), \": function() {\"), Template.indent(importObject), \"},\"]);\n  }\n};\n\nvar WasmMainTemplatePlugin =\n/*#__PURE__*/\nfunction () {\n  function WasmMainTemplatePlugin(_ref3) {\n    var generateLoadBinaryCode = _ref3.generateLoadBinaryCode,\n        supportsStreaming = _ref3.supportsStreaming,\n        mangleImports = _ref3.mangleImports;\n\n    _classCallCheck(this, WasmMainTemplatePlugin);\n\n    this.generateLoadBinaryCode = generateLoadBinaryCode;\n    this.supportsStreaming = supportsStreaming;\n    this.mangleImports = mangleImports;\n  }\n  /**\n   * @param {MainTemplate} mainTemplate main template\n   * @returns {void}\n   */\n\n\n  _createClass(WasmMainTemplatePlugin, [{\n    key: \"apply\",\n    value: function apply(mainTemplate) {\n      var _this = this;\n\n      mainTemplate.hooks.localVars.tap(\"WasmMainTemplatePlugin\", function (source, chunk) {\n        var wasmModules = getAllWasmModules(chunk);\n        if (wasmModules.length === 0) return source;\n        var importObjects = wasmModules.map(function (module) {\n          return generateImportObject(module, _this.mangleImports);\n        });\n        return Template.asString([source, \"\", \"// object to store loaded and loading wasm modules\", \"var installedWasmModules = {};\", \"\", // This function is used to delay reading the installed wasm module promises\n        // by a microtask. Sorting them doesn't help because there are egdecases where\n        // sorting is not possible (modules splitted into different chunks).\n        // So we not even trying and solve this by a microtask delay.\n        \"function promiseResolve() { return Promise.resolve(); }\", \"\", \"var wasmImportObjects = {\", Template.indent(importObjects), \"};\"]);\n      });\n      mainTemplate.hooks.requireEnsure.tap(\"WasmMainTemplatePlugin\", function (source, chunk, hash) {\n        var webassemblyModuleFilename = mainTemplate.outputOptions.webassemblyModuleFilename;\n        var chunkModuleMaps = chunk.getChunkModuleMaps(function (m) {\n          return m.type.startsWith(\"webassembly\");\n        });\n        if (Object.keys(chunkModuleMaps.id).length === 0) return source;\n        var wasmModuleSrcPath = mainTemplate.getAssetPath(JSON.stringify(webassemblyModuleFilename), {\n          hash: \"\\\" + \".concat(mainTemplate.renderCurrentHashCode(hash), \" + \\\"\"),\n          hashWithLength: function hashWithLength(length) {\n            return \"\\\" + \".concat(mainTemplate.renderCurrentHashCode(hash, length), \" + \\\"\");\n          },\n          module: {\n            id: '\" + wasmModuleId + \"',\n            hash: \"\\\" + \".concat(JSON.stringify(chunkModuleMaps.hash), \"[wasmModuleId] + \\\"\"),\n            hashWithLength: function hashWithLength(length) {\n              var shortChunkHashMap = Object.create(null);\n\n              var _arr = Object.keys(chunkModuleMaps.hash);\n\n              for (var _i = 0; _i < _arr.length; _i++) {\n                var wasmModuleId = _arr[_i];\n\n                if (typeof chunkModuleMaps.hash[wasmModuleId] === \"string\") {\n                  shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[wasmModuleId].substr(0, length);\n                }\n              }\n\n              return \"\\\" + \".concat(JSON.stringify(shortChunkHashMap), \"[wasmModuleId] + \\\"\");\n            }\n          }\n        });\n\n        var createImportObject = function createImportObject(content) {\n          return _this.mangleImports ? \"{ \".concat(JSON.stringify(WebAssemblyUtils.MANGLED_MODULE), \": \").concat(content, \" }\") : content;\n        };\n\n        return Template.asString([source, \"\", \"// Fetch + compile chunk loading for webassembly\", \"\", \"var wasmModules = \".concat(JSON.stringify(chunkModuleMaps.id), \"[chunkId] || [];\"), \"\", \"wasmModules.forEach(function(wasmModuleId) {\", Template.indent([\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\", \"\", '// a Promise means \"currently loading\" or \"already loaded\".', \"if(installedWasmModuleData)\", Template.indent([\"promises.push(installedWasmModuleData);\"]), \"else {\", Template.indent([\"var importObject = wasmImportObjects[wasmModuleId]();\", \"var req = \".concat(_this.generateLoadBinaryCode(wasmModuleSrcPath), \";\"), \"var promise;\", _this.supportsStreaming ? Template.asString([\"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\", Template.indent([\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\", Template.indent([\"return WebAssembly.instantiate(items[0], \".concat(createImportObject(\"items[1]\"), \");\")]), \"});\"]), \"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\", Template.indent([\"promise = WebAssembly.instantiateStreaming(req, \".concat(createImportObject(\"importObject\"), \");\")])]) : Template.asString([\"if(importObject instanceof Promise) {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = Promise.all([\", Template.indent([\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\", \"importObject\"]), \"]).then(function(items) {\", Template.indent([\"return WebAssembly.instantiate(items[0], \".concat(createImportObject(\"items[1]\"), \");\")]), \"});\"])]), \"} else {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = bytesPromise.then(function(bytes) {\", Template.indent([\"return WebAssembly.instantiate(bytes, \".concat(createImportObject(\"importObject\"), \");\")]), \"});\"]), \"}\", \"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\", Template.indent([\"return \".concat(mainTemplate.requireFn, \".w[wasmModuleId] = (res.instance || res).exports;\")]), \"}));\"]), \"}\"]), \"});\"]);\n      });\n      mainTemplate.hooks.requireExtensions.tap(\"WasmMainTemplatePlugin\", function (source, chunk) {\n        if (!chunk.hasModuleInGraph(function (m) {\n          return m.type.startsWith(\"webassembly\");\n        })) {\n          return source;\n        }\n\n        return Template.asString([source, \"\", \"// object with all WebAssembly.instance exports\", \"\".concat(mainTemplate.requireFn, \".w = {};\")]);\n      });\n      mainTemplate.hooks.hash.tap(\"WasmMainTemplatePlugin\", function (hash) {\n        hash.update(\"WasmMainTemplatePlugin\");\n        hash.update(\"2\");\n      });\n    }\n  }]);\n\n  return WasmMainTemplatePlugin;\n}();\n\nmodule.exports = WasmMainTemplatePlugin;","map":null,"metadata":{},"sourceType":"script"}