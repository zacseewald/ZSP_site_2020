{"ast":null,"code":"/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Storage =\n/*#__PURE__*/\nfunction () {\n  function Storage(duration) {\n    _classCallCheck(this, Storage);\n\n    this.duration = duration;\n    this.running = new Map();\n    this.data = new Map();\n    this.levels = [];\n\n    if (duration > 0) {\n      this.levels.push(new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set(), new Set());\n\n      for (var i = 8000; i < duration; i += 500) {\n        this.levels.push(new Set());\n      }\n    }\n\n    this.count = 0;\n    this.interval = null;\n    this.needTickCheck = false;\n    this.nextTick = null;\n    this.passive = true;\n    this.tick = this.tick.bind(this);\n  }\n\n  _createClass(Storage, [{\n    key: \"ensureTick\",\n    value: function ensureTick() {\n      if (!this.interval && this.duration > 0 && !this.nextTick) this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length));\n    }\n  }, {\n    key: \"finished\",\n    value: function finished(name, err, result) {\n      var callbacks = this.running.get(name);\n      this.running.delete(name);\n\n      if (this.duration > 0) {\n        this.data.set(name, [err, result]);\n        var levelData = this.levels[0];\n        this.count -= levelData.size;\n        levelData.add(name);\n        this.count += levelData.size;\n        this.ensureTick();\n      }\n\n      for (var i = 0; i < callbacks.length; i++) {\n        callbacks[i](err, result);\n      }\n    }\n  }, {\n    key: \"finishedSync\",\n    value: function finishedSync(name, err, result) {\n      if (this.duration > 0) {\n        this.data.set(name, [err, result]);\n        var levelData = this.levels[0];\n        this.count -= levelData.size;\n        levelData.add(name);\n        this.count += levelData.size;\n        this.ensureTick();\n      }\n    }\n  }, {\n    key: \"provide\",\n    value: function provide(name, provider, callback) {\n      var _this = this;\n\n      if (typeof name !== \"string\") {\n        callback(new TypeError(\"path must be a string\"));\n        return;\n      }\n\n      var running = this.running.get(name);\n\n      if (running) {\n        running.push(callback);\n        return;\n      }\n\n      if (this.duration > 0) {\n        this.checkTicks();\n        var data = this.data.get(name);\n\n        if (data) {\n          return process.nextTick(function () {\n            callback.apply(null, data);\n          });\n        }\n      }\n\n      this.running.set(name, running = [callback]);\n      provider(name, function (err, result) {\n        _this.finished(name, err, result);\n      });\n    }\n  }, {\n    key: \"provideSync\",\n    value: function provideSync(name, provider) {\n      if (typeof name !== \"string\") {\n        throw new TypeError(\"path must be a string\");\n      }\n\n      if (this.duration > 0) {\n        this.checkTicks();\n        var data = this.data.get(name);\n\n        if (data) {\n          if (data[0]) throw data[0];\n          return data[1];\n        }\n      }\n\n      var result;\n\n      try {\n        result = provider(name);\n      } catch (e) {\n        this.finishedSync(name, e);\n        throw e;\n      }\n\n      this.finishedSync(name, null, result);\n      return result;\n    }\n  }, {\n    key: \"tick\",\n    value: function tick() {\n      var decay = this.levels.pop();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = decay[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var item = _step.value;\n          this.data.delete(item);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.count -= decay.size;\n      decay.clear();\n      this.levels.unshift(decay);\n\n      if (this.count === 0) {\n        clearInterval(this.interval);\n        this.interval = null;\n        this.nextTick = null;\n        return true;\n      } else if (this.nextTick) {\n        this.nextTick += Math.floor(this.duration / this.levels.length);\n        var time = new Date().getTime();\n\n        if (this.nextTick > time) {\n          this.nextTick = null;\n          this.interval = setInterval(this.tick, Math.floor(this.duration / this.levels.length));\n          return true;\n        }\n      } else if (this.passive) {\n        clearInterval(this.interval);\n        this.interval = null;\n        this.nextTick = new Date().getTime() + Math.floor(this.duration / this.levels.length);\n      } else {\n        this.passive = true;\n      }\n    }\n  }, {\n    key: \"checkTicks\",\n    value: function checkTicks() {\n      this.passive = false;\n\n      if (this.nextTick) {\n        while (!this.tick()) {\n          ;\n        }\n      }\n    }\n  }, {\n    key: \"purge\",\n    value: function purge(what) {\n      if (!what) {\n        this.count = 0;\n        clearInterval(this.interval);\n        this.nextTick = null;\n        this.data.clear();\n        this.levels.forEach(function (level) {\n          level.clear();\n        });\n      } else if (typeof what === \"string\") {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.data.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var key = _step2.value;\n            if (key.startsWith(what)) this.data.delete(key);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      } else {\n        for (var i = what.length - 1; i >= 0; i--) {\n          this.purge(what[i]);\n        }\n      }\n    }\n  }]);\n\n  return Storage;\n}();\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function CachedInputFileSystem(fileSystem, duration) {\n    var _this2 = this;\n\n    _classCallCheck(this, CachedInputFileSystem);\n\n    this.fileSystem = fileSystem;\n    this._statStorage = new Storage(duration);\n    this._readdirStorage = new Storage(duration);\n    this._readFileStorage = new Storage(duration);\n    this._readJsonStorage = new Storage(duration);\n    this._readlinkStorage = new Storage(duration);\n    this._stat = this.fileSystem.stat ? this.fileSystem.stat.bind(this.fileSystem) : null;\n    if (!this._stat) this.stat = null;\n    this._statSync = this.fileSystem.statSync ? this.fileSystem.statSync.bind(this.fileSystem) : null;\n    if (!this._statSync) this.statSync = null;\n    this._readdir = this.fileSystem.readdir ? this.fileSystem.readdir.bind(this.fileSystem) : null;\n    if (!this._readdir) this.readdir = null;\n    this._readdirSync = this.fileSystem.readdirSync ? this.fileSystem.readdirSync.bind(this.fileSystem) : null;\n    if (!this._readdirSync) this.readdirSync = null;\n    this._readFile = this.fileSystem.readFile ? this.fileSystem.readFile.bind(this.fileSystem) : null;\n    if (!this._readFile) this.readFile = null;\n    this._readFileSync = this.fileSystem.readFileSync ? this.fileSystem.readFileSync.bind(this.fileSystem) : null;\n    if (!this._readFileSync) this.readFileSync = null;\n\n    if (this.fileSystem.readJson) {\n      this._readJson = this.fileSystem.readJson.bind(this.fileSystem);\n    } else if (this.readFile) {\n      this._readJson = function (path, callback) {\n        _this2.readFile(path, function (err, buffer) {\n          if (err) return callback(err);\n          var data;\n\n          try {\n            data = JSON.parse(buffer.toString(\"utf-8\"));\n          } catch (e) {\n            return callback(e);\n          }\n\n          callback(null, data);\n        });\n      };\n    } else {\n      this.readJson = null;\n    }\n\n    if (this.fileSystem.readJsonSync) {\n      this._readJsonSync = this.fileSystem.readJsonSync.bind(this.fileSystem);\n    } else if (this.readFileSync) {\n      this._readJsonSync = function (path) {\n        var buffer = _this2.readFileSync(path);\n\n        var data = JSON.parse(buffer.toString(\"utf-8\"));\n        return data;\n      };\n    } else {\n      this.readJsonSync = null;\n    }\n\n    this._readlink = this.fileSystem.readlink ? this.fileSystem.readlink.bind(this.fileSystem) : null;\n    if (!this._readlink) this.readlink = null;\n    this._readlinkSync = this.fileSystem.readlinkSync ? this.fileSystem.readlinkSync.bind(this.fileSystem) : null;\n    if (!this._readlinkSync) this.readlinkSync = null;\n  }\n\n  _createClass(CachedInputFileSystem, [{\n    key: \"stat\",\n    value: function stat(path, callback) {\n      this._statStorage.provide(path, this._stat, callback);\n    }\n  }, {\n    key: \"readdir\",\n    value: function readdir(path, callback) {\n      this._readdirStorage.provide(path, this._readdir, callback);\n    }\n  }, {\n    key: \"readFile\",\n    value: function readFile(path, callback) {\n      this._readFileStorage.provide(path, this._readFile, callback);\n    }\n  }, {\n    key: \"readJson\",\n    value: function readJson(path, callback) {\n      this._readJsonStorage.provide(path, this._readJson, callback);\n    }\n  }, {\n    key: \"readlink\",\n    value: function readlink(path, callback) {\n      this._readlinkStorage.provide(path, this._readlink, callback);\n    }\n  }, {\n    key: \"statSync\",\n    value: function statSync(path) {\n      return this._statStorage.provideSync(path, this._statSync);\n    }\n  }, {\n    key: \"readdirSync\",\n    value: function readdirSync(path) {\n      return this._readdirStorage.provideSync(path, this._readdirSync);\n    }\n  }, {\n    key: \"readFileSync\",\n    value: function readFileSync(path) {\n      return this._readFileStorage.provideSync(path, this._readFileSync);\n    }\n  }, {\n    key: \"readJsonSync\",\n    value: function readJsonSync(path) {\n      return this._readJsonStorage.provideSync(path, this._readJsonSync);\n    }\n  }, {\n    key: \"readlinkSync\",\n    value: function readlinkSync(path) {\n      return this._readlinkStorage.provideSync(path, this._readlinkSync);\n    }\n  }, {\n    key: \"purge\",\n    value: function purge(what) {\n      this._statStorage.purge(what);\n\n      this._readdirStorage.purge(what);\n\n      this._readFileStorage.purge(what);\n\n      this._readlinkStorage.purge(what);\n\n      this._readJsonStorage.purge(what);\n    }\n  }]);\n\n  return CachedInputFileSystem;\n}();","map":null,"metadata":{},"sourceType":"script"}