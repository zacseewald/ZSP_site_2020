{"ast":null,"code":"// give it a tarball and a path, and it'll dump the contents\nmodule.exports = Extract;\n\nvar tar = require(\"../tar.js\"),\n    fstream = require(\"fstream\"),\n    inherits = require(\"inherits\"),\n    path = require(\"path\");\n\nfunction Extract(opts) {\n  if (!(this instanceof Extract)) return new Extract(opts);\n  tar.Parse.apply(this);\n\n  if (typeof opts !== \"object\") {\n    opts = {\n      path: opts\n    };\n  } // better to drop in cwd? seems more standard.\n\n\n  opts.path = opts.path || path.resolve(\"node-tar-extract\");\n  opts.type = \"Directory\";\n  opts.Directory = true; // similar to --strip or --strip-components\n\n  opts.strip = +opts.strip;\n  if (!opts.strip || opts.strip <= 0) opts.strip = 0;\n  this._fst = fstream.Writer(opts);\n  this.pause();\n  var me = this; // Hardlinks in tarballs are relative to the root\n  // of the tarball.  So, they need to be resolved against\n  // the target directory in order to be created properly.\n\n  me.on(\"entry\", function (entry) {\n    // if there's a \"strip\" argument, then strip off that many\n    // path components.\n    if (opts.strip) {\n      var p = entry.path.split(\"/\").slice(opts.strip).join(\"/\");\n      entry.path = entry.props.path = p;\n\n      if (entry.linkpath) {\n        var lp = entry.linkpath.split(\"/\").slice(opts.strip).join(\"/\");\n        entry.linkpath = entry.props.linkpath = lp;\n      }\n    }\n\n    if (entry.type === \"Link\") {\n      entry.linkpath = entry.props.linkpath = path.join(opts.path, path.join(\"/\", entry.props.linkpath));\n    }\n\n    if (entry.type === \"SymbolicLink\") {\n      var dn = path.dirname(entry.path) || \"\";\n      var linkpath = entry.props.linkpath;\n      var target = path.resolve(opts.path, dn, linkpath);\n\n      if (target.indexOf(opts.path) !== 0) {\n        linkpath = path.join(opts.path, path.join(\"/\", linkpath));\n      }\n\n      entry.linkpath = entry.props.linkpath = linkpath;\n    }\n  });\n\n  this._fst.on(\"ready\", function () {\n    me.pipe(me._fst, {\n      end: false\n    });\n    me.resume();\n  });\n\n  this._fst.on('error', function (err) {\n    me.emit('error', err);\n  });\n\n  this._fst.on('drain', function () {\n    me.emit('drain');\n  }); // this._fst.on(\"end\", function () {\n  //   console.error(\"\\nEEEE Extract End\", me._fst.path)\n  // })\n\n\n  this._fst.on(\"close\", function () {\n    // console.error(\"\\nEEEE Extract End\", me._fst.path)\n    me.emit(\"finish\");\n    me.emit(\"end\");\n    me.emit(\"close\");\n  });\n}\n\ninherits(Extract, tar.Parse);\n\nExtract.prototype._streamEnd = function () {\n  var me = this;\n  if (!me._ended || me._entry) me.error(\"unexpected eof\");\n\n  me._fst.end(); // my .end() is coming later.\n\n};","map":null,"metadata":{},"sourceType":"script"}