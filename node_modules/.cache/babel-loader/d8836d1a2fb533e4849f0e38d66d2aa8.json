{"ast":null,"code":"// A thing that emits \"entry\" events with Reader objects\n// Pausing it causes it to stop emitting entry events, and also\n// pauses the current entry if there is one.\nmodule.exports = DirReader;\n\nvar fs = require('graceful-fs');\n\nvar inherits = require('inherits');\n\nvar path = require('path');\n\nvar Reader = require('./reader.js');\n\nvar assert = require('assert').ok;\n\ninherits(DirReader, Reader);\n\nfunction DirReader(props) {\n  var self = this;\n\n  if (!(self instanceof DirReader)) {\n    throw new Error('DirReader must be called as constructor.');\n  } // should already be established as a Directory type\n\n\n  if (props.type !== 'Directory' || !props.Directory) {\n    throw new Error('Non-directory type ' + props.type);\n  }\n\n  self.entries = null;\n  self._index = -1;\n  self._paused = false;\n  self._length = -1;\n\n  if (props.sort) {\n    this.sort = props.sort;\n  }\n\n  Reader.call(this, props);\n}\n\nDirReader.prototype._getEntries = function () {\n  var self = this; // race condition.  might pause() before calling _getEntries,\n  // and then resume, and try to get them a second time.\n\n  if (self._gotEntries) return;\n  self._gotEntries = true;\n  fs.readdir(self._path, function (er, entries) {\n    if (er) return self.error(er);\n    self.entries = entries;\n    self.emit('entries', entries);\n    if (self._paused) self.once('resume', processEntries);else processEntries();\n\n    function processEntries() {\n      self._length = self.entries.length;\n\n      if (typeof self.sort === 'function') {\n        self.entries = self.entries.sort(self.sort.bind(self));\n      }\n\n      self._read();\n    }\n  });\n}; // start walking the dir, and emit an \"entry\" event for each one.\n\n\nDirReader.prototype._read = function () {\n  var self = this;\n  if (!self.entries) return self._getEntries();\n\n  if (self._paused || self._currentEntry || self._aborted) {\n    // console.error('DR paused=%j, current=%j, aborted=%j', self._paused, !!self._currentEntry, self._aborted)\n    return;\n  }\n\n  self._index++;\n\n  if (self._index >= self.entries.length) {\n    if (!self._ended) {\n      self._ended = true;\n      self.emit('end');\n      self.emit('close');\n    }\n\n    return;\n  } // ok, handle this one, then.\n  // save creating a proxy, by stat'ing the thing now.\n\n\n  var p = path.resolve(self._path, self.entries[self._index]);\n  assert(p !== self._path);\n  assert(self.entries[self._index]); // set this to prevent trying to _read() again in the stat time.\n\n  self._currentEntry = p;\n  fs[self.props.follow ? 'stat' : 'lstat'](p, function (er, stat) {\n    if (er) return self.error(er);\n    var who = self._proxy || self;\n    stat.path = p;\n    stat.basename = path.basename(p);\n    stat.dirname = path.dirname(p);\n    var childProps = self.getChildProps.call(who, stat);\n    childProps.path = p;\n    childProps.basename = path.basename(p);\n    childProps.dirname = path.dirname(p);\n    var entry = Reader(childProps, stat); // console.error(\"DR Entry\", p, stat.size)\n\n    self._currentEntry = entry; // \"entry\" events are for direct entries in a specific dir.\n    // \"child\" events are for any and all children at all levels.\n    // This nomenclature is not completely final.\n\n    entry.on('pause', function (who) {\n      if (!self._paused && !entry._disowned) {\n        self.pause(who);\n      }\n    });\n    entry.on('resume', function (who) {\n      if (self._paused && !entry._disowned) {\n        self.resume(who);\n      }\n    });\n    entry.on('stat', function (props) {\n      self.emit('_entryStat', entry, props);\n      if (entry._aborted) return;\n\n      if (entry._paused) {\n        entry.once('resume', function () {\n          self.emit('entryStat', entry, props);\n        });\n      } else self.emit('entryStat', entry, props);\n    });\n    entry.on('ready', function EMITCHILD() {\n      // console.error(\"DR emit child\", entry._path)\n      if (self._paused) {\n        // console.error(\"  DR emit child - try again later\")\n        // pause the child, and emit the \"entry\" event once we drain.\n        // console.error(\"DR pausing child entry\")\n        entry.pause(self);\n        return self.once('resume', EMITCHILD);\n      } // skip over sockets.  they can't be piped around properly,\n      // so there's really no sense even acknowledging them.\n      // if someone really wants to see them, they can listen to\n      // the \"socket\" events.\n\n\n      if (entry.type === 'Socket') {\n        self.emit('socket', entry);\n      } else {\n        self.emitEntry(entry);\n      }\n    });\n    var ended = false;\n    entry.on('close', onend);\n    entry.on('disown', onend);\n\n    function onend() {\n      if (ended) return;\n      ended = true;\n      self.emit('childEnd', entry);\n      self.emit('entryEnd', entry);\n      self._currentEntry = null;\n\n      if (!self._paused) {\n        self._read();\n      }\n    } // XXX Remove this.  Works in node as of 0.6.2 or so.\n    // Long filenames should not break stuff.\n\n\n    entry.on('error', function (er) {\n      if (entry._swallowErrors) {\n        self.warn(er);\n        entry.emit('end');\n        entry.emit('close');\n      } else {\n        self.emit('error', er);\n      }\n    }) // proxy up some events.\n    ;\n    ['child', 'childEnd', 'warn'].forEach(function (ev) {\n      entry.on(ev, self.emit.bind(self, ev));\n    });\n  });\n};\n\nDirReader.prototype.disown = function (entry) {\n  entry.emit('beforeDisown');\n  entry._disowned = true;\n  entry.parent = entry.root = null;\n\n  if (entry === this._currentEntry) {\n    this._currentEntry = null;\n  }\n\n  entry.emit('disown');\n};\n\nDirReader.prototype.getChildProps = function () {\n  return {\n    depth: this.depth + 1,\n    root: this.root || this,\n    parent: this,\n    follow: this.follow,\n    filter: this.filter,\n    sort: this.props.sort,\n    hardlinks: this.props.hardlinks\n  };\n};\n\nDirReader.prototype.pause = function (who) {\n  var self = this;\n  if (self._paused) return;\n  who = who || self;\n  self._paused = true;\n\n  if (self._currentEntry && self._currentEntry.pause) {\n    self._currentEntry.pause(who);\n  }\n\n  self.emit('pause', who);\n};\n\nDirReader.prototype.resume = function (who) {\n  var self = this;\n  if (!self._paused) return;\n  who = who || self;\n  self._paused = false; // console.error('DR Emit Resume', self._path)\n\n  self.emit('resume', who);\n\n  if (self._paused) {\n    // console.error('DR Re-paused', self._path)\n    return;\n  }\n\n  if (self._currentEntry) {\n    if (self._currentEntry.resume) self._currentEntry.resume(who);\n  } else self._read();\n};\n\nDirReader.prototype.emitEntry = function (entry) {\n  this.emit('entry', entry);\n  this.emit('child', entry);\n};","map":null,"metadata":{},"sourceType":"script"}