{"ast":null,"code":"module.exports = exports = configure;\nmodule.exports.test = {\n  PythonFinder: PythonFinder,\n  findAccessibleSync: findAccessibleSync,\n  findPython: findPython\n  /**\n   * Module dependencies.\n   */\n\n};\n\nvar fs = require('graceful-fs'),\n    path = require('path'),\n    log = require('npmlog'),\n    osenv = require('osenv'),\n    which = require('which'),\n    semver = require('semver'),\n    mkdirp = require('mkdirp'),\n    cp = require('child_process'),\n    extend = require('util')._extend,\n    processRelease = require('./process-release'),\n    win = process.platform === 'win32',\n    findNodeDirectory = require('./find-node-directory'),\n    msgFormat = require('util').format;\n\nif (win) var findVS2017 = require('./find-vs2017');\nexports.usage = 'Generates ' + (win ? 'MSVC project files' : 'a Makefile') + ' for the current module';\n\nfunction configure(gyp, argv, callback) {\n  var python = gyp.opts.python || process.env.PYTHON || 'python2',\n      buildDir = path.resolve('build'),\n      configNames = ['config.gypi', 'common.gypi'],\n      configs = [],\n      nodeDir,\n      release = processRelease(argv, gyp, process.version, process.release);\n  findPython(python, function (err, found) {\n    if (err) {\n      callback(err);\n    } else {\n      python = found;\n      getNodeDir();\n    }\n  });\n\n  function getNodeDir() {\n    // 'python' should be set by now\n    process.env.PYTHON = python;\n\n    if (gyp.opts.nodedir) {\n      // --nodedir was specified. use that for the dev files\n      nodeDir = gyp.opts.nodedir.replace(/^~/, osenv.home());\n      log.verbose('get node dir', 'compiling against specified --nodedir dev files: %s', nodeDir);\n      createBuildDir();\n    } else {\n      // if no --nodedir specified, ensure node dependencies are installed\n      if ('v' + release.version !== process.version) {\n        // if --target was given, then determine a target version to compile for\n        log.verbose('get node dir', 'compiling against --target node version: %s', release.version);\n      } else {\n        // if no --target was specified then use the current host node version\n        log.verbose('get node dir', 'no --target version specified, falling back to host node version: %s', release.version);\n      }\n\n      if (!release.semver) {\n        // could not parse the version string with semver\n        return callback(new Error('Invalid version number: ' + release.version));\n      } // If the tarball option is set, always remove and reinstall the headers\n      // into devdir. Otherwise only install if they're not already there.\n\n\n      gyp.opts.ensure = gyp.opts.tarball ? false : true;\n      gyp.commands.install([release.version], function (err, version) {\n        if (err) return callback(err);\n        log.verbose('get node dir', 'target node version installed:', release.versionDir);\n        nodeDir = path.resolve(gyp.devDir, release.versionDir);\n        createBuildDir();\n      });\n    }\n  }\n\n  function createBuildDir() {\n    log.verbose('build dir', 'attempting to create \"build\" dir: %s', buildDir);\n    mkdirp(buildDir, function (err, isNew) {\n      if (err) return callback(err);\n      log.verbose('build dir', '\"build\" dir needed to be created?', isNew);\n\n      if (win && (!gyp.opts.msvs_version || gyp.opts.msvs_version === '2017')) {\n        findVS2017(function (err, vsSetup) {\n          if (err) {\n            log.verbose('Not using VS2017:', err.message);\n            createConfigFile();\n          } else {\n            createConfigFile(null, vsSetup);\n          }\n        });\n      } else {\n        createConfigFile();\n      }\n    });\n  }\n\n  function createConfigFile(err, vsSetup) {\n    if (err) return callback(err);\n    var configFilename = 'config.gypi';\n    var configPath = path.resolve(buildDir, configFilename);\n    log.verbose('build/' + configFilename, 'creating config file');\n    var config = process.config || {},\n        defaults = config.target_defaults,\n        variables = config.variables; // default \"config.variables\"\n\n    if (!variables) variables = config.variables = {}; // default \"config.defaults\"\n\n    if (!defaults) defaults = config.target_defaults = {}; // don't inherit the \"defaults\" from node's `process.config` object.\n    // doing so could cause problems in cases where the `node` executable was\n    // compiled on a different machine (with different lib/include paths) than\n    // the machine where the addon is being built to\n\n    defaults.cflags = [];\n    defaults.defines = [];\n    defaults.include_dirs = [];\n    defaults.libraries = []; // set the default_configuration prop\n\n    if ('debug' in gyp.opts) {\n      defaults.default_configuration = gyp.opts.debug ? 'Debug' : 'Release';\n    }\n\n    if (!defaults.default_configuration) {\n      defaults.default_configuration = 'Release';\n    } // set the target_arch variable\n\n\n    variables.target_arch = gyp.opts.arch || process.arch || 'ia32'; // set the node development directory\n\n    variables.nodedir = nodeDir; // disable -T \"thin\" static archives by default\n\n    variables.standalone_static_library = gyp.opts.thin ? 0 : 1;\n\n    if (vsSetup) {\n      // GYP doesn't (yet) have support for VS2017, so we force it to VS2015\n      // to avoid pulling a floating patch that has not landed upstream.\n      // Ref: https://chromium-review.googlesource.com/#/c/433540/\n      gyp.opts.msvs_version = '2015';\n      process.env['GYP_MSVS_VERSION'] = 2015;\n      process.env['GYP_MSVS_OVERRIDE_PATH'] = vsSetup.path;\n      defaults['msbuild_toolset'] = 'v141';\n      defaults['msvs_windows_target_platform_version'] = vsSetup.sdk;\n      variables['msbuild_path'] = path.join(vsSetup.path, 'MSBuild', '15.0', 'Bin', 'MSBuild.exe');\n    } // loop through the rest of the opts and add the unknown ones as variables.\n    // this allows for module-specific configure flags like:\n    //\n    //   $ node-gyp configure --shared-libxml2\n\n\n    Object.keys(gyp.opts).forEach(function (opt) {\n      if (opt === 'argv') return;\n      if (opt in gyp.configDefs) return;\n      variables[opt.replace(/-/g, '_')] = gyp.opts[opt];\n    }); // ensures that any boolean values from `process.config` get stringified\n\n    function boolsToString(k, v) {\n      if (typeof v === 'boolean') return String(v);\n      return v;\n    }\n\n    log.silly('build/' + configFilename, config); // now write out the config.gypi file to the build/ dir\n\n    var prefix = '# Do not edit. File was generated by node-gyp\\'s \"configure\" step',\n        json = JSON.stringify(config, boolsToString, 2);\n    log.verbose('build/' + configFilename, 'writing out config file: %s', configPath);\n    configs.push(configPath);\n    fs.writeFile(configPath, [prefix, json, ''].join('\\n'), findConfigs);\n  }\n\n  function findConfigs(err) {\n    if (err) return callback(err);\n    var name = configNames.shift();\n    if (!name) return runGyp();\n    var fullPath = path.resolve(name);\n    log.verbose(name, 'checking for gypi file: %s', fullPath);\n    fs.stat(fullPath, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          findConfigs(); // check next gypi filename\n        } else {\n          callback(err);\n        }\n      } else {\n        log.verbose(name, 'found gypi file');\n        configs.push(fullPath);\n        findConfigs();\n      }\n    });\n  }\n\n  function runGyp(err) {\n    if (err) return callback(err);\n\n    if (!~argv.indexOf('-f') && !~argv.indexOf('--format')) {\n      if (win) {\n        log.verbose('gyp', 'gyp format was not specified; forcing \"msvs\"'); // force the 'make' target for non-Windows\n\n        argv.push('-f', 'msvs');\n      } else {\n        log.verbose('gyp', 'gyp format was not specified; forcing \"make\"'); // force the 'make' target for non-Windows\n\n        argv.push('-f', 'make');\n      }\n    }\n\n    function hasMsvsVersion() {\n      return argv.some(function (arg) {\n        return arg.indexOf('msvs_version') === 0;\n      });\n    }\n\n    if (win && !hasMsvsVersion()) {\n      if ('msvs_version' in gyp.opts) {\n        argv.push('-G', 'msvs_version=' + gyp.opts.msvs_version);\n      } else {\n        argv.push('-G', 'msvs_version=auto');\n      }\n    } // include all the \".gypi\" files that were found\n\n\n    configs.forEach(function (config) {\n      argv.push('-I', config);\n    }); // For AIX and z/OS we need to set up the path to the exports file\n    // which contains the symbols needed for linking. \n\n    var node_exp_file = undefined;\n\n    if (process.platform === 'aix' || process.platform === 'os390') {\n      var ext = process.platform === 'aix' ? 'exp' : 'x';\n      var node_root_dir = findNodeDirectory();\n      var candidates = undefined;\n\n      if (process.platform === 'aix') {\n        candidates = ['include/node/node', 'out/Release/node', 'out/Debug/node', 'node'].map(function (file) {\n          return file + '.' + ext;\n        });\n      } else {\n        candidates = ['out/Release/obj.target/libnode', 'out/Debug/obj.target/libnode', 'lib/libnode'].map(function (file) {\n          return file + '.' + ext;\n        });\n      }\n\n      var logprefix = 'find exports file';\n      node_exp_file = findAccessibleSync(logprefix, node_root_dir, candidates);\n\n      if (node_exp_file !== undefined) {\n        log.verbose(logprefix, 'Found exports file: %s', node_exp_file);\n      } else {\n        var msg = msgFormat('Could not find node.%s file in %s', ext, node_root_dir);\n        log.error(logprefix, 'Could not find exports file');\n        return callback(new Error(msg));\n      }\n    } // this logic ported from the old `gyp_addon` python file\n\n\n    var gyp_script = path.resolve(__dirname, '..', 'gyp', 'gyp_main.py');\n    var addon_gypi = path.resolve(__dirname, '..', 'addon.gypi');\n    var common_gypi = path.resolve(nodeDir, 'include/node/common.gypi');\n    fs.stat(common_gypi, function (err, stat) {\n      if (err) common_gypi = path.resolve(nodeDir, 'common.gypi');\n      var output_dir = 'build';\n\n      if (win) {\n        // Windows expects an absolute path\n        output_dir = buildDir;\n      }\n\n      var nodeGypDir = path.resolve(__dirname, '..');\n      var nodeLibFile = path.join(nodeDir, !gyp.opts.nodedir ? '<(target_arch)' : '$(Configuration)', release.name + '.lib');\n      argv.push('-I', addon_gypi);\n      argv.push('-I', common_gypi);\n      argv.push('-Dlibrary=shared_library');\n      argv.push('-Dvisibility=default');\n      argv.push('-Dnode_root_dir=' + nodeDir);\n\n      if (process.platform === 'aix' || process.platform === 'os390') {\n        argv.push('-Dnode_exp_file=' + node_exp_file);\n      }\n\n      argv.push('-Dnode_gyp_dir=' + nodeGypDir);\n      argv.push('-Dnode_lib_file=' + nodeLibFile);\n      argv.push('-Dmodule_root_dir=' + process.cwd());\n      argv.push('-Dnode_engine=' + (gyp.opts.node_engine || process.jsEngine || 'v8'));\n      argv.push('--depth=.');\n      argv.push('--no-parallel'); // tell gyp to write the Makefile/Solution files into output_dir\n\n      argv.push('--generator-output', output_dir); // tell make to write its output into the same dir\n\n      argv.push('-Goutput_dir=.'); // enforce use of the \"binding.gyp\" file\n\n      argv.unshift('binding.gyp'); // execute `gyp` from the current target nodedir\n\n      argv.unshift(gyp_script); // make sure python uses files that came with this particular node package\n\n      var pypath = [path.join(__dirname, '..', 'gyp', 'pylib')];\n\n      if (process.env.PYTHONPATH) {\n        pypath.push(process.env.PYTHONPATH);\n      }\n\n      process.env.PYTHONPATH = pypath.join(win ? ';' : ':');\n      var cp = gyp.spawn(python, argv);\n      cp.on('exit', onCpExit);\n    });\n  }\n  /**\n   * Called when the `gyp` child process exits.\n   */\n\n\n  function onCpExit(code, signal) {\n    if (code !== 0) {\n      callback(new Error('`gyp` failed with exit code: ' + code));\n    } else {\n      // we're done\n      callback();\n    }\n  }\n}\n/**\n * Returns the first file or directory from an array of candidates that is\n * readable by the current user, or undefined if none of the candidates are\n * readable.\n */\n\n\nfunction findAccessibleSync(logprefix, dir, candidates) {\n  for (var next = 0; next < candidates.length; next++) {\n    var candidate = path.resolve(dir, candidates[next]);\n\n    try {\n      var fd = fs.openSync(candidate, 'r');\n    } catch (e) {\n      // this candidate was not found or not readable, do nothing\n      log.silly(logprefix, 'Could not open %s: %s', candidate, e.message);\n      continue;\n    }\n\n    fs.closeSync(fd);\n    log.silly(logprefix, 'Found readable %s', candidate);\n    return candidate;\n  }\n\n  return undefined;\n}\n\nfunction PythonFinder(python, callback) {\n  this.callback = callback;\n  this.python = python;\n}\n\nPythonFinder.prototype = {\n  checkPythonLauncherDepth: 0,\n  env: process.env,\n  execFile: cp.execFile,\n  log: log,\n  resolve: path.win32 && path.win32.resolve || path.resolve,\n  stat: fs.stat,\n  which: which,\n  win: win,\n  checkPython: function checkPython() {\n    this.log.verbose('check python', 'checking for Python executable \"%s\" in the PATH', this.python);\n    this.which(this.python, function (err, execPath) {\n      if (err) {\n        this.log.verbose('`which` failed', this.python, err);\n\n        if (this.python === 'python2') {\n          this.python = 'python';\n          return this.checkPython();\n        }\n\n        if (this.win) {\n          this.checkPythonLauncher();\n        } else {\n          this.failNoPython();\n        }\n      } else {\n        this.log.verbose('`which` succeeded', this.python, execPath); // Found the `python` executable, and from now on we use it explicitly.\n        // This solves #667 and #750 (`execFile` won't run batch files\n        // (*.cmd, and *.bat))\n\n        this.python = execPath;\n        this.checkPythonVersion();\n      }\n    }.bind(this));\n  },\n  // Distributions of Python on Windows by default install with the \"py.exe\"\n  // Python launcher which is more likely to exist than the Python executable\n  // being in the $PATH.\n  // Because the Python launcher supports all versions of Python, we have to\n  // explicitly request a Python 2 version. This is done by supplying \"-2\" as\n  // the first command line argument. Since \"py.exe -2\" would be an invalid\n  // executable for \"execFile\", we have to use the launcher to figure out\n  // where the actual \"python.exe\" executable is located.\n  checkPythonLauncher: function checkPythonLauncher() {\n    this.checkPythonLauncherDepth += 1;\n    this.log.verbose('could not find \"' + this.python + '\". checking python launcher');\n    var env = extend({}, this.env);\n    env.TERM = 'dumb';\n    var launcherArgs = ['-2', '-c', 'import sys; print sys.executable'];\n    this.execFile('py.exe', launcherArgs, {\n      env: env\n    }, function (err, stdout) {\n      if (err) {\n        this.guessPython();\n      } else {\n        this.python = stdout.trim();\n        this.log.verbose('check python launcher', 'python executable found: %j', this.python);\n        this.checkPythonVersion();\n      }\n\n      this.checkPythonLauncherDepth -= 1;\n    }.bind(this));\n  },\n  checkPythonVersion: function checkPythonVersion() {\n    var args = ['-c', 'import sys; print \"%s.%s.%s\" % sys.version_info[:3];'];\n    var env = extend({}, this.env);\n    env.TERM = 'dumb';\n    this.execFile(this.python, args, {\n      env: env\n    }, function (err, stdout) {\n      if (err) {\n        return this.callback(err);\n      }\n\n      this.log.verbose('check python version', '`%s -c \"' + args[1] + '\"` returned: %j', this.python, stdout);\n      var version = stdout.trim();\n      var range = semver.Range('>=2.5.0 <3.0.0');\n      var valid = false;\n\n      try {\n        valid = range.test(version);\n      } catch (e) {\n        this.log.silly('range.test() error', e);\n      }\n\n      if (valid) {\n        this.callback(null, this.python);\n      } else if (this.win && this.checkPythonLauncherDepth === 0) {\n        this.checkPythonLauncher();\n      } else {\n        this.failPythonVersion(version);\n      }\n    }.bind(this));\n  },\n  failNoPython: function failNoPython() {\n    var errmsg = 'Can\\'t find Python executable \"' + this.python + '\", you can set the PYTHON env variable.';\n    this.callback(new Error(errmsg));\n  },\n  failPythonVersion: function failPythonVersion(badVersion) {\n    var errmsg = 'Python executable \"' + this.python + '\" is v' + badVersion + ', which is not supported by gyp.\\n' + 'You can pass the --python switch to point to ' + 'Python >= v2.5.0 & < 3.0.0.';\n    this.callback(new Error(errmsg));\n  },\n  // Called on Windows when \"python\" isn't available in the current $PATH.\n  // We are going to check if \"%SystemDrive%\\python27\\python.exe\" exists.\n  guessPython: function guessPython() {\n    this.log.verbose('could not find \"' + this.python + '\". guessing location');\n    var rootDir = this.env.SystemDrive || 'C:\\\\';\n\n    if (rootDir[rootDir.length - 1] !== '\\\\') {\n      rootDir += '\\\\';\n    }\n\n    var pythonPath = this.resolve(rootDir, 'Python27', 'python.exe');\n    this.log.verbose('ensuring that file exists:', pythonPath);\n    this.stat(pythonPath, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          this.failNoPython();\n        } else {\n          this.callback(err);\n        }\n\n        return;\n      }\n\n      this.python = pythonPath;\n      this.checkPythonVersion();\n    }.bind(this));\n  }\n};\n\nfunction findPython(python, callback) {\n  var finder = new PythonFinder(python, callback);\n  finder.checkPython();\n}","map":null,"metadata":{},"sourceType":"script"}