{"ast":null,"code":"module.exports = exports = function exports(gyp, argv, callback) {\n  return install(fs, gyp, argv, callback);\n};\n\nmodule.exports.test = {\n  download: download,\n  install: install,\n  readCAFile: readCAFile\n};\nexports.usage = 'Install node development files for the specified node version.';\n/**\n * Module dependencies.\n */\n\nvar fs = require('graceful-fs'),\n    osenv = require('osenv'),\n    tar = require('tar'),\n    rm = require('rimraf'),\n    path = require('path'),\n    crypto = require('crypto'),\n    zlib = require('zlib'),\n    log = require('npmlog'),\n    semver = require('semver'),\n    fstream = require('fstream'),\n    request = require('request'),\n    mkdir = require('mkdirp'),\n    processRelease = require('./process-release'),\n    win = process.platform == 'win32';\n\nfunction install(fs, gyp, argv, callback) {\n  var release = processRelease(argv, gyp, process.version, process.release); // ensure no double-callbacks happen\n\n  function cb(err) {\n    if (cb.done) return;\n    cb.done = true;\n\n    if (err) {\n      log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n      gyp.commands.remove([release.versionDir], function (err2) {\n        callback(err);\n      });\n    } else {\n      callback(null, release.version);\n    }\n  } // Determine which node dev files version we are installing\n\n\n  log.verbose('install', 'input version string %j', release.version);\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    return callback(new Error('Invalid version number: ' + release.version));\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    return callback(new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version));\n  } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version);\n\n    if (gyp.opts.nodedir) {\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      callback();\n    } else {\n      callback(new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead'));\n    }\n\n    return;\n  } // flatten version into String\n\n\n  log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n  var devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n    fs.stat(devDir, function (err, stat) {\n      if (err) {\n        if (err.code == 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          go();\n        } else if (err.code == 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      var installVersionFile = path.resolve(devDir, 'installVersion');\n      fs.readFile(installVersionFile, 'ascii', function (err, ver) {\n        if (err && err.code != 'ENOENT') {\n          return cb(err);\n        }\n\n        var installVersion = parseInt(ver, 10) || 0;\n        log.verbose('got \"installVersion\"', installVersion);\n        log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n        if (installVersion < gyp.package.installVersion) {\n          log.verbose('install', 'version is no good; reinstalling');\n          go();\n        } else {\n          log.verbose('install', 'version is good');\n          cb();\n        }\n      });\n    });\n  } else {\n    go();\n  }\n\n  function getContentSha(res, callback) {\n    var shasum = crypto.createHash('sha256');\n    res.on('data', function (chunk) {\n      shasum.update(chunk);\n    }).on('end', function () {\n      callback(null, shasum.digest('hex'));\n    });\n  }\n\n  function go() {\n    log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n    mkdir(devDir, function (err, created) {\n      if (err) {\n        if (err.code == 'EACCES') {\n          eaccesFallback(err);\n        } else {\n          cb(err);\n        }\n\n        return;\n      }\n\n      if (created) {\n        log.verbose('created nodedir', created);\n      } // now download the node tarball\n\n\n      var tarPath = gyp.opts.tarball;\n      var badDownload = false,\n          extractCount = 0,\n          gunzip = zlib.createGunzip(),\n          extracter = tar.Extract({\n        path: devDir,\n        strip: 1,\n        filter: isValid\n      });\n      var contentShasums = {};\n      var expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n      // only .h header files and the gyp files get extracted\n\n      function isValid() {\n        var name = this.path.substring(devDir.length + 1);\n        var isValid = valid(name);\n\n        if (name === '' && this.type === 'Directory') {\n          // the first directory entry is ok\n          return true;\n        }\n\n        if (isValid) {\n          log.verbose('extracted file from tarball', name);\n          extractCount++;\n        } else {\n          // invalid\n          log.silly('ignoring from tarball', name);\n        }\n\n        return isValid;\n      }\n\n      gunzip.on('error', cb);\n      extracter.on('error', cb);\n      extracter.on('end', afterTarball); // download the tarball, gunzip and extract!\n\n      if (tarPath) {\n        var input = fs.createReadStream(tarPath);\n        input.pipe(gunzip).pipe(extracter);\n        return;\n      }\n\n      try {\n        var req = download(gyp, process.env, release.tarballUrl);\n      } catch (e) {\n        return cb(e);\n      } // something went wrong downloading the tarball?\n\n\n      req.on('error', function (err) {\n        if (err.code === 'ENOTFOUND') {\n          return cb(new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.'));\n        }\n\n        badDownload = true;\n        cb(err);\n      });\n      req.on('close', function () {\n        if (extractCount === 0) {\n          cb(new Error('Connection closed while downloading tarball file'));\n        }\n      });\n      req.on('response', function (res) {\n        if (res.statusCode !== 200) {\n          badDownload = true;\n          cb(new Error(res.statusCode + ' response downloading ' + release.tarballUrl));\n          return;\n        } // content checksum\n\n\n        getContentSha(res, function (_, checksum) {\n          var filename = path.basename(release.tarballUrl).trim();\n          contentShasums[filename] = checksum;\n          log.verbose('content checksum', filename, checksum);\n        }); // start unzipping and untaring\n\n        req.pipe(gunzip).pipe(extracter);\n      }); // invoked after the tarball has finished being extracted\n\n      function afterTarball() {\n        if (badDownload) return;\n\n        if (extractCount === 0) {\n          return cb(new Error('There was a fatal problem while downloading/extracting the tarball'));\n        }\n\n        log.verbose('tarball', 'done parsing tarball');\n        var async = 0;\n\n        if (win) {\n          // need to download node.lib\n          async++;\n          downloadNodeLib(deref);\n        } // write the \"installVersion\" file\n\n\n        async++;\n        var installVersionPath = path.resolve(devDir, 'installVersion');\n        fs.writeFile(installVersionPath, gyp.package.installVersion + '\\n', deref); // Only download SHASUMS.txt if not using tarPath override\n\n        if (!tarPath) {\n          // download SHASUMS.txt\n          async++;\n          downloadShasums(deref);\n        }\n\n        if (async === 0) {\n          // no async tasks required\n          cb();\n        }\n\n        function deref(err) {\n          if (err) return cb(err);\n          async--;\n\n          if (!async) {\n            log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n            for (var k in contentShasums) {\n              log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n              if (contentShasums[k] !== expectShasums[k]) {\n                cb(new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]));\n                return;\n              }\n            }\n\n            cb();\n          }\n        }\n      }\n\n      function downloadShasums(done) {\n        log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n        var shasumsPath = path.resolve(devDir, 'SHASUMS256.txt');\n        log.verbose('checksum url', release.shasumsUrl);\n\n        try {\n          var req = download(gyp, process.env, release.shasumsUrl);\n        } catch (e) {\n          return cb(e);\n        }\n\n        req.on('error', done);\n        req.on('response', function (res) {\n          if (res.statusCode !== 200) {\n            done(new Error(res.statusCode + ' status code downloading checksum'));\n            return;\n          }\n\n          var chunks = [];\n          res.on('data', function (chunk) {\n            chunks.push(chunk);\n          });\n          res.on('end', function () {\n            var lines = Buffer.concat(chunks).toString().trim().split('\\n');\n            lines.forEach(function (line) {\n              var items = line.trim().split(/\\s+/);\n              if (items.length !== 2) return; // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n              var name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            });\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n            done();\n          });\n        });\n      }\n\n      function downloadNodeLib(done) {\n        log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n        var dir32 = path.resolve(devDir, 'ia32'),\n            dir64 = path.resolve(devDir, 'x64'),\n            libPath32 = path.resolve(dir32, release.name + '.lib'),\n            libPath64 = path.resolve(dir64, release.name + '.lib');\n        log.verbose('32-bit ' + release.name + '.lib dir', dir32);\n        log.verbose('64-bit ' + release.name + '.lib dir', dir64);\n        log.verbose('`' + release.name + '.lib` 32-bit url', release.libUrl32);\n        log.verbose('`' + release.name + '.lib` 64-bit url', release.libUrl64);\n        var async = 2;\n        mkdir(dir32, function (err) {\n          if (err) return done(err);\n          log.verbose('streaming 32-bit ' + release.name + '.lib to:', libPath32);\n\n          try {\n            var req = download(gyp, process.env, release.libUrl32, cb);\n          } catch (e) {\n            return cb(e);\n          }\n\n          req.on('error', done);\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 32-bit ' + release.name + '.lib'));\n              return;\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath32] = checksum;\n              log.verbose('content checksum', release.libPath32, checksum);\n            });\n            var ws = fs.createWriteStream(libPath32);\n            ws.on('error', cb);\n            req.pipe(ws);\n          });\n          req.on('end', function () {\n            --async || done();\n          });\n        });\n        mkdir(dir64, function (err) {\n          if (err) return done(err);\n          log.verbose('streaming 64-bit ' + release.name + '.lib to:', libPath64);\n\n          try {\n            var req = download(gyp, process.env, release.libUrl64, cb);\n          } catch (e) {\n            return cb(e);\n          }\n\n          req.on('error', done);\n          req.on('response', function (res) {\n            if (res.statusCode !== 200) {\n              done(new Error(res.statusCode + ' status code downloading 64-bit ' + release.name + '.lib'));\n              return;\n            }\n\n            getContentSha(res, function (_, checksum) {\n              contentShasums[release.libPath64] = checksum;\n              log.verbose('content checksum', release.libPath64, checksum);\n            });\n            var ws = fs.createWriteStream(libPath64);\n            ws.on('error', cb);\n            req.pipe(ws);\n          });\n          req.on('end', function () {\n            --async || done();\n          });\n        });\n      } // downloadNodeLib()\n\n    }); // mkdir()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n\n  function valid(file) {\n    // header files\n    var extname = path.extname(file);\n    return extname === '.h' || extname === '.gypi';\n  }\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n\n  function eaccesFallback(err) {\n    var noretry = '--node_gyp_internal_noretry';\n    if (-1 !== argv.indexOf(noretry)) return cb(err);\n    var tmpdir = osenv.tmpdir();\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n    log.warn('EACCES', 'user \"%s\" does not have permission to access the dev dir \"%s\"', osenv.user(), devDir);\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n    if (process.cwd() == tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n      gyp.todo.push({\n        name: 'remove',\n        args: argv\n      });\n    }\n\n    gyp.commands.install([noretry].concat(argv), cb);\n  }\n}\n\nfunction download(gyp, env, url) {\n  log.http('GET', url);\n  var requestOpts = {\n    uri: url,\n    headers: {\n      'User-Agent': 'node-gyp v' + gyp.version + ' (node ' + process.version + ')'\n    }\n  };\n  var cafile = gyp.opts.cafile;\n\n  if (cafile) {\n    requestOpts.ca = readCAFile(cafile);\n  } // basic support for a proxy server\n\n\n  var proxyUrl = gyp.opts.proxy || env.http_proxy || env.HTTP_PROXY || env.npm_config_proxy;\n\n  if (proxyUrl) {\n    if (/^https?:\\/\\//i.test(proxyUrl)) {\n      log.verbose('download', 'using proxy url: \"%s\"', proxyUrl);\n      requestOpts.proxy = proxyUrl;\n    } else {\n      log.warn('download', 'ignoring invalid \"proxy\" config setting: \"%s\"', proxyUrl);\n    }\n  }\n\n  var req = request(requestOpts);\n  req.on('response', function (res) {\n    log.http(res.statusCode, url);\n  });\n  return req;\n}\n\nfunction readCAFile(filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  var ca = fs.readFileSync(filename, 'utf8');\n  var re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n  return ca.match(re);\n}","map":null,"metadata":{},"sourceType":"script"}