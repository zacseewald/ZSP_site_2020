{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    SyncHook = _require.SyncHook,\n    MultiHook = _require.MultiHook;\n\nvar asyncLib = require(\"neo-async\");\n\nvar MultiWatching = require(\"./MultiWatching\");\n\nvar MultiStats = require(\"./MultiStats\");\n\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\nmodule.exports =\n/*#__PURE__*/\nfunction (_Tapable) {\n  _inherits(MultiCompiler, _Tapable);\n\n  function MultiCompiler(compilers) {\n    var _this;\n\n    _classCallCheck(this, MultiCompiler);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MultiCompiler).call(this));\n    _this.hooks = {\n      done: new SyncHook([\"stats\"]),\n      invalid: new MultiHook(compilers.map(function (c) {\n        return c.hooks.invalid;\n      })),\n      run: new MultiHook(compilers.map(function (c) {\n        return c.hooks.run;\n      })),\n      watchClose: new SyncHook([]),\n      watchRun: new MultiHook(compilers.map(function (c) {\n        return c.hooks.watchRun;\n      }))\n    };\n\n    if (!Array.isArray(compilers)) {\n      compilers = Object.keys(compilers).map(function (name) {\n        compilers[name].name = name;\n        return compilers[name];\n      });\n    }\n\n    _this.compilers = compilers;\n    var doneCompilers = 0;\n    var compilerStats = [];\n    var index = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      var _loop = function _loop() {\n        var compiler = _step.value;\n        var compilerDone = false;\n        var compilerIndex = index++; // eslint-disable-next-line no-loop-func\n\n        compiler.hooks.done.tap(\"MultiCompiler\", function (stats) {\n          if (!compilerDone) {\n            compilerDone = true;\n            doneCompilers++;\n          }\n\n          compilerStats[compilerIndex] = stats;\n\n          if (doneCompilers === _this.compilers.length) {\n            _this.hooks.done.call(new MultiStats(compilerStats));\n          }\n        }); // eslint-disable-next-line no-loop-func\n\n        compiler.hooks.invalid.tap(\"MultiCompiler\", function () {\n          if (compilerDone) {\n            compilerDone = false;\n            doneCompilers--;\n          }\n        });\n      };\n\n      for (var _iterator = _this.compilers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        _loop();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    _this.running = false;\n    return _this;\n  }\n\n  _createClass(MultiCompiler, [{\n    key: \"validateDependencies\",\n    value: function validateDependencies(callback) {\n      var _this2 = this;\n\n      var edges = new Set();\n      var missing = [];\n\n      var targetFound = function targetFound(compiler) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = edges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var edge = _step2.value;\n\n            if (edge.target === compiler) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return false;\n      };\n\n      var sortEdges = function sortEdges(e1, e2) {\n        return e1.source.name.localeCompare(e2.source.name) || e1.target.name.localeCompare(e2.target.name);\n      };\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.compilers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var source = _step3.value;\n\n          if (source.dependencies) {\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              var _loop2 = function _loop2() {\n                var dep = _step5.value;\n\n                var target = _this2.compilers.find(function (c) {\n                  return c.name === dep;\n                });\n\n                if (!target) {\n                  missing.push(dep);\n                } else {\n                  edges.add({\n                    source: source,\n                    target: target\n                  });\n                }\n              };\n\n              for (var _iterator5 = source.dependencies[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                _loop2();\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var errors = missing.map(function (m) {\n        return \"Compiler dependency `\".concat(m, \"` not found.\");\n      });\n      var stack = this.compilers.filter(function (c) {\n        return !targetFound(c);\n      });\n\n      while (stack.length > 0) {\n        var current = stack.pop();\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = edges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var edge = _step4.value;\n\n            if (edge.source === current) {\n              edges.delete(edge);\n              var target = edge.target;\n\n              if (!targetFound(target)) {\n                stack.push(target);\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      if (edges.size > 0) {\n        var lines = Array.from(edges).sort(sortEdges).map(function (edge) {\n          return \"\".concat(edge.source.name, \" -> \").concat(edge.target.name);\n        });\n        lines.unshift(\"Circular dependency found in compiler dependencies.\");\n        errors.unshift(lines.join(\"\\n\"));\n      }\n\n      if (errors.length > 0) {\n        var message = errors.join(\"\\n\");\n        callback(new Error(message));\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"runWithDependencies\",\n    value: function runWithDependencies(compilers, fn, callback) {\n      var fulfilledNames = new Set();\n      var remainingCompilers = compilers;\n\n      var isDependencyFulfilled = function isDependencyFulfilled(d) {\n        return fulfilledNames.has(d);\n      };\n\n      var getReadyCompilers = function getReadyCompilers() {\n        var readyCompilers = [];\n        var list = remainingCompilers;\n        remainingCompilers = [];\n        var _iteratorNormalCompletion6 = true;\n        var _didIteratorError6 = false;\n        var _iteratorError6 = undefined;\n\n        try {\n          for (var _iterator6 = list[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n            var c = _step6.value;\n            var ready = !c.dependencies || c.dependencies.every(isDependencyFulfilled);\n\n            if (ready) {\n              readyCompilers.push(c);\n            } else {\n              remainingCompilers.push(c);\n            }\n          }\n        } catch (err) {\n          _didIteratorError6 = true;\n          _iteratorError6 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n              _iterator6.return();\n            }\n          } finally {\n            if (_didIteratorError6) {\n              throw _iteratorError6;\n            }\n          }\n        }\n\n        return readyCompilers;\n      };\n\n      var runCompilers = function runCompilers(callback) {\n        if (remainingCompilers.length === 0) return callback();\n        asyncLib.map(getReadyCompilers(), function (compiler, callback) {\n          fn(compiler, function (err) {\n            if (err) return callback(err);\n            fulfilledNames.add(compiler.name);\n            runCompilers(callback);\n          });\n        }, callback);\n      };\n\n      runCompilers(callback);\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      var _this3 = this;\n\n      if (this.running) return handler(new ConcurrentCompilationError());\n      var watchings = [];\n      var allStats = this.compilers.map(function () {\n        return null;\n      });\n      var compilerStatus = this.compilers.map(function () {\n        return false;\n      });\n\n      if (this.validateDependencies(handler)) {\n        this.running = true;\n        this.runWithDependencies(this.compilers, function (compiler, callback) {\n          var compilerIdx = _this3.compilers.indexOf(compiler);\n\n          var firstRun = true;\n          var watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[compilerIdx] : watchOptions, function (err, stats) {\n            if (err) handler(err);\n\n            if (stats) {\n              allStats[compilerIdx] = stats;\n              compilerStatus[compilerIdx] = \"new\";\n\n              if (compilerStatus.every(Boolean)) {\n                var freshStats = allStats.filter(function (s, idx) {\n                  return compilerStatus[idx] === \"new\";\n                });\n                compilerStatus.fill(true);\n                var multiStats = new MultiStats(freshStats);\n                handler(null, multiStats);\n              }\n            }\n\n            if (firstRun && !err) {\n              firstRun = false;\n              callback();\n            }\n          });\n          watchings.push(watching);\n        }, function () {// ignore\n        });\n      }\n\n      return new MultiWatching(watchings, this);\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this4 = this;\n\n      if (this.running) {\n        return callback(new ConcurrentCompilationError());\n      }\n\n      var finalCallback = function finalCallback(err, stats) {\n        _this4.running = false;\n\n        if (callback !== undefined) {\n          return callback(err, stats);\n        }\n      };\n\n      var allStats = this.compilers.map(function () {\n        return null;\n      });\n\n      if (this.validateDependencies(callback)) {\n        this.running = true;\n        this.runWithDependencies(this.compilers, function (compiler, callback) {\n          var compilerIdx = _this4.compilers.indexOf(compiler);\n\n          compiler.run(function (err, stats) {\n            if (err) {\n              return callback(err);\n            }\n\n            allStats[compilerIdx] = stats;\n            callback();\n          });\n        }, function (err) {\n          if (err) {\n            return finalCallback(err);\n          }\n\n          finalCallback(null, new MultiStats(allStats));\n        });\n      }\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.compilers[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var compiler = _step7.value;\n\n          if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n            compiler.inputFileSystem.purge();\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"outputPath\",\n    get: function get() {\n      var commonPath = this.compilers[0].outputPath;\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this.compilers[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var compiler = _step8.value;\n\n          while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n            commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n          }\n        }\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n      return commonPath;\n    }\n  }, {\n    key: \"inputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = this.compilers[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var compiler = _step9.value;\n          compiler.inputFileSystem = value;\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"outputFileSystem\",\n    get: function get() {\n      throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n    },\n    set: function set(value) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = this.compilers[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var compiler = _step10.value;\n          compiler.outputFileSystem = value;\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n  }]);\n\n  return MultiCompiler;\n}(Tapable);","map":null,"metadata":{},"sourceType":"script"}