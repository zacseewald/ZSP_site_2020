{"ast":null,"code":"module.exports = Reader;\n\nvar fs = require('graceful-fs');\n\nvar Stream = require('stream').Stream;\n\nvar inherits = require('inherits');\n\nvar path = require('path');\n\nvar getType = require('./get-type.js');\n\nvar hardLinks = Reader.hardLinks = {};\n\nvar Abstract = require('./abstract.js'); // Must do this *before* loading the child classes\n\n\ninherits(Reader, Abstract);\n\nvar LinkReader = require('./link-reader.js');\n\nfunction Reader(props, currentStat) {\n  var self = this;\n  if (!(self instanceof Reader)) return new Reader(props, currentStat);\n\n  if (typeof props === 'string') {\n    props = {\n      path: props\n    };\n  } // polymorphism.\n  // call fstream.Reader(dir) to get a DirReader object, etc.\n  // Note that, unlike in the Writer case, ProxyReader is going\n  // to be the *normal* state of affairs, since we rarely know\n  // the type of a file prior to reading it.\n\n\n  var type;\n  var ClassType;\n\n  if (props.type && typeof props.type === 'function') {\n    type = props.type;\n    ClassType = type;\n  } else {\n    type = getType(props);\n    ClassType = Reader;\n  }\n\n  if (currentStat && !type) {\n    type = getType(currentStat);\n    props[type] = true;\n    props.type = type;\n  }\n\n  switch (type) {\n    case 'Directory':\n      ClassType = require('./dir-reader.js');\n      break;\n\n    case 'Link': // XXX hard links are just files.\n    // However, it would be good to keep track of files' dev+inode\n    // and nlink values, and create a HardLinkReader that emits\n    // a linkpath value of the original copy, so that the tar\n    // writer can preserve them.\n    // ClassType = HardLinkReader\n    // break\n\n    case 'File':\n      ClassType = require('./file-reader.js');\n      break;\n\n    case 'SymbolicLink':\n      ClassType = LinkReader;\n      break;\n\n    case 'Socket':\n      ClassType = require('./socket-reader.js');\n      break;\n\n    case null:\n      ClassType = require('./proxy-reader.js');\n      break;\n  }\n\n  if (!(self instanceof ClassType)) {\n    return new ClassType(props);\n  }\n\n  Abstract.call(self);\n\n  if (!props.path) {\n    self.error('Must provide a path', null, true);\n  }\n\n  self.readable = true;\n  self.writable = false;\n  self.type = type;\n  self.props = props;\n  self.depth = props.depth = props.depth || 0;\n  self.parent = props.parent || null;\n  self.root = props.root || props.parent && props.parent.root || self;\n  self._path = self.path = path.resolve(props.path);\n\n  if (process.platform === 'win32') {\n    self.path = self._path = self.path.replace(/\\?/g, '_');\n\n    if (self._path.length >= 260) {\n      // how DOES one create files on the moon?\n      // if the path has spaces in it, then UNC will fail.\n      self._swallowErrors = true; // if (self._path.indexOf(\" \") === -1) {\n\n      self._path = '\\\\\\\\?\\\\' + self.path.replace(/\\//g, '\\\\'); // }\n    }\n  }\n\n  self.basename = props.basename = path.basename(self.path);\n  self.dirname = props.dirname = path.dirname(self.path); // these have served their purpose, and are now just noisy clutter\n\n  props.parent = props.root = null; // console.error(\"\\n\\n\\n%s setting size to\", props.path, props.size)\n\n  self.size = props.size;\n  self.filter = typeof props.filter === 'function' ? props.filter : null;\n  if (props.sort === 'alpha') props.sort = alphasort; // start the ball rolling.\n  // this will stat the thing, and then call self._read()\n  // to start reading whatever it is.\n  // console.error(\"calling stat\", props.path, currentStat)\n\n  self._stat(currentStat);\n}\n\nfunction alphasort(a, b) {\n  return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;\n}\n\nReader.prototype._stat = function (currentStat) {\n  var self = this;\n  var props = self.props;\n  var stat = props.follow ? 'stat' : 'lstat'; // console.error(\"Reader._stat\", self._path, currentStat)\n\n  if (currentStat) process.nextTick(statCb.bind(null, null, currentStat));else fs[stat](self._path, statCb);\n\n  function statCb(er, props_) {\n    // console.error(\"Reader._stat, statCb\", self._path, props_, props_.nlink)\n    if (er) return self.error(er);\n    Object.keys(props_).forEach(function (k) {\n      props[k] = props_[k];\n    }); // if it's not the expected size, then abort here.\n\n    if (undefined !== self.size && props.size !== self.size) {\n      return self.error('incorrect size');\n    }\n\n    self.size = props.size;\n    var type = getType(props);\n    var handleHardlinks = props.hardlinks !== false; // special little thing for handling hardlinks.\n\n    if (handleHardlinks && type !== 'Directory' && props.nlink && props.nlink > 1) {\n      var k = props.dev + ':' + props.ino; // console.error(\"Reader has nlink\", self._path, k)\n\n      if (hardLinks[k] === self._path || !hardLinks[k]) {\n        hardLinks[k] = self._path;\n      } else {\n        // switch into hardlink mode.\n        type = self.type = self.props.type = 'Link';\n        self.Link = self.props.Link = true;\n        self.linkpath = self.props.linkpath = hardLinks[k]; // console.error(\"Hardlink detected, switching mode\", self._path, self.linkpath)\n        // Setting __proto__ would arguably be the \"correct\"\n        // approach here, but that just seems too wrong.\n\n        self._stat = self._read = LinkReader.prototype._read;\n      }\n    }\n\n    if (self.type && self.type !== type) {\n      self.error('Unexpected type: ' + type);\n    } // if the filter doesn't pass, then just skip over this one.\n    // still have to emit end so that dir-walking can move on.\n\n\n    if (self.filter) {\n      var who = self._proxy || self; // special handling for ProxyReaders\n\n      if (!self.filter.call(who, who, props)) {\n        if (!self._disowned) {\n          self.abort();\n          self.emit('end');\n          self.emit('close');\n        }\n\n        return;\n      }\n    } // last chance to abort or disown before the flow starts!\n\n\n    var events = ['_stat', 'stat', 'ready'];\n    var e = 0;\n\n    (function go() {\n      if (self._aborted) {\n        self.emit('end');\n        self.emit('close');\n        return;\n      }\n\n      if (self._paused && self.type !== 'Directory') {\n        self.once('resume', go);\n        return;\n      }\n\n      var ev = events[e++];\n\n      if (!ev) {\n        return self._read();\n      }\n\n      self.emit(ev, props);\n      go();\n    })();\n  }\n};\n\nReader.prototype.pipe = function (dest) {\n  var self = this;\n\n  if (typeof dest.add === 'function') {\n    // piping to a multi-compatible, and we've got directory entries.\n    self.on('entry', function (entry) {\n      var ret = dest.add(entry);\n\n      if (ret === false) {\n        self.pause();\n      }\n    });\n  } // console.error(\"R Pipe apply Stream Pipe\")\n\n\n  return Stream.prototype.pipe.apply(this, arguments);\n};\n\nReader.prototype.pause = function (who) {\n  this._paused = true;\n  who = who || this;\n  this.emit('pause', who);\n  if (this._stream) this._stream.pause(who);\n};\n\nReader.prototype.resume = function (who) {\n  this._paused = false;\n  who = who || this;\n  this.emit('resume', who);\n  if (this._stream) this._stream.resume(who);\n\n  this._read();\n};\n\nReader.prototype._read = function () {\n  this.error('Cannot read unknown type: ' + this.type);\n};","map":null,"metadata":{},"sourceType":"script"}