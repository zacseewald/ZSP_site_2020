{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar path = require(\"path\");\n\nvar asyncLib = require(\"neo-async\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    AsyncSeriesWaterfallHook = _require.AsyncSeriesWaterfallHook,\n    SyncWaterfallHook = _require.SyncWaterfallHook,\n    SyncBailHook = _require.SyncBailHook,\n    SyncHook = _require.SyncHook,\n    HookMap = _require.HookMap;\n\nvar NormalModule = require(\"./NormalModule\");\n\nvar RawModule = require(\"./RawModule\");\n\nvar RuleSet = require(\"./RuleSet\");\n\nvar cachedMerge = require(\"./util/cachedMerge\");\n\nvar EMPTY_RESOLVE_OPTIONS = {};\nvar MATCH_RESOURCE_REGEX = /^([^!]+)!=!/;\n\nvar loaderToIdent = function loaderToIdent(data) {\n  if (!data.options) {\n    return data.loader;\n  }\n\n  if (typeof data.options === \"string\") {\n    return data.loader + \"?\" + data.options;\n  }\n\n  if (typeof data.options !== \"object\") {\n    throw new Error(\"loader options must be string or object\");\n  }\n\n  if (data.ident) {\n    return data.loader + \"??\" + data.ident;\n  }\n\n  return data.loader + \"?\" + JSON.stringify(data.options);\n};\n\nvar identToLoaderRequest = function identToLoaderRequest(resultString) {\n  var idx = resultString.indexOf(\"?\");\n\n  if (idx >= 0) {\n    var loader = resultString.substr(0, idx);\n    var options = resultString.substr(idx + 1);\n    return {\n      loader: loader,\n      options: options\n    };\n  } else {\n    return {\n      loader: resultString,\n      options: undefined\n    };\n  }\n};\n\nvar dependencyCache = new WeakMap();\n\nvar NormalModuleFactory =\n/*#__PURE__*/\nfunction (_Tapable) {\n  _inherits(NormalModuleFactory, _Tapable);\n\n  function NormalModuleFactory(context, resolverFactory, options) {\n    var _this;\n\n    _classCallCheck(this, NormalModuleFactory);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NormalModuleFactory).call(this));\n    _this.hooks = {\n      resolver: new SyncWaterfallHook([\"resolver\"]),\n      factory: new SyncWaterfallHook([\"factory\"]),\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      createModule: new SyncBailHook([\"data\"]),\n      module: new SyncWaterfallHook([\"module\", \"data\"]),\n      createParser: new HookMap(function () {\n        return new SyncBailHook([\"parserOptions\"]);\n      }),\n      parser: new HookMap(function () {\n        return new SyncHook([\"parser\", \"parserOptions\"]);\n      }),\n      createGenerator: new HookMap(function () {\n        return new SyncBailHook([\"generatorOptions\"]);\n      }),\n      generator: new HookMap(function () {\n        return new SyncHook([\"generator\", \"generatorOptions\"]);\n      })\n    };\n\n    _this._pluginCompat.tap(\"NormalModuleFactory\", function (options) {\n      switch (options.name) {\n        case \"before-resolve\":\n        case \"after-resolve\":\n          options.async = true;\n          break;\n\n        case \"parser\":\n          _this.hooks.parser.for(\"javascript/auto\").tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\n          return true;\n      }\n\n      var match;\n      match = /^parser (.+)$/.exec(options.name);\n\n      if (match) {\n        _this.hooks.parser.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n        return true;\n      }\n\n      match = /^create-parser (.+)$/.exec(options.name);\n\n      if (match) {\n        _this.hooks.createParser.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n\n        return true;\n      }\n    });\n\n    _this.resolverFactory = resolverFactory;\n    _this.ruleSet = new RuleSet(options.defaultRules.concat(options.rules));\n    _this.cachePredicate = typeof options.unsafeCache === \"function\" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);\n    _this.context = context || \"\";\n    _this.parserCache = Object.create(null);\n    _this.generatorCache = Object.create(null);\n\n    _this.hooks.factory.tap(\"NormalModuleFactory\", function () {\n      return function (result, callback) {\n        var resolver = _this.hooks.resolver.call(null); // Ignored\n\n\n        if (!resolver) return callback();\n        resolver(result, function (err, data) {\n          if (err) return callback(err); // Ignored\n\n          if (!data) return callback(); // direct module\n\n          if (typeof data.source === \"function\") return callback(null, data);\n\n          _this.hooks.afterResolve.callAsync(data, function (err, result) {\n            if (err) return callback(err); // Ignored\n\n            if (!result) return callback();\n\n            var createdModule = _this.hooks.createModule.call(result);\n\n            if (!createdModule) {\n              if (!result.request) {\n                return callback(new Error(\"Empty dependency (no request)\"));\n              }\n\n              createdModule = new NormalModule(result);\n            }\n\n            createdModule = _this.hooks.module.call(createdModule, result);\n            return callback(null, createdModule);\n          });\n        });\n      };\n    });\n\n    _this.hooks.resolver.tap(\"NormalModuleFactory\", function () {\n      return function (data, callback) {\n        var contextInfo = data.contextInfo;\n        var context = data.context;\n        var request = data.request;\n\n        var loaderResolver = _this.getResolver(\"loader\");\n\n        var normalResolver = _this.getResolver(\"normal\", data.resolveOptions);\n\n        var matchResource = undefined;\n        var requestWithoutMatchResource = request;\n        var matchResourceMatch = MATCH_RESOURCE_REGEX.exec(request);\n\n        if (matchResourceMatch) {\n          matchResource = matchResourceMatch[1];\n\n          if (/^\\.\\.?\\//.test(matchResource)) {\n            matchResource = path.join(context, matchResource);\n          }\n\n          requestWithoutMatchResource = request.substr(matchResourceMatch[0].length);\n        }\n\n        var noPreAutoLoaders = requestWithoutMatchResource.startsWith(\"-!\");\n        var noAutoLoaders = noPreAutoLoaders || requestWithoutMatchResource.startsWith(\"!\");\n        var noPrePostAutoLoaders = requestWithoutMatchResource.startsWith(\"!!\");\n        var elements = requestWithoutMatchResource.replace(/^-?!+/, \"\").replace(/!!+/g, \"!\").split(\"!\");\n        var resource = elements.pop();\n        elements = elements.map(identToLoaderRequest);\n        asyncLib.parallel([function (callback) {\n          return _this.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback);\n        }, function (callback) {\n          if (resource === \"\" || resource[0] === \"?\") {\n            return callback(null, {\n              resource: resource\n            });\n          }\n\n          normalResolver.resolve(contextInfo, context, resource, {}, function (err, resource, resourceResolveData) {\n            if (err) return callback(err);\n            callback(null, {\n              resourceResolveData: resourceResolveData,\n              resource: resource\n            });\n          });\n        }], function (err, results) {\n          if (err) return callback(err);\n          var loaders = results[0];\n          var resourceResolveData = results[1].resourceResolveData;\n          resource = results[1].resource; // translate option idents\n\n          try {\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = loaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var item = _step.value;\n\n                if (typeof item.options === \"string\" && item.options[0] === \"?\") {\n                  var ident = item.options.substr(1);\n                  item.options = _this.ruleSet.findOptionsByIdent(ident);\n                  item.ident = ident;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator.return != null) {\n                  _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          } catch (e) {\n            return callback(e);\n          }\n\n          if (resource === false) {\n            // ignored\n            return callback(null, new RawModule(\"/* (ignored) */\", \"ignored \".concat(context, \" \").concat(request), \"\".concat(request, \" (ignored)\")));\n          }\n\n          var userRequest = (matchResource !== undefined ? \"\".concat(matchResource, \"!=!\") : \"\") + loaders.map(loaderToIdent).concat([resource]).join(\"!\");\n          var resourcePath = matchResource !== undefined ? matchResource : resource;\n          var resourceQuery = \"\";\n          var queryIndex = resourcePath.indexOf(\"?\");\n\n          if (queryIndex >= 0) {\n            resourceQuery = resourcePath.substr(queryIndex);\n            resourcePath = resourcePath.substr(0, queryIndex);\n          }\n\n          var result = _this.ruleSet.exec({\n            resource: resourcePath,\n            realResource: matchResource !== undefined ? resource.replace(/\\?.*/, \"\") : resourcePath,\n            resourceQuery: resourceQuery,\n            issuer: contextInfo.issuer,\n            compiler: contextInfo.compiler\n          });\n\n          var settings = {};\n          var useLoadersPost = [];\n          var useLoaders = [];\n          var useLoadersPre = [];\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = result[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var r = _step2.value;\n\n              if (r.type === \"use\") {\n                if (r.enforce === \"post\" && !noPrePostAutoLoaders) {\n                  useLoadersPost.push(r.value);\n                } else if (r.enforce === \"pre\" && !noPreAutoLoaders && !noPrePostAutoLoaders) {\n                  useLoadersPre.push(r.value);\n                } else if (!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders) {\n                  useLoaders.push(r.value);\n                }\n              } else if (typeof r.value === \"object\" && r.value !== null && typeof settings[r.type] === \"object\" && settings[r.type] !== null) {\n                settings[r.type] = cachedMerge(settings[r.type], r.value);\n              } else {\n                settings[r.type] = r.value;\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n\n          asyncLib.parallel([_this.resolveRequestArray.bind(_assertThisInitialized(_assertThisInitialized(_this)), contextInfo, _this.context, useLoadersPost, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_assertThisInitialized(_this)), contextInfo, _this.context, useLoaders, loaderResolver), _this.resolveRequestArray.bind(_assertThisInitialized(_assertThisInitialized(_this)), contextInfo, _this.context, useLoadersPre, loaderResolver)], function (err, results) {\n            if (err) return callback(err);\n            loaders = results[0].concat(loaders, results[1], results[2]);\n            process.nextTick(function () {\n              var type = settings.type;\n              var resolveOptions = settings.resolve;\n              callback(null, {\n                context: context,\n                request: loaders.map(loaderToIdent).concat([resource]).join(\"!\"),\n                dependencies: data.dependencies,\n                userRequest: userRequest,\n                rawRequest: request,\n                loaders: loaders,\n                resource: resource,\n                matchResource: matchResource,\n                resourceResolveData: resourceResolveData,\n                settings: settings,\n                type: type,\n                parser: _this.getParser(type, settings.parser),\n                generator: _this.getGenerator(type, settings.generator),\n                resolveOptions: resolveOptions\n              });\n            });\n          });\n        });\n      };\n    });\n\n    return _this;\n  }\n\n  _createClass(NormalModuleFactory, [{\n    key: \"create\",\n    value: function create(data, callback) {\n      var _this2 = this;\n\n      var dependencies = data.dependencies;\n      var cacheEntry = dependencyCache.get(dependencies[0]);\n      if (cacheEntry) return callback(null, cacheEntry);\n      var context = data.context || this.context;\n      var resolveOptions = data.resolveOptions || EMPTY_RESOLVE_OPTIONS;\n      var request = dependencies[0].request;\n      var contextInfo = data.contextInfo || {};\n      this.hooks.beforeResolve.callAsync({\n        contextInfo: contextInfo,\n        resolveOptions: resolveOptions,\n        context: context,\n        request: request,\n        dependencies: dependencies\n      }, function (err, result) {\n        if (err) return callback(err); // Ignored\n\n        if (!result) return callback();\n\n        var factory = _this2.hooks.factory.call(null); // Ignored\n\n\n        if (!factory) return callback();\n        factory(result, function (err, module) {\n          if (err) return callback(err);\n\n          if (module && _this2.cachePredicate(module)) {\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n              for (var _iterator3 = dependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                var d = _step3.value;\n                dependencyCache.set(d, module);\n              }\n            } catch (err) {\n              _didIteratorError3 = true;\n              _iteratorError3 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                  _iterator3.return();\n                }\n              } finally {\n                if (_didIteratorError3) {\n                  throw _iteratorError3;\n                }\n              }\n            }\n          }\n\n          callback(null, module);\n        });\n      });\n    }\n  }, {\n    key: \"resolveRequestArray\",\n    value: function resolveRequestArray(contextInfo, context, array, resolver, callback) {\n      if (array.length === 0) return callback(null, []);\n      asyncLib.map(array, function (item, callback) {\n        resolver.resolve(contextInfo, context, item.loader, {}, function (err, result) {\n          if (err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) {\n            return resolver.resolve(contextInfo, context, item.loader + \"-loader\", {}, function (err2) {\n              if (!err2) {\n                err.message = err.message + \"\\n\" + \"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\\n\" + \"                 You need to specify '\".concat(item.loader, \"-loader' instead of '\").concat(item.loader, \"',\\n\") + \"                 see https://webpack.js.org/migrate/3/#automatic-loader-module-name-extension-removed\";\n              }\n\n              callback(err);\n            });\n          }\n\n          if (err) return callback(err);\n          var optionsOnly = item.options ? {\n            options: item.options\n          } : undefined;\n          return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));\n        });\n      }, callback);\n    }\n  }, {\n    key: \"getParser\",\n    value: function getParser(type, parserOptions) {\n      var ident = type;\n\n      if (parserOptions) {\n        if (parserOptions.ident) {\n          ident = \"\".concat(type, \"|\").concat(parserOptions.ident);\n        } else {\n          ident = JSON.stringify([type, parserOptions]);\n        }\n      }\n\n      if (ident in this.parserCache) {\n        return this.parserCache[ident];\n      }\n\n      return this.parserCache[ident] = this.createParser(type, parserOptions);\n    }\n  }, {\n    key: \"createParser\",\n    value: function createParser(type) {\n      var parserOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var parser = this.hooks.createParser.for(type).call(parserOptions);\n\n      if (!parser) {\n        throw new Error(\"No parser registered for \".concat(type));\n      }\n\n      this.hooks.parser.for(type).call(parser, parserOptions);\n      return parser;\n    }\n  }, {\n    key: \"getGenerator\",\n    value: function getGenerator(type, generatorOptions) {\n      var ident = type;\n\n      if (generatorOptions) {\n        if (generatorOptions.ident) {\n          ident = \"\".concat(type, \"|\").concat(generatorOptions.ident);\n        } else {\n          ident = JSON.stringify([type, generatorOptions]);\n        }\n      }\n\n      if (ident in this.generatorCache) {\n        return this.generatorCache[ident];\n      }\n\n      return this.generatorCache[ident] = this.createGenerator(type, generatorOptions);\n    }\n  }, {\n    key: \"createGenerator\",\n    value: function createGenerator(type) {\n      var generatorOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var generator = this.hooks.createGenerator.for(type).call(generatorOptions);\n\n      if (!generator) {\n        throw new Error(\"No generator registered for \".concat(type));\n      }\n\n      this.hooks.generator.for(type).call(generator, generatorOptions);\n      return generator;\n    }\n  }, {\n    key: \"getResolver\",\n    value: function getResolver(type, resolveOptions) {\n      return this.resolverFactory.get(type, resolveOptions || EMPTY_RESOLVE_OPTIONS);\n    }\n  }]);\n\n  return NormalModuleFactory;\n}(Tapable);\n\nmodule.exports = NormalModuleFactory;","map":null,"metadata":{},"sourceType":"script"}