{"ast":null,"code":"module.exports = ExtendedHeaderWriter;\n\nvar inherits = require(\"inherits\"),\n    EntryWriter = require(\"./entry-writer.js\");\n\ninherits(ExtendedHeaderWriter, EntryWriter);\n\nvar tar = require(\"../tar.js\"),\n    path = require(\"path\"),\n    TarHeader = require(\"./header.js\"); // props is the props of the thing we need to write an\n// extended header for.\n// Don't be shy with it.  Just encode everything.\n\n\nfunction ExtendedHeaderWriter(props) {\n  // console.error(\">> ehw ctor\")\n  var me = this;\n\n  if (!(me instanceof ExtendedHeaderWriter)) {\n    return new ExtendedHeaderWriter(props);\n  }\n\n  me.fields = props;\n  var p = {\n    path: (\"PaxHeader\" + path.join(\"/\", props.path || \"\")).replace(/\\\\/g, \"/\").substr(0, 100),\n    mode: props.mode || 0666,\n    uid: props.uid || 0,\n    gid: props.gid || 0,\n    size: 0 // will be set later\n    ,\n    mtime: props.mtime || Date.now() / 1000,\n    type: \"x\",\n    linkpath: \"\",\n    ustar: \"ustar\\0\",\n    ustarver: \"00\",\n    uname: props.uname || \"\",\n    gname: props.gname || \"\",\n    devmaj: props.devmaj || 0,\n    devmin: props.devmin || 0\n  };\n  EntryWriter.call(me, p); // console.error(\">> ehw props\", me.props)\n\n  me.props = p;\n  me._meta = true;\n}\n\nExtendedHeaderWriter.prototype.end = function () {\n  // console.error(\">> ehw end\")\n  var me = this;\n  if (me._ended) return;\n  me._ended = true;\n\n  me._encodeFields();\n\n  if (me.props.size === 0) {\n    // nothing to write!\n    me._ready = true;\n\n    me._stream.end();\n\n    return;\n  }\n\n  me._stream.write(TarHeader.encode(me.props));\n\n  me.body.forEach(function (l) {\n    me._stream.write(l);\n  });\n  me._ready = true; // console.error(\">> ehw _process calling end()\", me.props)\n\n  this._stream.end();\n};\n\nExtendedHeaderWriter.prototype._encodeFields = function () {\n  // console.error(\">> ehw _encodeFields\")\n  this.body = [];\n\n  if (this.fields.prefix) {\n    this.fields.path = this.fields.prefix + \"/\" + this.fields.path;\n    this.fields.prefix = \"\";\n  }\n\n  encodeFields(this.fields, \"\", this.body, this.fields.noProprietary);\n  var me = this;\n  this.body.forEach(function (l) {\n    me.props.size += l.length;\n  });\n};\n\nfunction encodeFields(fields, prefix, body, nop) {\n  // console.error(\">> >> ehw encodeFields\")\n  // \"%d %s=%s\\n\", <length>, <keyword>, <value>\n  // The length is a decimal number, and includes itself and the \\n\n  // Numeric values are decimal strings.\n  Object.keys(fields).forEach(function (k) {\n    var val = fields[k],\n        numeric = tar.numeric[k];\n    if (prefix) k = prefix + \".\" + k; // already including NODETAR.type, don't need File=true also\n\n    if (k === fields.type && val === true) return;\n\n    switch (k) {\n      // don't include anything that's always handled just fine\n      // in the normal header, or only meaningful in the context\n      // of nodetar\n      case \"mode\":\n      case \"cksum\":\n      case \"ustar\":\n      case \"ustarver\":\n      case \"prefix\":\n      case \"basename\":\n      case \"dirname\":\n      case \"needExtended\":\n      case \"block\":\n      case \"filter\":\n        return;\n\n      case \"rdev\":\n        if (val === 0) return;\n        break;\n\n      case \"nlink\":\n      case \"dev\": // Truly a hero among men, Creator of Star!\n\n      case \"ino\":\n        // Speak his name with reverent awe!  It is:\n        k = \"SCHILY.\" + k;\n        break;\n\n      default:\n        break;\n    }\n\n    if (val && typeof val === \"object\" && !Buffer.isBuffer(val)) encodeFields(val, k, body, nop);else if (val === null || val === undefined) return;else body.push.apply(body, encodeField(k, val, nop));\n  });\n  return body;\n}\n\nfunction encodeField(k, v, nop) {\n  // lowercase keys must be valid, otherwise prefix with\n  // \"NODETAR.\"\n  if (k.charAt(0) === k.charAt(0).toLowerCase()) {\n    var m = k.split(\".\")[0];\n    if (!tar.knownExtended[m]) k = \"NODETAR.\" + k;\n  } // no proprietary\n\n\n  if (nop && k.charAt(0) !== k.charAt(0).toLowerCase()) {\n    return [];\n  }\n\n  if (typeof val === \"number\") val = val.toString(10);\n  var s = new Buffer(\" \" + k + \"=\" + v + \"\\n\"),\n      digits = Math.floor(Math.log(s.length) / Math.log(10)) + 1; // console.error(\"1 s=%j digits=%j s.length=%d\", s.toString(), digits, s.length)\n  // if adding that many digits will make it go over that length,\n  // then add one to it. For example, if the string is:\n  // \" foo=bar\\n\"\n  // then that's 9 characters.  With the \"9\", that bumps the length\n  // up to 10.  However, this is invalid:\n  // \"10 foo=bar\\n\"\n  // but, since that's actually 11 characters, since 10 adds another\n  // character to the length, and the length includes the number\n  // itself.  In that case, just bump it up again.\n\n  if (s.length + digits >= Math.pow(10, digits)) digits += 1; // console.error(\"2 s=%j digits=%j s.length=%d\", s.toString(), digits, s.length)\n\n  var len = digits + s.length; // console.error(\"3 s=%j digits=%j s.length=%d len=%d\", s.toString(), digits, s.length, len)\n\n  var lenBuf = new Buffer(\"\" + len);\n\n  if (lenBuf.length + s.length !== len) {\n    throw new Error(\"Bad length calculation\\n\" + \"len=\" + len + \"\\n\" + \"lenBuf=\" + JSON.stringify(lenBuf.toString()) + \"\\n\" + \"lenBuf.length=\" + lenBuf.length + \"\\n\" + \"digits=\" + digits + \"\\n\" + \"s=\" + JSON.stringify(s.toString()) + \"\\n\" + \"s.length=\" + s.length);\n  }\n\n  return [lenBuf, s];\n}","map":null,"metadata":{},"sourceType":"script"}