{"ast":null,"code":"// pipe in an fstream, and it'll make a tarball.\n// key-value pair argument is global extended header props.\nmodule.exports = Pack;\n\nvar EntryWriter = require(\"./entry-writer.js\"),\n    Stream = require(\"stream\").Stream,\n    path = require(\"path\"),\n    inherits = require(\"inherits\"),\n    GlobalHeaderWriter = require(\"./global-header-writer.js\"),\n    collect = require(\"fstream\").collect,\n    eof = new Buffer(512);\n\nfor (var i = 0; i < 512; i++) {\n  eof[i] = 0;\n}\n\ninherits(Pack, Stream);\n\nfunction Pack(props) {\n  // console.error(\"-- p ctor\")\n  var me = this;\n  if (!(me instanceof Pack)) return new Pack(props);\n  if (props) me._noProprietary = props.noProprietary;else me._noProprietary = false;\n  me._global = props;\n  me.readable = true;\n  me.writable = true;\n  me._buffer = []; // console.error(\"-- -- set current to null in ctor\")\n\n  me._currentEntry = null;\n  me._processing = false;\n  me._pipeRoot = null;\n  me.on(\"pipe\", function (src) {\n    if (src.root === me._pipeRoot) return;\n    me._pipeRoot = src;\n    src.on(\"end\", function () {\n      me._pipeRoot = null;\n    });\n    me.add(src);\n  });\n}\n\nPack.prototype.addGlobal = function (props) {\n  // console.error(\"-- p addGlobal\")\n  if (this._didGlobal) return;\n  this._didGlobal = true;\n  var me = this;\n  GlobalHeaderWriter(props).on(\"data\", function (c) {\n    me.emit(\"data\", c);\n  }).end();\n};\n\nPack.prototype.add = function (stream) {\n  if (this._global && !this._didGlobal) this.addGlobal(this._global);\n  if (this._ended) return this.emit(\"error\", new Error(\"add after end\"));\n  collect(stream);\n\n  this._buffer.push(stream);\n\n  this._process();\n\n  this._needDrain = this._buffer.length > 0;\n  return !this._needDrain;\n};\n\nPack.prototype.pause = function () {\n  this._paused = true;\n  if (this._currentEntry) this._currentEntry.pause();\n  this.emit(\"pause\");\n};\n\nPack.prototype.resume = function () {\n  this._paused = false;\n  if (this._currentEntry) this._currentEntry.resume();\n  this.emit(\"resume\");\n\n  this._process();\n};\n\nPack.prototype.end = function () {\n  this._ended = true;\n\n  this._buffer.push(eof);\n\n  this._process();\n};\n\nPack.prototype._process = function () {\n  var me = this;\n\n  if (me._paused || me._processing) {\n    return;\n  }\n\n  var entry = me._buffer.shift();\n\n  if (!entry) {\n    if (me._needDrain) {\n      me.emit(\"drain\");\n    }\n\n    return;\n  }\n\n  if (entry.ready === false) {\n    // console.error(\"-- entry is not ready\", entry)\n    me._buffer.unshift(entry);\n\n    entry.on(\"ready\", function () {\n      // console.error(\"-- -- ready!\", entry)\n      me._process();\n    });\n    return;\n  }\n\n  me._processing = true;\n\n  if (entry === eof) {\n    // need 2 ending null blocks.\n    me.emit(\"data\", eof);\n    me.emit(\"data\", eof);\n    me.emit(\"end\");\n    me.emit(\"close\");\n    return;\n  } // Change the path to be relative to the root dir that was\n  // added to the tarball.\n  //\n  // XXX This should be more like how -C works, so you can\n  // explicitly set a root dir, and also explicitly set a pathname\n  // in the tarball to use.  That way we can skip a lot of extra\n  // work when resolving symlinks for bundled dependencies in npm.\n\n\n  var root = path.dirname((entry.root || entry).path);\n\n  if (me._global && me._global.fromBase && entry.root && entry.root.path) {\n    // user set 'fromBase: true' indicating tar root should be directory itself\n    root = entry.root.path;\n  }\n\n  var wprops = {};\n  Object.keys(entry.props || {}).forEach(function (k) {\n    wprops[k] = entry.props[k];\n  });\n  if (me._noProprietary) wprops.noProprietary = true;\n  wprops.path = path.relative(root, entry.path || ''); // actually not a matter of opinion or taste.\n\n  if (process.platform === \"win32\") {\n    wprops.path = wprops.path.replace(/\\\\/g, \"/\");\n  }\n\n  if (!wprops.type) wprops.type = 'Directory';\n\n  switch (wprops.type) {\n    // sockets not supported\n    case \"Socket\":\n      return;\n\n    case \"Directory\":\n      wprops.path += \"/\";\n      wprops.size = 0;\n      break;\n\n    case \"Link\":\n      var lp = path.resolve(path.dirname(entry.path), entry.linkpath);\n      wprops.linkpath = path.relative(root, lp) || \".\";\n      wprops.size = 0;\n      break;\n\n    case \"SymbolicLink\":\n      var lp = path.resolve(path.dirname(entry.path), entry.linkpath);\n      wprops.linkpath = path.relative(path.dirname(entry.path), lp) || \".\";\n      wprops.size = 0;\n      break;\n  } // console.error(\"-- new writer\", wprops)\n  // if (!wprops.type) {\n  //   // console.error(\"-- no type?\", entry.constructor.name, entry)\n  // }\n  // console.error(\"-- -- set current to new writer\", wprops.path)\n\n\n  var writer = me._currentEntry = EntryWriter(wprops);\n  writer.parent = me; // writer.on(\"end\", function () {\n  //   // console.error(\"-- -- writer end\", writer.path)\n  // })\n\n  writer.on(\"data\", function (c) {\n    me.emit(\"data\", c);\n  });\n  writer.on(\"header\", function () {\n    Buffer.prototype.toJSON = function () {\n      return this.toString().split(/\\0/).join(\".\");\n    }; // console.error(\"-- -- writer header %j\", writer.props)\n\n\n    if (writer.props.size === 0) nextEntry();\n  });\n  writer.on(\"close\", nextEntry);\n  var ended = false;\n\n  function nextEntry() {\n    if (ended) return;\n    ended = true; // console.error(\"-- -- writer close\", writer.path)\n    // console.error(\"-- -- set current to null\", wprops.path)\n\n    me._currentEntry = null;\n    me._processing = false;\n\n    me._process();\n  }\n\n  writer.on(\"error\", function (er) {\n    // console.error(\"-- -- writer error\", writer.path)\n    me.emit(\"error\", er);\n  }); // if it's the root, then there's no need to add its entries,\n  // or data, since they'll be added directly.\n\n  if (entry === me._pipeRoot) {\n    // console.error(\"-- is the root, don't auto-add\")\n    writer.add = null;\n  }\n\n  entry.pipe(writer);\n};\n\nPack.prototype.destroy = function () {};\n\nPack.prototype.write = function () {};","map":null,"metadata":{},"sourceType":"script"}