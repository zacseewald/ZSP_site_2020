{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\"; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nvar _toConsumableArray = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar acorn = require(\"acorn-dynamic-import\").default;\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    SyncBailHook = _require.SyncBailHook,\n    HookMap = _require.HookMap;\n\nvar util = require(\"util\");\n\nvar vm = require(\"vm\");\n\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nvar StackedSetMap = require(\"./util/StackedSetMap\");\n\nvar TrackingSet = require(\"./util/TrackingSet\");\n\nvar joinRanges = function joinRanges(startRange, endRange) {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\nvar defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 2019,\n  sourceType: \"module\",\n  onComment: null,\n  plugins: {\n    dynamicImport: true\n  }\n}; // regexp to match at lease one \"magic comment\"\n\nvar webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nvar EMPTY_ARRAY = [];\nvar EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nvar Parser =\n/*#__PURE__*/\nfunction (_Tapable) {\n  _inherits(Parser, _Tapable);\n\n  function Parser(options) {\n    var _this;\n\n    var sourceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n\n    _classCallCheck(this, Parser);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Parser).call(this));\n    _this.hooks = {\n      evaluateTypeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluate: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateDefinedIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateCallExpressionMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"param\"]);\n      }),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(function () {\n        return new SyncBailHook([\"statement\"]);\n      }),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationLet: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationConst: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationVar: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      canRename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      rename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      assigned: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      assign: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      typeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      callAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      new: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    var HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n\n    _this._pluginCompat.tap(\"Parser\", function (options) {\n      var _arr = Object.keys(HOOK_MAP_COMPAT_CONFIG);\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var name = _arr[_i];\n        var regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        var match = regexp.exec(options.name);\n\n        if (match) {\n          if (match[1]) {\n            _this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n          } else {\n            _this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_assertThisInitialized(_this))));\n          }\n\n          return true;\n        }\n      }\n    });\n\n    _this.options = options;\n    _this.sourceType = sourceType;\n    _this.scope = undefined;\n    _this.state = undefined;\n    _this.comments = undefined;\n\n    _this.initializeEvaluating();\n\n    return _this;\n  }\n\n  _createClass(Parser, [{\n    key: \"initializeEvaluating\",\n    value: function initializeEvaluating() {\n      var _this2 = this;\n\n      this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", function (expr) {\n        switch (typeof expr.value) {\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n        }\n\n        if (expr.value === null) {\n          return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n        }\n\n        if (expr.value instanceof RegExp) {\n          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var leftAsBool;\n        var right;\n\n        if (expr.operator === \"&&\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === false) return left.setRange(expr.range);\n          if (leftAsBool !== true) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        } else if (expr.operator === \"||\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === true) return left.setRange(expr.range);\n          if (leftAsBool !== false) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var right;\n        var res;\n\n        if (expr.operator === \"+\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n\n          if (left.isString()) {\n            if (right.isString()) {\n              res.setString(left.string + right.string);\n            } else if (right.isNumber()) {\n              res.setString(left.string + right.number);\n            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n              // \"left\" + (\"prefix\" + inner + \"postfix\")\n              // => (\"leftprefix\" + inner + \"postfix\")\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // \"left\" + ([null] + inner + \"postfix\")\n              // => (\"left\" + inner + \"postfix\")\n              res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n            } else {\n              // \"left\" + expr\n              // => (\"left\" + expr + \"\")\n              res.setWrapped(left, null, [right]);\n            }\n          } else if (left.isNumber()) {\n            if (right.isString()) {\n              res.setString(left.number + right.string);\n            } else if (right.isNumber()) {\n              res.setNumber(left.number + right.number);\n            } else {\n              return;\n            }\n          } else if (left.isWrapped()) {\n            if (left.postfix && left.postfix.isString() && right.isString()) {\n              // (\"prefix\" + inner + \"postfix\") + \"right\"\n              // => (\"prefix\" + inner + \"postfixright\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n              // (\"prefix\" + inner + \"postfix\") + 123\n              // => (\"prefix\" + inner + \"postfix123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (right.isString()) {\n              // (\"prefix\" + inner + [null]) + \"right\"\n              // => (\"prefix\" + inner + \"right\")\n              res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n            } else if (right.isNumber()) {\n              // (\"prefix\" + inner + [null]) + 123\n              // => (\"prefix\" + inner + \"123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n              // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n              res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n            } else {\n              // (\"prefix\" + inner + postfix) + expr\n              // => (\"prefix\" + inner + postfix + expr + [null])\n              res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n            }\n          } else {\n            if (right.isString()) {\n              // left + \"right\"\n              // => ([null] + left + \"right\")\n              res.setWrapped(null, right, [left]);\n            } else if (right.isWrapped()) {\n              // left + (prefix + inner + \"postfix\")\n              // => ([null] + left + prefix + inner + \"postfix\")\n              res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n            } else {\n              return;\n            }\n          }\n\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"-\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number - right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"*\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number * right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"/\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number / right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"**\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(Math.pow(left.number, right.number));\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string === right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number === right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool === right.bool);\n          }\n        } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string !== right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number !== right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool !== right.bool);\n          }\n        } else if (expr.operator === \"&\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number & right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"|\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number | right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"^\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number ^ right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >>> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"<<\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number << right.number);\n          res.setRange(expr.range);\n          return res;\n        }\n      });\n      this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", function (expr) {\n        if (expr.operator === \"typeof\") {\n          var res;\n          var name;\n\n          if (expr.argument.type === \"Identifier\") {\n            name = _this2.scope.renames.get(expr.argument.name) || expr.argument.name;\n\n            if (!_this2.scope.definitions.has(name)) {\n              var hook = _this2.hooks.evaluateTypeof.get(name);\n\n              if (hook !== undefined) {\n                res = hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n\n          if (expr.argument.type === \"MemberExpression\") {\n            var exprName = _this2.getNameForExpression(expr.argument);\n\n            if (exprName && exprName.free) {\n              var _hook = _this2.hooks.evaluateTypeof.get(exprName.name);\n\n              if (_hook !== undefined) {\n                res = _hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n\n          if (expr.argument.type === \"FunctionExpression\") {\n            return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n          }\n\n          var arg = _this2.evaluateExpression(expr.argument);\n\n          if (arg.isString() || arg.isWrapped()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n          }\n\n          if (arg.isNumber()) {\n            return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n          }\n\n          if (arg.isBoolean()) {\n            return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n          }\n\n          if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n          }\n        } else if (expr.operator === \"!\") {\n          var argument = _this2.evaluateExpression(expr.argument);\n\n          if (!argument) return;\n\n          if (argument.isBoolean()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n          }\n\n          if (argument.isTruthy()) {\n            return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n          }\n\n          if (argument.isFalsy()) {\n            return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n          }\n\n          if (argument.isString()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n          }\n\n          if (argument.isNumber()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n          }\n        } else if (expr.operator === \"~\") {\n          var _argument = _this2.evaluateExpression(expr.argument);\n\n          if (!_argument) return;\n          if (!_argument.isNumber()) return;\n\n          var _res = new BasicEvaluatedExpression();\n\n          _res.setNumber(~_argument.number);\n\n          _res.setRange(expr.range);\n\n          return _res;\n        }\n      });\n      this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", function (expr) {\n        return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(expr.name) || expr.name;\n\n        if (!_this2.scope.definitions.has(expr.name)) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        } else {\n          var _hook2 = _this2.hooks.evaluateDefinedIdentifier.get(name);\n\n          if (_hook2 !== undefined) {\n            return _hook2.call(expr);\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(\"this\");\n\n        if (name) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", function (expression) {\n        var exprName = _this2.getNameForExpression(expression);\n\n        if (exprName) {\n          if (exprName.free) {\n            var hook = _this2.hooks.evaluateIdentifier.get(exprName.name);\n\n            if (hook !== undefined) {\n              var result = hook.call(expression);\n              if (result) return result;\n            }\n\n            return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n          } else {\n            var _hook3 = _this2.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\n            if (_hook3 !== undefined) {\n              return _hook3.call(expression);\n            }\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", function (expr) {\n        if (expr.callee.type !== \"MemberExpression\") return;\n        if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n\n        var param = _this2.evaluateExpression(expr.callee.object);\n\n        if (!param) return;\n        var property = expr.callee.property.name || expr.callee.property.value;\n\n        var hook = _this2.hooks.evaluateCallExpressionMember.get(property);\n\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 2) return;\n\n        var arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n        var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n        if (!arg1.isString() && !arg1.isRegExp()) return;\n        arg1 = arg1.regExp || arg1.string;\n        if (!arg2.isString()) return;\n        arg2 = arg2.string;\n        return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n      });\n      [\"substr\", \"substring\"].forEach(function (fn) {\n        _this2.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", function (expr, param) {\n          if (!param.isString()) return;\n          var arg1;\n          var result,\n              str = param.string;\n\n          switch (expr.arguments.length) {\n            case 1:\n              arg1 = _this2.evaluateExpression(expr.arguments[0]);\n              if (!arg1.isNumber()) return;\n              result = str[fn](arg1.number);\n              break;\n\n            case 2:\n              {\n                arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n                var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n                if (!arg1.isNumber()) return;\n                if (!arg2.isNumber()) return;\n                result = str[fn](arg1.number, arg2.number);\n                break;\n              }\n\n            default:\n              return;\n          }\n\n          return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n        });\n      });\n      /**\n       * @param {string} kind \"cooked\" | \"raw\"\n       * @param {TODO} templateLiteralExpr TemplateLiteral expr\n       * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n       */\n\n      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, templateLiteralExpr) {\n        var quasis = [];\n        var parts = [];\n\n        for (var i = 0; i < templateLiteralExpr.quasis.length; i++) {\n          var quasiExpr = templateLiteralExpr.quasis[i];\n          var quasi = quasiExpr.value[kind];\n\n          if (i > 0) {\n            var prevExpr = parts[parts.length - 1];\n\n            var expr = _this2.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n\n            var exprAsString = expr.asString();\n\n            if (typeof exprAsString === \"string\") {\n              // We can merge quasi + expr + quasi when expr\n              // is a const string\n              prevExpr.setString(prevExpr.string + exprAsString + quasi);\n              prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n              prevExpr.setExpression(undefined);\n              continue;\n            }\n\n            parts.push(expr);\n          }\n\n          var part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n          quasis.push(part);\n          parts.push(part);\n        }\n\n        return {\n          quasis: quasis,\n          parts: parts\n        };\n      };\n\n      this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", function (node) {\n        var _getSimplifiedTemplat = getSimplifiedTemplateResult(\"cooked\", node),\n            quasis = _getSimplifiedTemplat.quasis,\n            parts = _getSimplifiedTemplat.parts;\n\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n      });\n      this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", function (node) {\n        if (_this2.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\n        var _getSimplifiedTemplat2 = getSimplifiedTemplateResult(\"raw\", node.quasi),\n            quasis = _getSimplifiedTemplat2.quasis,\n            parts = _getSimplifiedTemplat2.parts;\n\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString() && !param.isWrapped()) return;\n        var stringSuffix = null;\n        var hasUnknownParams = false;\n\n        for (var i = expr.arguments.length - 1; i >= 0; i--) {\n          var argExpr = _this2.evaluateExpression(expr.arguments[i]);\n\n          if (!argExpr.isString() && !argExpr.isNumber()) {\n            hasUnknownParams = true;\n            break;\n          }\n\n          var value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n          var newString = value + (stringSuffix ? stringSuffix.string : \"\");\n          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n          stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n        }\n\n        if (hasUnknownParams) {\n          var prefix = param.isString() ? param : param.prefix;\n          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n        } else if (param.isWrapped()) {\n          var postfix = stringSuffix || param.postfix;\n          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n        } else {\n          var _newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n\n          return new BasicEvaluatedExpression().setString(_newString).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 1) return;\n        var result;\n\n        var arg = _this2.evaluateExpression(expr.arguments[0]);\n\n        if (arg.isString()) {\n          result = param.string.split(arg.string);\n        } else if (arg.isRegExp()) {\n          result = param.string.split(arg.regExp);\n        } else {\n          return;\n        }\n\n        return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", function (expr) {\n        var condition = _this2.evaluateExpression(expr.test);\n\n        var conditionValue = condition.asBool();\n        var res;\n\n        if (conditionValue === undefined) {\n          var consequent = _this2.evaluateExpression(expr.consequent);\n\n          var alternate = _this2.evaluateExpression(expr.alternate);\n\n          if (!consequent || !alternate) return;\n          res = new BasicEvaluatedExpression();\n\n          if (consequent.isConditional()) {\n            res.setOptions(consequent.options);\n          } else {\n            res.setOptions([consequent]);\n          }\n\n          if (alternate.isConditional()) {\n            res.addOptions(alternate.options);\n          } else {\n            res.addOptions([alternate]);\n          }\n        } else {\n          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        }\n\n        res.setRange(expr.range);\n        return res;\n      });\n      this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", function (expr) {\n        var items = expr.elements.map(function (element) {\n          return element !== null && _this2.evaluateExpression(element);\n        });\n        if (!items.every(Boolean)) return;\n        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n      });\n    }\n  }, {\n    key: \"getRenameIdentifier\",\n    value: function getRenameIdentifier(expr) {\n      var result = this.evaluateExpression(expr);\n\n      if (result && result.isIdentifier()) {\n        return result.identifier;\n      }\n    }\n  }, {\n    key: \"walkClass\",\n    value: function walkClass(classy) {\n      if (classy.superClass) this.walkExpression(classy.superClass);\n\n      if (classy.body && classy.body.type === \"ClassBody\") {\n        var wasTopLevel = this.scope.topLevelScope;\n        this.scope.topLevelScope = false;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = classy.body.body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var methodDefinition = _step.value;\n\n            if (methodDefinition.type === \"MethodDefinition\") {\n              this.walkMethodDefinition(methodDefinition);\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        this.scope.topLevelScope = wasTopLevel;\n      }\n    }\n  }, {\n    key: \"walkMethodDefinition\",\n    value: function walkMethodDefinition(methodDefinition) {\n      if (methodDefinition.computed && methodDefinition.key) {\n        this.walkExpression(methodDefinition.key);\n      }\n\n      if (methodDefinition.value) {\n        this.walkExpression(methodDefinition.value);\n      }\n    } // Prewalking iterates the scope for variable declarations\n\n  }, {\n    key: \"prewalkStatements\",\n    value: function prewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.prewalkStatement(statement);\n      }\n    } // Walking iterates the statements and expressions and processes them\n\n  }, {\n    key: \"walkStatements\",\n    value: function walkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.walkStatement(statement);\n      }\n    }\n  }, {\n    key: \"prewalkStatement\",\n    value: function prewalkStatement(statement) {\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.prewalkBlockStatement(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.prewalkClassDeclaration(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.prewalkDoWhileStatement(statement);\n          break;\n\n        case \"ExportAllDeclaration\":\n          this.prewalkExportAllDeclaration(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.prewalkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.prewalkExportNamedDeclaration(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.prewalkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.prewalkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.prewalkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.prewalkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.prewalkIfStatement(statement);\n          break;\n\n        case \"ImportDeclaration\":\n          this.prewalkImportDeclaration(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.prewalkLabeledStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.prewalkSwitchStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.prewalkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.prewalkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.prewalkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.prewalkWithStatement(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"walkStatement\",\n    value: function walkStatement(statement) {\n      if (this.hooks.statement.call(statement) !== undefined) return;\n\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.walkBlockStatement(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.walkClassDeclaration(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.walkDoWhileStatement(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.walkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.walkExportNamedDeclaration(statement);\n          break;\n\n        case \"ExpressionStatement\":\n          this.walkExpressionStatement(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.walkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.walkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.walkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.walkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.walkIfStatement(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.walkLabeledStatement(statement);\n          break;\n\n        case \"ReturnStatement\":\n          this.walkReturnStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.walkSwitchStatement(statement);\n          break;\n\n        case \"ThrowStatement\":\n          this.walkThrowStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.walkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.walkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.walkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.walkWithStatement(statement);\n          break;\n      }\n    } // Real Statements\n\n  }, {\n    key: \"prewalkBlockStatement\",\n    value: function prewalkBlockStatement(statement) {\n      this.prewalkStatements(statement.body);\n    }\n  }, {\n    key: \"walkBlockStatement\",\n    value: function walkBlockStatement(statement) {\n      this.walkStatements(statement.body);\n    }\n  }, {\n    key: \"walkExpressionStatement\",\n    value: function walkExpressionStatement(statement) {\n      this.walkExpression(statement.expression);\n    }\n  }, {\n    key: \"prewalkIfStatement\",\n    value: function prewalkIfStatement(statement) {\n      this.prewalkStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.prewalkStatement(statement.alternate);\n      }\n    }\n  }, {\n    key: \"walkIfStatement\",\n    value: function walkIfStatement(statement) {\n      var result = this.hooks.statementIf.call(statement);\n\n      if (result === undefined) {\n        this.walkExpression(statement.test);\n        this.walkStatement(statement.consequent);\n\n        if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkStatement(statement.consequent);\n        } else if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"prewalkLabeledStatement\",\n    value: function prewalkLabeledStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkLabeledStatement\",\n    value: function walkLabeledStatement(statement) {\n      var hook = this.hooks.label.get(statement.label.name);\n\n      if (hook !== undefined) {\n        var result = hook.call(statement);\n        if (result === true) return;\n      }\n\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkWithStatement\",\n    value: function prewalkWithStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWithStatement\",\n    value: function walkWithStatement(statement) {\n      this.walkExpression(statement.object);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkSwitchStatement\",\n    value: function prewalkSwitchStatement(statement) {\n      this.prewalkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkSwitchStatement\",\n    value: function walkSwitchStatement(statement) {\n      this.walkExpression(statement.discriminant);\n      this.walkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkTerminatingStatement\",\n    value: function walkTerminatingStatement(statement) {\n      if (statement.argument) this.walkExpression(statement.argument);\n    }\n  }, {\n    key: \"walkReturnStatement\",\n    value: function walkReturnStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"walkThrowStatement\",\n    value: function walkThrowStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"prewalkTryStatement\",\n    value: function prewalkTryStatement(statement) {\n      this.prewalkStatement(statement.block);\n    }\n  }, {\n    key: \"walkTryStatement\",\n    value: function walkTryStatement(statement) {\n      if (this.scope.inTry) {\n        this.walkStatement(statement.block);\n      } else {\n        this.scope.inTry = true;\n        this.walkStatement(statement.block);\n        this.scope.inTry = false;\n      }\n\n      if (statement.handler) this.walkCatchClause(statement.handler);\n      if (statement.finalizer) this.walkStatement(statement.finalizer);\n    }\n  }, {\n    key: \"prewalkWhileStatement\",\n    value: function prewalkWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWhileStatement\",\n    value: function walkWhileStatement(statement) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkDoWhileStatement\",\n    value: function prewalkDoWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkDoWhileStatement\",\n    value: function walkDoWhileStatement(statement) {\n      this.walkStatement(statement.body);\n      this.walkExpression(statement.test);\n    }\n  }, {\n    key: \"prewalkForStatement\",\n    value: function prewalkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.prewalkStatement(statement.init);\n        }\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForStatement\",\n    value: function walkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkForInStatement\",\n    value: function prewalkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForInStatement\",\n    value: function walkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkForOfStatement\",\n    value: function prewalkForOfStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForOfStatement\",\n    value: function walkForOfStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      this.walkStatement(statement.body);\n    } // Declarations\n\n  }, {\n    key: \"prewalkFunctionDeclaration\",\n    value: function prewalkFunctionDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkFunctionDeclaration\",\n    value: function walkFunctionDeclaration(statement) {\n      var _this3 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inScope(statement.params, function () {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = statement.params[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var param = _step2.value;\n\n            _this3.walkPattern(param);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        if (statement.body.type === \"BlockStatement\") {\n          _this3.detectStrictMode(statement.body.body);\n\n          _this3.prewalkStatement(statement.body);\n\n          _this3.walkStatement(statement.body);\n        } else {\n          _this3.walkExpression(statement.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"prewalkImportDeclaration\",\n    value: function prewalkImportDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.import.call(statement, source);\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = statement.specifiers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var specifier = _step3.value;\n          var name = specifier.local.name;\n          this.scope.renames.set(name, null);\n          this.scope.definitions.add(name);\n\n          switch (specifier.type) {\n            case \"ImportDefaultSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, \"default\", name);\n              break;\n\n            case \"ImportSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n              break;\n\n            case \"ImportNamespaceSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, null, name);\n              break;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"prewalkExportNamedDeclaration\",\n    value: function prewalkExportNamedDeclaration(statement) {\n      var source;\n\n      if (statement.source) {\n        source = statement.source.value;\n        this.hooks.exportImport.call(statement, source);\n      } else {\n        this.hooks.export.call(statement);\n      }\n\n      if (statement.declaration) {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          var originalDefinitions = this.scope.definitions;\n          var tracker = new TrackingSet(this.scope.definitions);\n          this.scope.definitions = tracker;\n          this.prewalkStatement(statement.declaration);\n          var newDefs = Array.from(tracker.getAddedItems());\n          this.scope.definitions = originalDefinitions;\n\n          for (var index = newDefs.length - 1; index >= 0; index--) {\n            var def = newDefs[index];\n            this.hooks.exportSpecifier.call(statement, def, def, index);\n          }\n        }\n      }\n\n      if (statement.specifiers) {\n        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n          var specifier = statement.specifiers[specifierIndex];\n\n          switch (specifier.type) {\n            case \"ExportSpecifier\":\n              {\n                var name = specifier.exported.name;\n\n                if (source) {\n                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n                } else {\n                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n                }\n\n                break;\n              }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExportNamedDeclaration\",\n    value: function walkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.walkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportDefaultDeclaration\",\n    value: function prewalkExportDefaultDeclaration(statement) {\n      if (statement.declaration.id) {\n        var originalDefinitions = this.scope.definitions;\n        var tracker = new TrackingSet(this.scope.definitions);\n        this.scope.definitions = tracker;\n        this.prewalkStatement(statement.declaration);\n        var newDefs = Array.from(tracker.getAddedItems());\n        this.scope.definitions = originalDefinitions;\n\n        for (var index = 0, len = newDefs.length; index < len; index++) {\n          var def = newDefs[index];\n          this.hooks.exportSpecifier.call(statement, def, \"default\");\n        }\n      }\n    }\n  }, {\n    key: \"walkExportDefaultDeclaration\",\n    value: function walkExportDefaultDeclaration(statement) {\n      this.hooks.export.call(statement);\n\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.walkStatement(statement.declaration);\n        }\n      } else {\n        // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n        // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n        // These nodes must be treated as expressions.\n        if (statement.declaration.type === \"FunctionDeclaration\") {\n          this.walkFunctionDeclaration(statement.declaration);\n        } else if (statement.declaration.type === \"ClassDeclaration\") {\n          this.walkClassDeclaration(statement.declaration);\n        } else {\n          this.walkExpression(statement.declaration);\n        }\n\n        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n          this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n        }\n      }\n    }\n  }, {\n    key: \"prewalkExportAllDeclaration\",\n    value: function prewalkExportAllDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n      this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n    }\n  }, {\n    key: \"prewalkVariableDeclaration\",\n    value: function prewalkVariableDeclaration(statement) {\n      var _this4 = this;\n\n      var hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : statement.kind === \"let\" ? this.hooks.varDeclarationLet : this.hooks.varDeclarationVar;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = statement.declarations[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var declarator = _step4.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, function (name, decl) {\n                  var hook = hookMap.get(name);\n\n                  if (hook === undefined || !hook.call(decl)) {\n                    hook = _this4.hooks.varDeclaration.get(name);\n\n                    if (hook === undefined || !hook.call(decl)) {\n                      _this4.scope.renames.set(name, null);\n\n                      _this4.scope.definitions.add(name);\n                    }\n                  }\n                });\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkVariableDeclaration\",\n    value: function walkVariableDeclaration(statement) {\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = statement.declarations[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var declarator = _step5.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n                if (renameIdentifier && declarator.id.type === \"Identifier\") {\n                  var hook = this.hooks.canRename.get(renameIdentifier);\n\n                  if (hook !== undefined && hook.call(declarator.init)) {\n                    // renaming with \"var a = b;\"\n                    var _hook4 = this.hooks.rename.get(renameIdentifier);\n\n                    if (_hook4 === undefined || !_hook4.call(declarator.init)) {\n                      this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                      this.scope.definitions.delete(declarator.id.name);\n                    }\n\n                    break;\n                  }\n                }\n\n                this.walkPattern(declarator.id);\n                if (declarator.init) this.walkExpression(declarator.init);\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"prewalkClassDeclaration\",\n    value: function prewalkClassDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkClassDeclaration\",\n    value: function walkClassDeclaration(statement) {\n      this.walkClass(statement);\n    }\n  }, {\n    key: \"prewalkSwitchCases\",\n    value: function prewalkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        this.prewalkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkSwitchCases\",\n    value: function walkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n\n        this.walkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkCatchClause\",\n    value: function walkCatchClause(catchClause) {\n      var _this5 = this;\n\n      // Error binding is optional in catch clause since ECMAScript 2019\n      var errorBinding = catchClause.param === null ? EMPTY_ARRAY : [catchClause.param];\n      this.inScope(errorBinding, function () {\n        _this5.prewalkStatement(catchClause.body);\n\n        _this5.walkStatement(catchClause.body);\n      });\n    }\n  }, {\n    key: \"walkPattern\",\n    value: function walkPattern(pattern) {\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.walkArrayPattern(pattern);\n          break;\n\n        case \"AssignmentPattern\":\n          this.walkAssignmentPattern(pattern);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(pattern);\n          break;\n\n        case \"ObjectPattern\":\n          this.walkObjectPattern(pattern);\n          break;\n\n        case \"RestElement\":\n          this.walkRestElement(pattern);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAssignmentPattern\",\n    value: function walkAssignmentPattern(pattern) {\n      this.walkExpression(pattern.right);\n      this.walkPattern(pattern.left);\n    }\n  }, {\n    key: \"walkObjectPattern\",\n    value: function walkObjectPattern(pattern) {\n      for (var i = 0, len = pattern.properties.length; i < len; i++) {\n        var prop = pattern.properties[i];\n\n        if (prop) {\n          if (prop.computed) this.walkExpression(prop.key);\n          if (prop.value) this.walkPattern(prop.value);\n        }\n      }\n    }\n  }, {\n    key: \"walkArrayPattern\",\n    value: function walkArrayPattern(pattern) {\n      for (var i = 0, len = pattern.elements.length; i < len; i++) {\n        var element = pattern.elements[i];\n        if (element) this.walkPattern(element);\n      }\n    }\n  }, {\n    key: \"walkRestElement\",\n    value: function walkRestElement(pattern) {\n      this.walkPattern(pattern.argument);\n    }\n  }, {\n    key: \"walkExpressions\",\n    value: function walkExpressions(expressions) {\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = expressions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var expression = _step6.value;\n\n          if (expression) {\n            this.walkExpression(expression);\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExpression\",\n    value: function walkExpression(expression) {\n      switch (expression.type) {\n        case \"ArrayExpression\":\n          this.walkArrayExpression(expression);\n          break;\n\n        case \"ArrowFunctionExpression\":\n          this.walkArrowFunctionExpression(expression);\n          break;\n\n        case \"AssignmentExpression\":\n          this.walkAssignmentExpression(expression);\n          break;\n\n        case \"AwaitExpression\":\n          this.walkAwaitExpression(expression);\n          break;\n\n        case \"BinaryExpression\":\n          this.walkBinaryExpression(expression);\n          break;\n\n        case \"CallExpression\":\n          this.walkCallExpression(expression);\n          break;\n\n        case \"ClassExpression\":\n          this.walkClassExpression(expression);\n          break;\n\n        case \"ConditionalExpression\":\n          this.walkConditionalExpression(expression);\n          break;\n\n        case \"FunctionExpression\":\n          this.walkFunctionExpression(expression);\n          break;\n\n        case \"Identifier\":\n          this.walkIdentifier(expression);\n          break;\n\n        case \"LogicalExpression\":\n          this.walkLogicalExpression(expression);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(expression);\n          break;\n\n        case \"NewExpression\":\n          this.walkNewExpression(expression);\n          break;\n\n        case \"ObjectExpression\":\n          this.walkObjectExpression(expression);\n          break;\n\n        case \"SequenceExpression\":\n          this.walkSequenceExpression(expression);\n          break;\n\n        case \"SpreadElement\":\n          this.walkSpreadElement(expression);\n          break;\n\n        case \"TaggedTemplateExpression\":\n          this.walkTaggedTemplateExpression(expression);\n          break;\n\n        case \"TemplateLiteral\":\n          this.walkTemplateLiteral(expression);\n          break;\n\n        case \"ThisExpression\":\n          this.walkThisExpression(expression);\n          break;\n\n        case \"UnaryExpression\":\n          this.walkUnaryExpression(expression);\n          break;\n\n        case \"UpdateExpression\":\n          this.walkUpdateExpression(expression);\n          break;\n\n        case \"YieldExpression\":\n          this.walkYieldExpression(expression);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAwaitExpression\",\n    value: function walkAwaitExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkArrayExpression\",\n    value: function walkArrayExpression(expression) {\n      if (expression.elements) {\n        this.walkExpressions(expression.elements);\n      }\n    }\n  }, {\n    key: \"walkSpreadElement\",\n    value: function walkSpreadElement(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkObjectExpression\",\n    value: function walkObjectExpression(expression) {\n      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n        var prop = expression.properties[propIndex];\n\n        if (prop.type === \"SpreadElement\") {\n          this.walkExpression(prop.argument);\n          continue;\n        }\n\n        if (prop.computed) {\n          this.walkExpression(prop.key);\n        }\n\n        if (prop.shorthand) {\n          this.scope.inShorthand = true;\n        }\n\n        this.walkExpression(prop.value);\n\n        if (prop.shorthand) {\n          this.scope.inShorthand = false;\n        }\n      }\n    }\n  }, {\n    key: \"walkFunctionExpression\",\n    value: function walkFunctionExpression(expression) {\n      var _this6 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inScope(expression.params, function () {\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = expression.params[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var param = _step7.value;\n\n            _this6.walkPattern(param);\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this6.detectStrictMode(expression.body.body);\n\n          _this6.prewalkStatement(expression.body);\n\n          _this6.walkStatement(expression.body);\n        } else {\n          _this6.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkArrowFunctionExpression\",\n    value: function walkArrowFunctionExpression(expression) {\n      var _this7 = this;\n\n      this.inScope(expression.params, function () {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = expression.params[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var param = _step8.value;\n\n            _this7.walkPattern(param);\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this7.detectStrictMode(expression.body.body);\n\n          _this7.prewalkStatement(expression.body);\n\n          _this7.walkStatement(expression.body);\n        } else {\n          _this7.walkExpression(expression.body);\n        }\n      });\n    }\n  }, {\n    key: \"walkSequenceExpression\",\n    value: function walkSequenceExpression(expression) {\n      if (expression.expressions) this.walkExpressions(expression.expressions);\n    }\n  }, {\n    key: \"walkUpdateExpression\",\n    value: function walkUpdateExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkUnaryExpression\",\n    value: function walkUnaryExpression(expression) {\n      if (expression.operator === \"typeof\") {\n        var exprName = this.getNameForExpression(expression.argument);\n\n        if (exprName && exprName.free) {\n          var hook = this.hooks.typeof.get(exprName.name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkLeftRightExpression\",\n    value: function walkLeftRightExpression(expression) {\n      this.walkExpression(expression.left);\n      this.walkExpression(expression.right);\n    }\n  }, {\n    key: \"walkBinaryExpression\",\n    value: function walkBinaryExpression(expression) {\n      this.walkLeftRightExpression(expression);\n    }\n  }, {\n    key: \"walkLogicalExpression\",\n    value: function walkLogicalExpression(expression) {\n      var result = this.hooks.expressionLogicalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkLeftRightExpression(expression);\n      } else {\n        if (result) {\n          this.walkExpression(expression.right);\n        }\n      }\n    }\n  }, {\n    key: \"walkAssignmentExpression\",\n    value: function walkAssignmentExpression(expression) {\n      var _this8 = this;\n\n      var renameIdentifier = this.getRenameIdentifier(expression.right);\n\n      if (expression.left.type === \"Identifier\" && renameIdentifier) {\n        var hook = this.hooks.canRename.get(renameIdentifier);\n\n        if (hook !== undefined && hook.call(expression.right)) {\n          // renaming \"a = b;\"\n          var _hook5 = this.hooks.rename.get(renameIdentifier);\n\n          if (_hook5 === undefined || !_hook5.call(expression.right)) {\n            this.scope.renames.set(expression.left.name, renameIdentifier);\n            this.scope.definitions.delete(expression.left.name);\n          }\n\n          return;\n        }\n      }\n\n      if (expression.left.type === \"Identifier\") {\n        var assignedHook = this.hooks.assigned.get(expression.left.name);\n\n        if (assignedHook === undefined || !assignedHook.call(expression)) {\n          this.walkExpression(expression.right);\n        }\n\n        this.scope.renames.set(expression.left.name, null);\n        var assignHook = this.hooks.assign.get(expression.left.name);\n\n        if (assignHook === undefined || !assignHook.call(expression)) {\n          this.walkExpression(expression.left);\n        }\n\n        return;\n      }\n\n      this.walkExpression(expression.right);\n      this.walkPattern(expression.left);\n      this.enterPattern(expression.left, function (name, decl) {\n        _this8.scope.renames.set(name, null);\n      });\n    }\n  }, {\n    key: \"walkConditionalExpression\",\n    value: function walkConditionalExpression(expression) {\n      var result = this.hooks.expressionConditionalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkExpression(expression.test);\n        this.walkExpression(expression.consequent);\n\n        if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkExpression(expression.consequent);\n        } else if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"walkNewExpression\",\n    value: function walkNewExpression(expression) {\n      var callee = this.evaluateExpression(expression.callee);\n\n      if (callee.isIdentifier()) {\n        var hook = this.hooks.new.get(callee.identifier);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n\n          if (result === true) {\n            return;\n          }\n        }\n      }\n\n      this.walkExpression(expression.callee);\n\n      if (expression.arguments) {\n        this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkYieldExpression\",\n    value: function walkYieldExpression(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkTemplateLiteral\",\n    value: function walkTemplateLiteral(expression) {\n      if (expression.expressions) {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkTaggedTemplateExpression\",\n    value: function walkTaggedTemplateExpression(expression) {\n      if (expression.tag) {\n        this.walkExpression(expression.tag);\n      }\n\n      if (expression.quasi && expression.quasi.expressions) {\n        this.walkExpressions(expression.quasi.expressions);\n      }\n    }\n  }, {\n    key: \"walkClassExpression\",\n    value: function walkClassExpression(expression) {\n      this.walkClass(expression);\n    }\n  }, {\n    key: \"_walkIIFE\",\n    value: function _walkIIFE(functionExpression, options, currentThis) {\n      var _this9 = this;\n\n      var renameArgOrThis = function renameArgOrThis(argOrThis) {\n        var renameIdentifier = _this9.getRenameIdentifier(argOrThis);\n\n        if (renameIdentifier) {\n          var hook = _this9.hooks.canRename.get(renameIdentifier);\n\n          if (hook !== undefined && hook.call(argOrThis)) {\n            var _hook6 = _this9.hooks.rename.get(renameIdentifier);\n\n            if (_hook6 === undefined || !_hook6.call(argOrThis)) {\n              return renameIdentifier;\n            }\n          }\n        }\n\n        _this9.walkExpression(argOrThis);\n      };\n\n      var params = functionExpression.params;\n      var renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n      var args = options.map(renameArgOrThis);\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inScope(params.filter(function (identifier, idx) {\n        return !args[idx];\n      }), function () {\n        if (renameThis) {\n          _this9.scope.renames.set(\"this\", renameThis);\n        }\n\n        for (var i = 0; i < args.length; i++) {\n          var param = args[i];\n          if (!param) continue;\n          if (!params[i] || params[i].type !== \"Identifier\") continue;\n\n          _this9.scope.renames.set(params[i].name, param);\n        }\n\n        if (functionExpression.body.type === \"BlockStatement\") {\n          _this9.prewalkStatement(functionExpression.body);\n\n          _this9.walkStatement(functionExpression.body);\n        } else {\n          _this9.walkExpression(functionExpression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkCallExpression\",\n    value: function walkCallExpression(expression) {\n      if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n        // (function() { }.call/bind(?, ))\n        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n      } else if (expression.callee.type === \"FunctionExpression\") {\n        // (function() { }())\n        this._walkIIFE(expression.callee, expression.arguments, null);\n      } else if (expression.callee.type === \"Import\") {\n        var result = this.hooks.importCall.call(expression);\n        if (result === true) return;\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      } else {\n        var callee = this.evaluateExpression(expression.callee);\n\n        if (callee.isIdentifier()) {\n          var callHook = this.hooks.call.get(callee.identifier);\n\n          if (callHook !== undefined) {\n            var _result = callHook.call(expression);\n\n            if (_result === true) return;\n          }\n\n          var identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\n          if (identifier !== callee.identifier) {\n            var callAnyHook = this.hooks.callAnyMember.get(identifier);\n\n            if (callAnyHook !== undefined) {\n              var _result2 = callAnyHook.call(expression);\n\n              if (_result2 === true) return;\n            }\n          }\n        }\n\n        if (expression.callee) this.walkExpression(expression.callee);\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkMemberExpression\",\n    value: function walkMemberExpression(expression) {\n      var exprName = this.getNameForExpression(expression);\n\n      if (exprName && exprName.free) {\n        var expressionHook = this.hooks.expression.get(exprName.name);\n\n        if (expressionHook !== undefined) {\n          var result = expressionHook.call(expression);\n          if (result === true) return;\n        }\n\n        var expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n\n        if (expressionAnyMemberHook !== undefined) {\n          var _result3 = expressionAnyMemberHook.call(expression);\n\n          if (_result3 === true) return;\n        }\n      }\n\n      this.walkExpression(expression.object);\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkThisExpression\",\n    value: function walkThisExpression(expression) {\n      var expressionHook = this.hooks.expression.get(\"this\");\n\n      if (expressionHook !== undefined) {\n        expressionHook.call(expression);\n      }\n    }\n  }, {\n    key: \"walkIdentifier\",\n    value: function walkIdentifier(expression) {\n      if (!this.scope.definitions.has(expression.name)) {\n        var hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n  }, {\n    key: \"inScope\",\n    value: function inScope(params, fn) {\n      var _this10 = this;\n\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      this.scope.renames.set(\"this\", null);\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = params[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var param = _step9.value;\n\n          if (typeof param !== \"string\") {\n            this.enterPattern(param, function (param) {\n              _this10.scope.renames.set(param, null);\n\n              _this10.scope.definitions.add(param);\n            });\n          } else if (param) {\n            this.scope.renames.set(param, null);\n            this.scope.definitions.add(param);\n          }\n        }\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"detectStrictMode\",\n    value: function detectStrictMode(statements) {\n      var isStrict = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\" && statements[0].expression.value === \"use strict\";\n\n      if (isStrict) {\n        this.scope.isStrict = true;\n      }\n    }\n  }, {\n    key: \"enterPattern\",\n    value: function enterPattern(pattern, onIdent) {\n      if (!pattern) return;\n\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.enterArrayPattern(pattern, onIdent);\n          break;\n\n        case \"AssignmentPattern\":\n          this.enterAssignmentPattern(pattern, onIdent);\n          break;\n\n        case \"Identifier\":\n          this.enterIdentifier(pattern, onIdent);\n          break;\n\n        case \"ObjectPattern\":\n          this.enterObjectPattern(pattern, onIdent);\n          break;\n\n        case \"RestElement\":\n          this.enterRestElement(pattern, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"enterIdentifier\",\n    value: function enterIdentifier(pattern, onIdent) {\n      onIdent(pattern.name, pattern);\n    }\n  }, {\n    key: \"enterObjectPattern\",\n    value: function enterObjectPattern(pattern, onIdent) {\n      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n        var prop = pattern.properties[propIndex];\n        this.enterPattern(prop.value, onIdent);\n      }\n    }\n  }, {\n    key: \"enterArrayPattern\",\n    value: function enterArrayPattern(pattern, onIdent) {\n      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n        var element = pattern.elements[elementIndex];\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }, {\n    key: \"enterRestElement\",\n    value: function enterRestElement(pattern, onIdent) {\n      this.enterPattern(pattern.argument, onIdent);\n    }\n  }, {\n    key: \"enterAssignmentPattern\",\n    value: function enterAssignmentPattern(pattern, onIdent) {\n      this.enterPattern(pattern.left, onIdent);\n    }\n  }, {\n    key: \"evaluateExpression\",\n    value: function evaluateExpression(expression) {\n      try {\n        var hook = this.hooks.evaluate.get(expression.type);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n\n          if (result !== undefined) {\n            if (result) {\n              result.setExpression(expression);\n            }\n\n            return result;\n          }\n        }\n      } catch (e) {\n        console.warn(e); // ignore error\n      }\n\n      return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            return this.parseString(expression.left) + this.parseString(expression.right);\n          }\n\n          break;\n\n        case \"Literal\":\n          return expression.value + \"\";\n      }\n\n      throw new Error(expression.type + \" is not supported as parameter for require\");\n    }\n  }, {\n    key: \"parseCalculatedString\",\n    value: function parseCalculatedString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            var left = this.parseCalculatedString(expression.left);\n            var right = this.parseCalculatedString(expression.right);\n\n            if (left.code) {\n              return {\n                range: left.range,\n                value: left.value,\n                code: true,\n                conditional: false\n              };\n            } else if (right.code) {\n              return {\n                range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n                value: left.value + right.value,\n                code: true,\n                conditional: false\n              };\n            } else {\n              return {\n                range: [left.range[0], right.range[1]],\n                value: left.value + right.value,\n                code: false,\n                conditional: false\n              };\n            }\n          }\n\n          break;\n\n        case \"ConditionalExpression\":\n          {\n            var consequent = this.parseCalculatedString(expression.consequent);\n            var alternate = this.parseCalculatedString(expression.alternate);\n            var items = [];\n\n            if (consequent.conditional) {\n              items.push.apply(items, _toConsumableArray(consequent.conditional));\n            } else if (!consequent.code) {\n              items.push(consequent);\n            } else {\n              break;\n            }\n\n            if (alternate.conditional) {\n              items.push.apply(items, _toConsumableArray(alternate.conditional));\n            } else if (!alternate.code) {\n              items.push(alternate);\n            } else {\n              break;\n            }\n\n            return {\n              range: undefined,\n              value: \"\",\n              code: true,\n              conditional: items\n            };\n          }\n\n        case \"Literal\":\n          return {\n            range: expression.range,\n            value: expression.value + \"\",\n            code: false,\n            conditional: false\n          };\n      }\n\n      return {\n        range: undefined,\n        value: \"\",\n        code: true,\n        conditional: false\n      };\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(source, initialState) {\n      var ast;\n      var comments;\n\n      if (typeof source === \"object\" && source !== null) {\n        ast = source;\n        comments = source.comments;\n      } else {\n        comments = [];\n        ast = Parser.parse(source, {\n          sourceType: this.sourceType,\n          onComment: comments\n        });\n      }\n\n      var oldScope = this.scope;\n      var oldState = this.state;\n      var oldComments = this.comments;\n      this.scope = {\n        topLevelScope: true,\n        inTry: false,\n        inShorthand: false,\n        isStrict: false,\n        definitions: new StackedSetMap(),\n        renames: new StackedSetMap()\n      };\n      var state = this.state = initialState || {};\n      this.comments = comments;\n\n      if (this.hooks.program.call(ast, comments) === undefined) {\n        this.detectStrictMode(ast.body);\n        this.prewalkStatements(ast.body);\n        this.walkStatements(ast.body);\n      }\n\n      this.scope = oldScope;\n      this.state = oldState;\n      this.comments = oldComments;\n      return state;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(source) {\n      var ast = Parser.parse(\"(\" + source + \")\", {\n        sourceType: this.sourceType,\n        locations: false\n      });\n\n      if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n        throw new Error(\"evaluate: Source is not a expression\");\n      }\n\n      return this.evaluateExpression(ast.body[0].expression);\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments(range) {\n      return this.comments.filter(function (comment) {\n        return comment.range[0] >= range[0] && comment.range[1] <= range[1];\n      });\n    }\n  }, {\n    key: \"parseCommentOptions\",\n    value: function parseCommentOptions(range) {\n      var comments = this.getComments(range);\n\n      if (comments.length === 0) {\n        return EMPTY_COMMENT_OPTIONS;\n      }\n\n      var options = {};\n      var errors = [];\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = comments[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var comment = _step10.value;\n          var value = comment.value;\n\n          if (value && webpackCommentRegExp.test(value)) {\n            // try compile only if webpack options comment is present\n            try {\n              var val = vm.runInNewContext(\"(function(){return {\".concat(value, \"};})()\"));\n              Object.assign(options, val);\n            } catch (e) {\n              e.comment = comment;\n              errors.push(e);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n\n      return {\n        options: options,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"getNameForExpression\",\n    value: function getNameForExpression(expression) {\n      var expr = expression;\n      var exprName = [];\n\n      while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n        exprName.push(expr.computed ? expr.property.value : expr.property.name);\n        expr = expr.object;\n      }\n\n      var free;\n\n      if (expr.type === \"Identifier\") {\n        free = !this.scope.definitions.has(expr.name);\n        exprName.push(this.scope.renames.get(expr.name) || expr.name);\n      } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n        free = true;\n        exprName.push(this.scope.renames.get(\"this\"));\n      } else if (expr.type === \"ThisExpression\") {\n        free = this.scope.topLevelScope;\n        exprName.push(\"this\");\n      } else {\n        return null;\n      }\n\n      var prefix = \"\";\n\n      for (var i = exprName.length - 1; i >= 2; i--) {\n        prefix += exprName[i] + \".\";\n      }\n\n      if (exprName.length > 1) {\n        prefix += exprName[1];\n      }\n\n      var name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n      var nameGeneral = prefix;\n      return {\n        name: name,\n        nameGeneral: nameGeneral,\n        free: free\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(code, options) {\n      var type = options ? options.sourceType : \"module\";\n      var parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n\n      if (type === \"auto\") {\n        parserOptions.sourceType = \"module\";\n      }\n\n      var ast;\n      var error;\n      var threw = false;\n\n      try {\n        ast = acorn.parse(code, parserOptions);\n      } catch (e) {\n        error = e;\n        threw = true;\n      }\n\n      if (threw && type === \"auto\") {\n        parserOptions.sourceType = \"script\";\n\n        if (Array.isArray(parserOptions.onComment)) {\n          parserOptions.onComment.length = 0;\n        }\n\n        try {\n          ast = acorn.parse(code, parserOptions);\n          threw = false;\n        } catch (e) {\n          threw = true;\n        }\n      }\n\n      if (threw) {\n        throw error;\n      }\n\n      return ast;\n    }\n  }]);\n\n  return Parser;\n}(Tapable); // TODO remove in webpack 5\n\n\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}