{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar util = require(\"util\");\n\nvar _require = require(\"webpack-sources\"),\n    OriginalSource = _require.OriginalSource,\n    RawSource = _require.RawSource;\n\nvar Module = require(\"./Module\");\n\nvar AsyncDependenciesBlock = require(\"./AsyncDependenciesBlock\");\n\nvar Template = require(\"./Template\");\n\nvar contextify = require(\"./util/identifier\").contextify;\n/** @typedef {\"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"} ContextMode Context mode */\n\n/** @typedef {import(\"./dependencies/ContextElementDependency\")} ContextElementDependency */\n\n/**\n * @callback ResolveDependenciesCallback\n * @param {Error=} err\n * @param {ContextElementDependency[]} dependencies\n */\n\n/**\n * @callback ResolveDependencies\n * @param {TODO} fs\n * @param {TODO} options\n * @param {ResolveDependenciesCallback} callback\n */\n\n\nvar ContextModule =\n/*#__PURE__*/\nfunction (_Module) {\n  _inherits(ContextModule, _Module);\n\n  // type ContextMode = \"sync\" | \"eager\" | \"weak\" | \"async-weak\" | \"lazy\" | \"lazy-once\"\n  // type ContextOptions = { resource: string, recursive: boolean, regExp: RegExp, addon?: string, mode?: ContextMode, chunkName?: string, include?: RegExp, exclude?: RegExp, groupOptions?: Object }\n  // resolveDependencies: (fs: FS, options: ContextOptions, (err: Error?, dependencies: Dependency[]) => void) => void\n  // options: ContextOptions\n\n  /**\n   * @param {ResolveDependencies} resolveDependencies function to get dependencies in this context\n   * @param {TODO} options options object\n   */\n  function ContextModule(resolveDependencies, options) {\n    var _this;\n\n    _classCallCheck(this, ContextModule);\n\n    var resource;\n    var resourceQuery;\n    var queryIdx = options.resource.indexOf(\"?\");\n\n    if (queryIdx >= 0) {\n      resource = options.resource.substr(0, queryIdx);\n      resourceQuery = options.resource.substr(queryIdx);\n    } else {\n      resource = options.resource;\n      resourceQuery = \"\";\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ContextModule).call(this, \"javascript/dynamic\", resource)); // Info from Factory\n\n    _this.resolveDependencies = resolveDependencies;\n    _this.options = Object.assign({}, options, {\n      resource: resource,\n      resourceQuery: resourceQuery\n    });\n\n    if (options.resolveOptions !== undefined) {\n      _this.resolveOptions = options.resolveOptions;\n    } // Info from Build\n\n\n    _this._contextDependencies = new Set([_this.context]);\n\n    if (typeof options.mode !== \"string\") {\n      throw new Error(\"options.mode is a required option\");\n    }\n\n    _this._identifier = _this._createIdentifier();\n    return _this;\n  }\n\n  _createClass(ContextModule, [{\n    key: \"updateCacheModule\",\n    value: function updateCacheModule(module) {\n      this.resolveDependencies = module.resolveDependencies;\n      this.options = module.options;\n      this.resolveOptions = module.resolveOptions;\n    }\n  }, {\n    key: \"prettyRegExp\",\n    value: function prettyRegExp(regexString) {\n      // remove the \"/\" at the front and the beginning\n      // \"/foo/\" -> \"foo\"\n      return regexString.substring(1, regexString.length - 1);\n    }\n  }, {\n    key: \"_createIdentifier\",\n    value: function _createIdentifier() {\n      var identifier = this.context;\n\n      if (this.options.resourceQuery) {\n        identifier += \" \".concat(this.options.resourceQuery);\n      }\n\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n\n      if (!this.options.recursive) {\n        identifier += \" nonrecursive\";\n      }\n\n      if (this.options.addon) {\n        identifier += \" \".concat(this.options.addon);\n      }\n\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.options.regExp);\n      }\n\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.options.include);\n      }\n\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.options.exclude);\n      }\n\n      if (this.options.groupOptions) {\n        identifier += \" groupOptions: \".concat(JSON.stringify(this.options.groupOptions));\n      }\n\n      if (this.options.namespaceObject === \"strict\") {\n        identifier += \" strict namespace object\";\n      } else if (this.options.namespaceObject) {\n        identifier += \" namespace object\";\n      }\n\n      return identifier;\n    }\n  }, {\n    key: \"identifier\",\n    value: function identifier() {\n      return this._identifier;\n    }\n  }, {\n    key: \"readableIdentifier\",\n    value: function readableIdentifier(requestShortener) {\n      var identifier = requestShortener.shorten(this.context);\n\n      if (this.options.resourceQuery) {\n        identifier += \" \".concat(this.options.resourceQuery);\n      }\n\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n\n      if (!this.options.recursive) {\n        identifier += \" nonrecursive\";\n      }\n\n      if (this.options.addon) {\n        identifier += \" \".concat(requestShortener.shorten(this.options.addon));\n      }\n\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n      }\n\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n      }\n\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n      }\n\n      if (this.options.groupOptions) {\n        var groupOptions = this.options.groupOptions;\n\n        var _arr = Object.keys(groupOptions);\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var key = _arr[_i];\n          identifier += \" \".concat(key, \": \").concat(groupOptions[key]);\n        }\n      }\n\n      if (this.options.namespaceObject === \"strict\") {\n        identifier += \" strict namespace object\";\n      } else if (this.options.namespaceObject) {\n        identifier += \" namespace object\";\n      }\n\n      return identifier;\n    }\n  }, {\n    key: \"libIdent\",\n    value: function libIdent(options) {\n      var identifier = contextify(options.context, this.context);\n\n      if (this.options.mode) {\n        identifier += \" \".concat(this.options.mode);\n      }\n\n      if (this.options.recursive) {\n        identifier += \" recursive\";\n      }\n\n      if (this.options.addon) {\n        identifier += \" \".concat(contextify(options.context, this.options.addon));\n      }\n\n      if (this.options.regExp) {\n        identifier += \" \".concat(this.prettyRegExp(this.options.regExp + \"\"));\n      }\n\n      if (this.options.include) {\n        identifier += \" include: \".concat(this.prettyRegExp(this.options.include + \"\"));\n      }\n\n      if (this.options.exclude) {\n        identifier += \" exclude: \".concat(this.prettyRegExp(this.options.exclude + \"\"));\n      }\n\n      return identifier;\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      var ts = contextTimestamps.get(this.context);\n\n      if (!ts) {\n        return true;\n      }\n\n      return ts >= this.buildInfo.builtTime;\n    }\n  }, {\n    key: \"build\",\n    value: function build(options, compilation, resolver, fs, callback) {\n      var _this2 = this;\n\n      this.built = true;\n      this.buildMeta = {};\n      this.buildInfo = {\n        builtTime: Date.now(),\n        contextDependencies: this._contextDependencies\n      };\n      this.resolveDependencies(fs, this.options, function (err, dependencies) {\n        if (err) return callback(err); // abort if something failed\n        // this will create an empty context\n\n        if (!dependencies) {\n          callback();\n          return;\n        } // enhance dependencies with meta info\n\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = dependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _dep3 = _step.value;\n            _dep3.loc = {\n              name: _dep3.userRequest\n            };\n            _dep3.request = _this2.options.addon + _dep3.request;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (_this2.options.mode === \"sync\" || _this2.options.mode === \"eager\") {\n          // if we have an sync or eager context\n          // just add all dependencies and continue\n          _this2.dependencies = dependencies;\n        } else if (_this2.options.mode === \"lazy-once\") {\n          // for the lazy-once mode create a new async dependency block\n          // and add that block to this context\n          if (dependencies.length > 0) {\n            var block = new AsyncDependenciesBlock(Object.assign({}, _this2.options.groupOptions, {\n              name: _this2.options.chunkName\n            }), _this2);\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = dependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var dep = _step2.value;\n                block.addDependency(dep);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            _this2.addBlock(block);\n          }\n        } else if (_this2.options.mode === \"weak\" || _this2.options.mode === \"async-weak\") {\n          // we mark all dependencies as weak\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = dependencies[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var _dep = _step3.value;\n              _dep.weak = true;\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n\n          _this2.dependencies = dependencies;\n        } else if (_this2.options.mode === \"lazy\") {\n          // if we are lazy create a new async dependency block per dependency\n          // and add all blocks to this context\n          var index = 0;\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = dependencies[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var _dep2 = _step4.value;\n              var chunkName = _this2.options.chunkName;\n\n              if (chunkName) {\n                if (!/\\[(index|request)\\]/.test(chunkName)) {\n                  chunkName += \"[index]\";\n                }\n\n                chunkName = chunkName.replace(/\\[index\\]/g, index++);\n                chunkName = chunkName.replace(/\\[request\\]/g, Template.toPath(_dep2.userRequest));\n              }\n\n              var _block = new AsyncDependenciesBlock(Object.assign({}, _this2.options.groupOptions, {\n                name: chunkName\n              }), _dep2.module, _dep2.loc, _dep2.userRequest);\n\n              _block.addDependency(_dep2);\n\n              _this2.addBlock(_block);\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n        } else {\n          callback(new Error(\"Unsupported mode \\\"\".concat(_this2.options.mode, \"\\\" in context\")));\n          return;\n        }\n\n        callback();\n      });\n    }\n  }, {\n    key: \"getUserRequestMap\",\n    value: function getUserRequestMap(dependencies) {\n      // if we filter first we get a new array\n      // therefor we dont need to create a clone of dependencies explicitly\n      // therefore the order of this is !important!\n      return dependencies.filter(function (dependency) {\n        return dependency.module;\n      }).sort(function (a, b) {\n        if (a.userRequest === b.userRequest) {\n          return 0;\n        }\n\n        return a.userRequest < b.userRequest ? -1 : 1;\n      }).reduce(function (map, dep) {\n        map[dep.userRequest] = dep.module.id;\n        return map;\n      }, Object.create(null));\n    }\n  }, {\n    key: \"getFakeMap\",\n    value: function getFakeMap(dependencies) {\n      var _this3 = this;\n\n      if (!this.options.namespaceObject) {\n        return 9;\n      } // if we filter first we get a new array\n      // therefor we dont need to create a clone of dependencies explicitly\n      // therefore the order of this is !important!\n\n\n      var hasNonHarmony = false;\n      var hasNamespace = false;\n      var hasNamed = false;\n      var fakeMap = dependencies.filter(function (dependency) {\n        return dependency.module;\n      }).sort(function (a, b) {\n        return b.module.id - a.module.id;\n      }).reduce(function (map, dep) {\n        var exportsType = dep.module.buildMeta && dep.module.buildMeta.exportsType;\n        var id = dep.module.id;\n\n        if (!exportsType) {\n          map[id] = _this3.options.namespaceObject === \"strict\" ? 1 : 7;\n          hasNonHarmony = true;\n        } else if (exportsType === \"namespace\") {\n          map[id] = 9;\n          hasNamespace = true;\n        } else if (exportsType === \"named\") {\n          map[id] = 3;\n          hasNamed = true;\n        }\n\n        return map;\n      }, Object.create(null));\n\n      if (!hasNamespace && hasNonHarmony && !hasNamed) {\n        return this.options.namespaceObject === \"strict\" ? 1 : 7;\n      }\n\n      if (hasNamespace && !hasNonHarmony && !hasNamed) {\n        return 9;\n      }\n\n      if (!hasNamespace && !hasNonHarmony && hasNamed) {\n        return 3;\n      }\n\n      if (!hasNamespace && !hasNonHarmony && !hasNamed) {\n        return 9;\n      }\n\n      return fakeMap;\n    }\n  }, {\n    key: \"getFakeMapInitStatement\",\n    value: function getFakeMapInitStatement(fakeMap) {\n      return typeof fakeMap === \"object\" ? \"var fakeMap = \".concat(JSON.stringify(fakeMap, null, \"\\t\"), \";\") : \"\";\n    }\n  }, {\n    key: \"getReturn\",\n    value: function getReturn(type) {\n      if (type === 9) {\n        return \"__webpack_require__(id)\";\n      }\n\n      return \"__webpack_require__.t(id, \".concat(type, \")\");\n    }\n  }, {\n    key: \"getReturnModuleObjectSource\",\n    value: function getReturnModuleObjectSource(fakeMap) {\n      var fakeMapDataExpression = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"fakeMap[id]\";\n\n      if (typeof fakeMap === \"number\") {\n        return \"return \".concat(this.getReturn(fakeMap), \";\");\n      }\n\n      return \"return __webpack_require__.t(id, \".concat(fakeMapDataExpression, \")\");\n    }\n  }, {\n    key: \"getSyncSource\",\n    value: function getSyncSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nmodule.exports = webpackContext;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getWeakSyncSource\",\n    value: function getWeakSyncSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackContext(req) {\\n\\tvar id = webpackContextResolve(req);\\n\\tif(!__webpack_require__.m[id]) {\\n\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\t\").concat(returnModuleObject, \"\\n}\\nfunction webpackContextResolve(req) {\\n\\tvar id = map[req];\\n\\tif(!(id + 1)) { // check for number or string\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t}\\n\\treturn id;\\n}\\nwebpackContext.keys = function webpackContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackContext.resolve = webpackContextResolve;\\nwebpackContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackContext;\");\n    }\n  }, {\n    key: \"getAsyncWeakSource\",\n    value: function getAsyncWeakSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap);\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(function(id) {\\n\\t\\tif(!__webpack_require__.m[id]) {\\n\\t\\t\\tvar e = new Error(\\\"Module '\\\" + req + \\\"' ('\\\" + id + \\\"') is not available (weak dependency)\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar id = map[req];\\n\\t\\tif(!(id + 1)) { // check for number or string\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn id;\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getEagerSource\",\n    value: function getEagerSource(dependencies, id) {\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \"\\n\\t}\") : \"__webpack_require__\";\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar id = map[req];\\n\\t\\tif(!(id + 1)) { // check for number or string\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn id;\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getLazyOnceSource\",\n    value: function getLazyOnceSource(block, dependencies, id, runtimeTemplate) {\n      var promise = runtimeTemplate.blockPromise({\n        block: block,\n        message: \"lazy-once context\"\n      });\n      var map = this.getUserRequestMap(dependencies);\n      var fakeMap = this.getFakeMap(dependencies);\n      var thenFunction = fakeMap !== 9 ? \"function(id) {\\n\\t\\t\".concat(this.getReturnModuleObjectSource(fakeMap), \";\\n\\t}\") : \"__webpack_require__\";\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\n\").concat(this.getFakeMapInitStatement(fakeMap), \"\\n\\nfunction webpackAsyncContext(req) {\\n\\treturn webpackAsyncContextResolve(req).then(\").concat(thenFunction, \");\\n}\\nfunction webpackAsyncContextResolve(req) {\\n\\treturn \").concat(promise, \".then(function() {\\n\\t\\tvar id = map[req];\\n\\t\\tif(!(id + 1)) { // check for number or string\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t}\\n\\t\\treturn id;\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.resolve = webpackAsyncContextResolve;\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getLazySource\",\n    value: function getLazySource(blocks, id) {\n      var hasMultipleOrNoChunks = false;\n      var fakeMap = this.getFakeMap(blocks.map(function (b) {\n        return b.dependencies[0];\n      }));\n      var map = blocks.filter(function (block) {\n        return block.dependencies[0].module;\n      }).map(function (block) {\n        return {\n          dependency: block.dependencies[0],\n          block: block,\n          userRequest: block.dependencies[0].userRequest\n        };\n      }).sort(function (a, b) {\n        if (a.userRequest === b.userRequest) return 0;\n        return a.userRequest < b.userRequest ? -1 : 1;\n      }).reduce(function (map, item) {\n        var chunks = item.block.chunkGroup && item.block.chunkGroup.chunks || [];\n\n        if (chunks.length !== 1) {\n          hasMultipleOrNoChunks = true;\n        }\n\n        var arrayStart = [item.dependency.module.id];\n\n        if (typeof fakeMap === \"object\") {\n          arrayStart.push(fakeMap[item.dependency.module.id]);\n        }\n\n        map[item.userRequest] = arrayStart.concat(chunks.map(function (chunk) {\n          return chunk.id;\n        }));\n        return map;\n      }, Object.create(null));\n      var chunksStartPosition = typeof fakeMap === \"object\" ? 2 : 1;\n      var requestPrefix = hasMultipleOrNoChunks ? \"Promise.all(ids.slice(\".concat(chunksStartPosition, \").map(__webpack_require__.e))\") : \"__webpack_require__.e(ids[\".concat(chunksStartPosition, \"])\");\n      var returnModuleObject = this.getReturnModuleObjectSource(fakeMap, \"ids[1]\");\n      return \"var map = \".concat(JSON.stringify(map, null, \"\\t\"), \";\\nfunction webpackAsyncContext(req) {\\n\\tvar ids = map[req];\\n\\tif(!ids) {\\n\\t\\treturn Promise.resolve().then(function() {\\n\\t\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\t\\tthrow e;\\n\\t\\t});\\n\\t}\\n\\treturn \").concat(requestPrefix, \".then(function() {\\n\\t\\tvar id = ids[0];\\n\\t\\t\").concat(returnModuleObject, \"\\n\\t});\\n}\\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\\n\\treturn Object.keys(map);\\n};\\nwebpackAsyncContext.id = \").concat(JSON.stringify(id), \";\\nmodule.exports = webpackAsyncContext;\");\n    }\n  }, {\n    key: \"getSourceForEmptyContext\",\n    value: function getSourceForEmptyContext(id) {\n      return \"function webpackEmptyContext(req) {\\n\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\te.code = 'MODULE_NOT_FOUND';\\n\\tthrow e;\\n}\\nwebpackEmptyContext.keys = function() { return []; };\\nwebpackEmptyContext.resolve = webpackEmptyContext;\\nmodule.exports = webpackEmptyContext;\\nwebpackEmptyContext.id = \".concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getSourceForEmptyAsyncContext\",\n    value: function getSourceForEmptyAsyncContext(id) {\n      return \"function webpackEmptyAsyncContext(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(function() {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t});\\n}\\nwebpackEmptyAsyncContext.keys = function() { return []; };\\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\\nmodule.exports = webpackEmptyAsyncContext;\\nwebpackEmptyAsyncContext.id = \".concat(JSON.stringify(id), \";\");\n    }\n  }, {\n    key: \"getSourceString\",\n    value: function getSourceString(asyncMode, runtimeTemplate) {\n      if (asyncMode === \"lazy\") {\n        if (this.blocks && this.blocks.length > 0) {\n          return this.getLazySource(this.blocks, this.id);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"eager\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getEagerSource(this.dependencies, this.id);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"lazy-once\") {\n        var block = this.blocks[0];\n\n        if (block) {\n          return this.getLazyOnceSource(block, block.dependencies, this.id, runtimeTemplate);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"async-weak\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getAsyncWeakSource(this.dependencies, this.id);\n        }\n\n        return this.getSourceForEmptyAsyncContext(this.id);\n      }\n\n      if (asyncMode === \"weak\") {\n        if (this.dependencies && this.dependencies.length > 0) {\n          return this.getWeakSyncSource(this.dependencies, this.id);\n        }\n      }\n\n      if (this.dependencies && this.dependencies.length > 0) {\n        return this.getSyncSource(this.dependencies, this.id);\n      }\n\n      return this.getSourceForEmptyContext(this.id);\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource(sourceString) {\n      if (this.useSourceMap) {\n        return new OriginalSource(sourceString, this.identifier());\n      }\n\n      return new RawSource(sourceString);\n    }\n  }, {\n    key: \"source\",\n    value: function source(dependencyTemplates, runtimeTemplate) {\n      return this.getSource(this.getSourceString(this.options.mode, runtimeTemplate));\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      // base penalty\n      var initialSize = 160; // if we dont have dependencies we stop here.\n\n      return this.dependencies.reduce(function (size, dependency) {\n        var element =\n        /** @type {ContextElementDependency} */\n        dependency;\n        return size + 5 + element.userRequest.length;\n      }, initialSize);\n    }\n  }]);\n\n  return ContextModule;\n}(Module); // TODO remove in webpack 5\n\n\nObject.defineProperty(ContextModule.prototype, \"recursive\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is recursive\n   */\n  function () {\n    return this.options.recursive;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {boolean} value is recursive\n   * @returns {void}\n   */\n  function (value) {\n    this.options.recursive = value;\n  }, \"ContextModule.recursive has been moved to ContextModule.options.recursive\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"regExp\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {RegExp} regular expression\n   */\n  function () {\n    return this.options.regExp;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {RegExp} value Regular expression\n   * @returns {void}\n   */\n  function (value) {\n    this.options.regExp = value;\n  }, \"ContextModule.regExp has been moved to ContextModule.options.regExp\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"addon\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} addon\n   */\n  function () {\n    return this.options.addon;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value addon\n   * @returns {void}\n   */\n  function (value) {\n    this.options.addon = value;\n  }, \"ContextModule.addon has been moved to ContextModule.options.addon\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"async\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {boolean} is async\n   */\n  function () {\n    return this.options.mode;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {ContextMode} value Context mode\n   * @returns {void}\n   */\n  function (value) {\n    this.options.mode = value;\n  }, \"ContextModule.async has been moved to ContextModule.options.mode\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(ContextModule.prototype, \"chunkName\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @returns {string} chunk name\n   */\n  function () {\n    return this.options.chunkName;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @this {ContextModule}\n   * @param {string} value chunk name\n   * @returns {void}\n   */\n  function (value) {\n    this.options.chunkName = value;\n  }, \"ContextModule.chunkName has been moved to ContextModule.options.chunkName\")\n});\nmodule.exports = ContextModule;","map":null,"metadata":{},"sourceType":"script"}