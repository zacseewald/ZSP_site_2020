{"ast":null,"code":"module.exports = LinkWriter;\n\nvar fs = require('graceful-fs');\n\nvar Writer = require('./writer.js');\n\nvar inherits = require('inherits');\n\nvar path = require('path');\n\nvar rimraf = require('rimraf');\n\ninherits(LinkWriter, Writer);\n\nfunction LinkWriter(props) {\n  var self = this;\n\n  if (!(self instanceof LinkWriter)) {\n    throw new Error('LinkWriter must be called as constructor.');\n  } // should already be established as a Link type\n\n\n  if (!(props.type === 'Link' && props.Link || props.type === 'SymbolicLink' && props.SymbolicLink)) {\n    throw new Error('Non-link type ' + props.type);\n  }\n\n  if (props.linkpath === '') props.linkpath = '.';\n\n  if (!props.linkpath) {\n    self.error('Need linkpath property to create ' + props.type);\n  }\n\n  Writer.call(this, props);\n}\n\nLinkWriter.prototype._create = function () {\n  // console.error(\" LW _create\")\n  var self = this;\n  var hard = self.type === 'Link' || process.platform === 'win32';\n  var link = hard ? 'link' : 'symlink';\n  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath; // can only change the link path by clobbering\n  // For hard links, let's just assume that's always the case, since\n  // there's no good way to read them if we don't already know.\n\n  if (hard) return clobber(self, lp, link);\n  fs.readlink(self._path, function (er, p) {\n    // only skip creation if it's exactly the same link\n    if (p && p === lp) return finish(self);\n    clobber(self, lp, link);\n  });\n};\n\nfunction clobber(self, lp, link) {\n  rimraf(self._path, function (er) {\n    if (er) return self.error(er);\n    create(self, lp, link);\n  });\n}\n\nfunction create(self, lp, link) {\n  fs[link](lp, self._path, function (er) {\n    // if this is a hard link, and we're in the process of writing out a\n    // directory, it's very possible that the thing we're linking to\n    // doesn't exist yet (especially if it was intended as a symlink),\n    // so swallow ENOENT errors here and just soldier in.\n    // Additionally, an EPERM or EACCES can happen on win32 if it's trying\n    // to make a link to a directory.  Again, just skip it.\n    // A better solution would be to have fs.symlink be supported on\n    // windows in some nice fashion.\n    if (er) {\n      if ((er.code === 'ENOENT' || er.code === 'EACCES' || er.code === 'EPERM') && process.platform === 'win32') {\n        self.ready = true;\n        self.emit('ready');\n        self.emit('end');\n        self.emit('close');\n\n        self.end = self._finish = function () {};\n      } else return self.error(er);\n    }\n\n    finish(self);\n  });\n}\n\nfunction finish(self) {\n  self.ready = true;\n  self.emit('ready');\n  if (self._ended && !self._finished) self._finish();\n}\n\nLinkWriter.prototype.end = function () {\n  // console.error(\"LW finish in end\")\n  this._ended = true;\n\n  if (this.ready) {\n    this._finished = true;\n\n    this._finish();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}