{"ast":null,"code":"// field paths that every tar file must have.\n// header is padded to 512 bytes.\nvar f = 0,\n    fields = {},\n    path = fields.path = f++,\n    mode = fields.mode = f++,\n    uid = fields.uid = f++,\n    gid = fields.gid = f++,\n    size = fields.size = f++,\n    mtime = fields.mtime = f++,\n    cksum = fields.cksum = f++,\n    type = fields.type = f++,\n    linkpath = fields.linkpath = f++,\n    headerSize = 512,\n    blockSize = 512,\n    fieldSize = [];\nfieldSize[path] = 100;\nfieldSize[mode] = 8;\nfieldSize[uid] = 8;\nfieldSize[gid] = 8;\nfieldSize[size] = 12;\nfieldSize[mtime] = 12;\nfieldSize[cksum] = 8;\nfieldSize[type] = 1;\nfieldSize[linkpath] = 100; // \"ustar\\0\" may introduce another bunch of headers.\n// these are optional, and will be nulled out if not present.\n\nvar ustar = fields.ustar = f++,\n    ustarver = fields.ustarver = f++,\n    uname = fields.uname = f++,\n    gname = fields.gname = f++,\n    devmaj = fields.devmaj = f++,\n    devmin = fields.devmin = f++,\n    prefix = fields.prefix = f++,\n    fill = fields.fill = f++; // terminate fields.\n\nfields[f] = null;\nfieldSize[ustar] = 6;\nfieldSize[ustarver] = 2;\nfieldSize[uname] = 32;\nfieldSize[gname] = 32;\nfieldSize[devmaj] = 8;\nfieldSize[devmin] = 8;\nfieldSize[prefix] = 155;\nfieldSize[fill] = 12; // nb: prefix field may in fact be 130 bytes of prefix,\n// a null char, 12 bytes for atime, 12 bytes for ctime.\n//\n// To recognize this format:\n// 1. prefix[130] === ' ' or '\\0'\n// 2. atime and ctime are octal numeric values\n// 3. atime and ctime have ' ' in their last byte\n\nvar fieldEnds = {},\n    fieldOffs = {},\n    fe = 0;\n\nfor (var i = 0; i < f; i++) {\n  fieldOffs[i] = fe;\n  fieldEnds[i] = fe += fieldSize[i];\n} // build a translation table of field paths.\n\n\nObject.keys(fields).forEach(function (f) {\n  if (fields[f] !== null) fields[fields[f]] = f;\n}); // different values of the 'type' field\n// paths match the values of Stats.isX() functions, where appropriate\n\nvar types = {\n  0: \"File\",\n  \"\\0\": \"OldFile\" // like 0\n  ,\n  \"\": \"OldFile\",\n  1: \"Link\",\n  2: \"SymbolicLink\",\n  3: \"CharacterDevice\",\n  4: \"BlockDevice\",\n  5: \"Directory\",\n  6: \"FIFO\",\n  7: \"ContiguousFile\" // like 0\n  // posix headers\n  ,\n  g: \"GlobalExtendedHeader\" // k=v for the rest of the archive\n  ,\n  x: \"ExtendedHeader\" // k=v for the next file\n  // vendor-specific stuff\n  ,\n  A: \"SolarisACL\" // skip\n  ,\n  D: \"GNUDumpDir\" // like 5, but with data, which should be skipped\n  ,\n  I: \"Inode\" // metadata only, skip\n  ,\n  K: \"NextFileHasLongLinkpath\" // data = link path of next file\n  ,\n  L: \"NextFileHasLongPath\" // data = path of next file\n  ,\n  M: \"ContinuationFile\" // skip\n  ,\n  N: \"OldGnuLongPath\" // like L\n  ,\n  S: \"SparseFile\" // skip\n  ,\n  V: \"TapeVolumeHeader\" // skip\n  ,\n  X: \"OldExtendedHeader\" // like x\n\n};\nObject.keys(types).forEach(function (t) {\n  types[types[t]] = types[types[t]] || t;\n}); // values for the mode field\n\nvar modes = {\n  suid: 04000 // set uid on extraction\n  ,\n  sgid: 02000 // set gid on extraction\n  ,\n  svtx: 01000 // set restricted deletion flag on dirs on extraction\n  ,\n  uread: 0400,\n  uwrite: 0200,\n  uexec: 0100,\n  gread: 040,\n  gwrite: 020,\n  gexec: 010,\n  oread: 4,\n  owrite: 2,\n  oexec: 1,\n  all: 07777\n};\nvar numeric = {\n  mode: true,\n  uid: true,\n  gid: true,\n  size: true,\n  mtime: true,\n  devmaj: true,\n  devmin: true,\n  cksum: true,\n  atime: true,\n  ctime: true,\n  dev: true,\n  ino: true,\n  nlink: true\n};\nObject.keys(modes).forEach(function (t) {\n  modes[modes[t]] = modes[modes[t]] || t;\n});\nvar knownExtended = {\n  atime: true,\n  charset: true,\n  comment: true,\n  ctime: true,\n  gid: true,\n  gname: true,\n  linkpath: true,\n  mtime: true,\n  path: true,\n  realtime: true,\n  security: true,\n  size: true,\n  uid: true,\n  uname: true\n};\nexports.fields = fields;\nexports.fieldSize = fieldSize;\nexports.fieldOffs = fieldOffs;\nexports.fieldEnds = fieldEnds;\nexports.types = types;\nexports.modes = modes;\nexports.numeric = numeric;\nexports.headerSize = headerSize;\nexports.blockSize = blockSize;\nexports.knownExtended = knownExtended;\nexports.Pack = require(\"./lib/pack.js\");\nexports.Parse = require(\"./lib/parse.js\");\nexports.Extract = require(\"./lib/extract.js\");","map":null,"metadata":{},"sourceType":"script"}