{"ast":null,"code":"// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\nmodule.exports = DirWriter;\n\nvar Writer = require('./writer.js');\n\nvar inherits = require('inherits');\n\nvar mkdir = require('mkdirp');\n\nvar path = require('path');\n\nvar collect = require('./collect.js');\n\ninherits(DirWriter, Writer);\n\nfunction DirWriter(props) {\n  var self = this;\n\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true);\n  } // should already be established as a Directory type\n\n\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' + JSON.stringify(props), null, true);\n  }\n\n  Writer.call(this, props);\n}\n\nDirWriter.prototype._create = function () {\n  var self = this;\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er); // ready to start getting entries!\n\n    self.ready = true;\n    self.emit('ready');\n\n    self._process();\n  });\n}; // a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\n\n\nDirWriter.prototype.write = function () {\n  return true;\n};\n\nDirWriter.prototype.end = function () {\n  this._ended = true;\n\n  this._process();\n};\n\nDirWriter.prototype.add = function (entry) {\n  var self = this; // console.error('\\tadd', entry._path, '->', self._path)\n\n  collect(entry);\n\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry);\n\n    return false;\n  } // create a new writer, and pipe the incoming entry into it.\n\n\n  if (self._ended) {\n    return self.error('add after end');\n  }\n\n  self._buffer.push(entry);\n\n  self._process();\n\n  return this._buffer.length === 0;\n};\n\nDirWriter.prototype._process = function () {\n  var self = this; // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return;\n\n  var entry = self._buffer.shift();\n\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain');\n    if (self._ended) self._finish();\n    return;\n  }\n\n  self._processing = true; // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry); // ok, add this entry\n  //\n  // don't allow recursive copying\n\n  var p = entry;\n  var pp;\n\n  do {\n    pp = p._path || p.path;\n\n    if (pp === self.root._path || pp === self._path || pp && pp.indexOf(self._path) === 0) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false;\n      if (entry._collected) entry.pipe();\n      return self._process();\n    }\n\n    p = p.parent;\n  } while (p); // console.error(\"DW not recursive\")\n  // chop off the entry's root dir, replace with ours\n\n\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  };\n  pp = entry._path || entry.path || entry.props.path;\n\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1);\n  } // get rid of any ../../ shenanigans\n\n\n  props.path = path.join(self.path, path.join('/', pp)); // if i have a filter, the child should inherit it.\n\n  props.filter = self.filter; // all the rest of the stuff, copy over from the source.\n\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k];\n    }\n  }); // not sure at this point what kind of writer this is.\n\n  var child = self._currentChild = new Writer(props);\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child);\n    entry.resume();\n  }); // XXX Make this work in node.\n  // Long filenames should not break stuff.\n\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er);\n      child.emit('end');\n      child.emit('close');\n    } else {\n      self.emit('error', er);\n    }\n  }); // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n\n  child.on('close', onend);\n  var ended = false;\n\n  function onend() {\n    if (ended) return;\n    ended = true; // console.error(\"* DW Child end\", child.basename)\n\n    self._currentChild = null;\n    self._processing = false;\n\n    self._process();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}