{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar crypto = require(\"crypto\");\n\nvar SortableSet = require(\"../util/SortableSet\");\n\nvar GraphHelpers = require(\"../GraphHelpers\");\n\nvar _require = require(\"../util/SetHelpers\"),\n    isSubset = _require.isSubset;\n\nvar deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nvar MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\nvar contextify = require(\"../util/identifier\").contextify;\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n\nvar deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\nvar hashFilename = function hashFilename(name) {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\n\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\nvar getRequests = function getRequests(chunk) {\n  var requests = 0;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = chunk.groupsIterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var chunkGroup = _step.value;\n      requests = Math.max(requests, chunkGroup.chunks.length);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return requests;\n};\n\nvar getModulesSize = function getModulesSize(modules) {\n  var sum = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var m = _step2.value;\n      sum += m.size();\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nvar isOverlap = function isOverlap(a, b) {\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = a[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var item = _step3.value;\n      if (b.has(item)) return true;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return false;\n};\n\nvar compareEntries = function compareEntries(a, b) {\n  // 1. by priority\n  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  var diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  var aSizeReduce = a.size * (a.chunks.size - 1);\n  var bSizeReduce = b.size * (b.chunks.size - 1);\n  var diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by number of modules (to be able to compare by identifier)\n\n  var modulesA = a.modules;\n  var modulesB = b.modules;\n  var diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 5. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  var aI = modulesA[Symbol.iterator]();\n  var bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    var aItem = aI.next();\n    var bItem = bI.next();\n    if (aItem.done) return 0;\n    var aModuleIdentifier = aItem.value.identifier();\n    var bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\n\nvar compareNumbers = function compareNumbers(a, b) {\n  return a - b;\n};\n\nvar INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {\n  return chunk.canBeInitial();\n};\n\nvar ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {\n  return !chunk.canBeInitial();\n};\n\nvar ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {\n  return true;\n};\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  function SplitChunksPlugin(options) {\n    _classCallCheck(this, SplitChunksPlugin);\n\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n\n  _createClass(SplitChunksPlugin, [{\n    key: \"apply\",\n\n    /**\n     * @param {Compiler} compiler webpack compiler\n     * @returns {void}\n     */\n    value: function apply(compiler) {\n      var _this = this;\n\n      compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", function (compilation) {\n        var alreadyOptimized = false;\n        compilation.hooks.unseal.tap(\"SplitChunksPlugin\", function () {\n          alreadyOptimized = false;\n        });\n        compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", function (chunks) {\n          if (alreadyOptimized) return;\n          alreadyOptimized = true; // Give each selected chunk an index (to create strings from chunks)\n\n          var indexMap = new Map();\n          var index = 1;\n          var _iteratorNormalCompletion4 = true;\n          var _didIteratorError4 = false;\n          var _iteratorError4 = undefined;\n\n          try {\n            for (var _iterator4 = chunks[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n              var chunk = _step4.value;\n              indexMap.set(chunk, index++);\n            }\n          } catch (err) {\n            _didIteratorError4 = true;\n            _iteratorError4 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                _iterator4.return();\n              }\n            } finally {\n              if (_didIteratorError4) {\n                throw _iteratorError4;\n              }\n            }\n          }\n\n          var getKey = function getKey(chunks) {\n            return Array.from(chunks, function (c) {\n              return indexMap.get(c);\n            }).sort(compareNumbers).join();\n          };\n          /** @type {Map<string, Set<Chunk>>} */\n\n\n          var chunkSetsInGraph = new Map();\n          var _iteratorNormalCompletion5 = true;\n          var _didIteratorError5 = false;\n          var _iteratorError5 = undefined;\n\n          try {\n            for (var _iterator5 = compilation.modules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n              var _module = _step5.value;\n              var chunksKey = getKey(_module.chunksIterable);\n\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(_module.chunksIterable));\n              }\n            } // group these set of chunks by count\n            // to allow to check less sets via isSubset\n            // (only smaller sets can be subset)\n\n            /** @type {Map<number, Array<Set<Chunk>>>} */\n\n          } catch (err) {\n            _didIteratorError5 = true;\n            _iteratorError5 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n                _iterator5.return();\n              }\n            } finally {\n              if (_didIteratorError5) {\n                throw _iteratorError5;\n              }\n            }\n          }\n\n          var chunkSetsByCount = new Map();\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = chunkSetsInGraph.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var chunksSet = _step6.value;\n              var count = chunksSet.size;\n              var array = chunkSetsByCount.get(count);\n\n              if (array === undefined) {\n                array = [];\n                chunkSetsByCount.set(count, array);\n              }\n\n              array.push(chunksSet);\n            } // Create a list of possible combinations\n\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n\n          var combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n          var getCombinations = function getCombinations(key) {\n            var chunksSet = chunkSetsInGraph.get(key);\n            var array = [chunksSet];\n\n            if (chunksSet.size > 1) {\n              var _iteratorNormalCompletion7 = true;\n              var _didIteratorError7 = false;\n              var _iteratorError7 = undefined;\n\n              try {\n                for (var _iterator7 = chunkSetsByCount[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n                  var _step7$value = _slicedToArray(_step7.value, 2),\n                      count = _step7$value[0],\n                      setArray = _step7$value[1];\n\n                  // \"equal\" is not needed because they would have been merge in the first step\n                  if (count < chunksSet.size) {\n                    var _iteratorNormalCompletion8 = true;\n                    var _didIteratorError8 = false;\n                    var _iteratorError8 = undefined;\n\n                    try {\n                      for (var _iterator8 = setArray[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n                        var set = _step8.value;\n\n                        if (isSubset(chunksSet, set)) {\n                          array.push(set);\n                        }\n                      }\n                    } catch (err) {\n                      _didIteratorError8 = true;\n                      _iteratorError8 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n                          _iterator8.return();\n                        }\n                      } finally {\n                        if (_didIteratorError8) {\n                          throw _iteratorError8;\n                        }\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError7 = true;\n                _iteratorError7 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n                    _iterator7.return();\n                  }\n                } finally {\n                  if (_didIteratorError7) {\n                    throw _iteratorError7;\n                  }\n                }\n              }\n            }\n\n            return array;\n          };\n          /**\n           * @typedef {Object} SelectedChunksResult\n           * @property {Chunk[]} chunks the list of chunks\n           * @property {string} key a key of the list\n           */\n\n          /**\n           * @typedef {function(Chunk): boolean} ChunkFilterFunction\n           */\n\n          /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n          var selectedChunksCacheByChunksSet = new WeakMap();\n          /**\n           * get list and key by applying the filter function to the list\n           * It is cached for performance reasons\n           * @param {Set<Chunk>} chunks list of chunks\n           * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n           * @returns {SelectedChunksResult} list and key\n           */\n\n          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {\n            var entry = selectedChunksCacheByChunksSet.get(chunks);\n\n            if (entry === undefined) {\n              entry = new WeakMap();\n              selectedChunksCacheByChunksSet.set(chunks, entry);\n            }\n            /** @type {SelectedChunksResult} */\n\n\n            var entry2 = entry.get(chunkFilter);\n\n            if (entry2 === undefined) {\n              /** @type {Chunk[]} */\n              var selectedChunks = [];\n              var _iteratorNormalCompletion9 = true;\n              var _didIteratorError9 = false;\n              var _iteratorError9 = undefined;\n\n              try {\n                for (var _iterator9 = chunks[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n                  var chunk = _step9.value;\n                  if (chunkFilter(chunk)) selectedChunks.push(chunk);\n                }\n              } catch (err) {\n                _didIteratorError9 = true;\n                _iteratorError9 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n                    _iterator9.return();\n                  }\n                } finally {\n                  if (_didIteratorError9) {\n                    throw _iteratorError9;\n                  }\n                }\n              }\n\n              entry2 = {\n                chunks: selectedChunks,\n                key: getKey(selectedChunks)\n              };\n              entry.set(chunkFilter, entry2);\n            }\n\n            return entry2;\n          };\n          /**\n           * @typedef {Object} ChunksInfoItem\n           * @property {SortableSet} modules\n           * @property {TODO} cacheGroup\n           * @property {string} name\n           * @property {boolean} validateSize\n           * @property {number} size\n           * @property {Set<Chunk>} chunks\n           * @property {Set<Chunk>} reuseableChunks\n           * @property {Set<string>} chunksKeys\n           */\n          // Map a list of chunks to a list of modules\n          // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n          /** @type {Map<string, ChunksInfoItem>} */\n\n\n          var chunksInfoMap = new Map();\n          /**\n           * @param {TODO} cacheGroup the current cache group\n           * @param {Chunk[]} selectedChunks chunks selected for this module\n           * @param {string} selectedChunksKey a key of selectedChunks\n           * @param {Module} module the current module\n           * @returns {void}\n           */\n\n          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, selectedChunks, selectedChunksKey, module) {\n            // Break if minimum number of chunks is not reached\n            if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Create key for maps\n            // When it has a name we use the name as key\n            // Elsewise we create the key from chunks and cache group key\n            // This automatically merges equal names\n\n            var key = cacheGroup.key + (name ? \" name:\".concat(name) : \" chunks:\".concat(selectedChunksKey)); // Add module to maps\n\n            var info = chunksInfoMap.get(key);\n\n            if (info === undefined) {\n              chunksInfoMap.set(key, info = {\n                modules: new SortableSet(undefined, sortByIdentifier),\n                cacheGroup: cacheGroup,\n                name: name,\n                validateSize: cacheGroup.minSize > 0,\n                size: 0,\n                chunks: new Set(),\n                reuseableChunks: new Set(),\n                chunksKeys: new Set()\n              });\n            }\n\n            info.modules.add(module);\n\n            if (info.validateSize) {\n              info.size += module.size();\n            }\n\n            if (!info.chunksKeys.has(selectedChunksKey)) {\n              info.chunksKeys.add(selectedChunksKey);\n              var _iteratorNormalCompletion10 = true;\n              var _didIteratorError10 = false;\n              var _iteratorError10 = undefined;\n\n              try {\n                for (var _iterator10 = selectedChunks[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n                  var chunk = _step10.value;\n                  info.chunks.add(chunk);\n                }\n              } catch (err) {\n                _didIteratorError10 = true;\n                _iteratorError10 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion10 && _iterator10.return != null) {\n                    _iterator10.return();\n                  }\n                } finally {\n                  if (_didIteratorError10) {\n                    throw _iteratorError10;\n                  }\n                }\n              }\n            }\n          }; // Walk through all modules\n\n\n          var _iteratorNormalCompletion11 = true;\n          var _didIteratorError11 = false;\n          var _iteratorError11 = undefined;\n\n          try {\n            for (var _iterator11 = compilation.modules[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n              var _module2 = _step11.value;\n\n              // Get cache group\n              var cacheGroups = _this.options.getCacheGroups(_module2);\n\n              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n                continue;\n              } // Prepare some values\n\n\n              var _chunksKey = getKey(_module2.chunksIterable);\n\n              var combs = combinationsCache.get(_chunksKey);\n\n              if (combs === undefined) {\n                combs = getCombinations(_chunksKey);\n                combinationsCache.set(_chunksKey, combs);\n              }\n\n              var _iteratorNormalCompletion14 = true;\n              var _didIteratorError14 = false;\n              var _iteratorError14 = undefined;\n\n              try {\n                for (var _iterator14 = cacheGroups[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n                  var cacheGroupSource = _step14.value;\n                  var cacheGroup = {\n                    key: cacheGroupSource.key,\n                    priority: cacheGroupSource.priority || 0,\n                    chunksFilter: cacheGroupSource.chunksFilter || _this.options.chunksFilter,\n                    minSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : _this.options.minSize,\n                    minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : _this.options.minSize,\n                    maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : _this.options.maxSize,\n                    minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : _this.options.minChunks,\n                    maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxAsyncRequests,\n                    maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxInitialRequests,\n                    getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : _this.options.getName,\n                    filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : _this.options.filename,\n                    automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : _this.options.automaticNameDelimiter,\n                    reuseExistingChunk: cacheGroupSource.reuseExistingChunk\n                  }; // For all combination of chunk selection\n\n                  var _iteratorNormalCompletion15 = true;\n                  var _didIteratorError15 = false;\n                  var _iteratorError15 = undefined;\n\n                  try {\n                    for (var _iterator15 = combs[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n                      var chunkCombination = _step15.value;\n                      // Break if minimum number of chunks is not reached\n                      if (chunkCombination.size < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),\n                          selectedChunks = _getSelectedChunks.chunks,\n                          selectedChunksKey = _getSelectedChunks.key;\n\n                      addModuleToChunksInfoMap(cacheGroup, selectedChunks, selectedChunksKey, _module2);\n                    }\n                  } catch (err) {\n                    _didIteratorError15 = true;\n                    _iteratorError15 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion15 && _iterator15.return != null) {\n                        _iterator15.return();\n                      }\n                    } finally {\n                      if (_didIteratorError15) {\n                        throw _iteratorError15;\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError14 = true;\n                _iteratorError14 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion14 && _iterator14.return != null) {\n                    _iterator14.return();\n                  }\n                } finally {\n                  if (_didIteratorError14) {\n                    throw _iteratorError14;\n                  }\n                }\n              }\n            } // Filter items were size < minSize\n\n          } catch (err) {\n            _didIteratorError11 = true;\n            _iteratorError11 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {\n                _iterator11.return();\n              }\n            } finally {\n              if (_didIteratorError11) {\n                throw _iteratorError11;\n              }\n            }\n          }\n\n          var _iteratorNormalCompletion12 = true;\n          var _didIteratorError12 = false;\n          var _iteratorError12 = undefined;\n\n          try {\n            for (var _iterator12 = chunksInfoMap[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n              var pair = _step12.value;\n              var info = pair[1];\n\n              if (info.validateSize && info.size < info.cacheGroup.minSize) {\n                chunksInfoMap.delete(pair[0]);\n              }\n            }\n            /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\n          } catch (err) {\n            _didIteratorError12 = true;\n            _iteratorError12 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {\n                _iterator12.return();\n              }\n            } finally {\n              if (_didIteratorError12) {\n                throw _iteratorError12;\n              }\n            }\n          }\n\n          var maxSizeQueueMap = new Map();\n\n          var _loop = function _loop() {\n            // Find best matching entry\n            var bestEntryKey = void 0;\n            var bestEntry = void 0;\n            var _iteratorNormalCompletion16 = true;\n            var _didIteratorError16 = false;\n            var _iteratorError16 = undefined;\n\n            try {\n              for (var _iterator16 = chunksInfoMap[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n                var _pair = _step16.value;\n                var key = _pair[0];\n                var _info = _pair[1];\n\n                if (bestEntry === undefined) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                } else if (compareEntries(bestEntry, _info) < 0) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                }\n              }\n            } catch (err) {\n              _didIteratorError16 = true;\n              _iteratorError16 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion16 && _iterator16.return != null) {\n                  _iterator16.return();\n                }\n              } finally {\n                if (_didIteratorError16) {\n                  throw _iteratorError16;\n                }\n              }\n            }\n\n            var item = bestEntry;\n            chunksInfoMap.delete(bestEntryKey);\n            var chunkName = item.name; // Variable for the new chunk (lazy created)\n\n            /** @type {Chunk} */\n\n            var newChunk = void 0; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n            var isReused = false;\n\n            if (item.cacheGroup.reuseExistingChunk) {\n              var _iteratorNormalCompletion17 = true;\n              var _didIteratorError17 = false;\n              var _iteratorError17 = undefined;\n\n              try {\n                outer: for (var _iterator17 = item.chunks[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {\n                  var _chunk = _step17.value;\n                  if (_chunk.getNumberOfModules() !== item.modules.size) continue;\n                  if (_chunk.hasEntryModule()) continue;\n                  var _iteratorNormalCompletion18 = true;\n                  var _didIteratorError18 = false;\n                  var _iteratorError18 = undefined;\n\n                  try {\n                    for (var _iterator18 = item.modules[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {\n                      var _module3 = _step18.value;\n                      if (!_chunk.containsModule(_module3)) continue outer;\n                    }\n                  } catch (err) {\n                    _didIteratorError18 = true;\n                    _iteratorError18 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion18 && _iterator18.return != null) {\n                        _iterator18.return();\n                      }\n                    } finally {\n                      if (_didIteratorError18) {\n                        throw _iteratorError18;\n                      }\n                    }\n                  }\n\n                  if (!newChunk || !newChunk.name) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length < newChunk.name.length) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length === newChunk.name.length && _chunk.name < newChunk.name) {\n                    newChunk = _chunk;\n                  }\n\n                  chunkName = undefined;\n                  isReused = true;\n                }\n              } catch (err) {\n                _didIteratorError17 = true;\n                _iteratorError17 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion17 && _iterator17.return != null) {\n                    _iterator17.return();\n                  }\n                } finally {\n                  if (_didIteratorError17) {\n                    throw _iteratorError17;\n                  }\n                }\n              }\n            } // Check if maxRequests condition can be fulfilled\n\n\n            var usedChunks = Array.from(item.chunks).filter(function (chunk) {\n              // skip if we address ourself\n              return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n            }); // Skip when no chunk selected\n\n            if (usedChunks.length === 0) return \"continue\";\n\n            if (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests)) {\n              var chunkInLimit = usedChunks.filter(function (chunk) {\n                // respect max requests when not enforced\n                var maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n                return !isFinite(maxRequests) || getRequests(chunk) < maxRequests;\n              });\n\n              if (chunkInLimit.length < usedChunks.length) {\n                if (chunkInLimit.length >= item.cacheGroup.minChunks) {\n                  var _iteratorNormalCompletion19 = true;\n                  var _didIteratorError19 = false;\n                  var _iteratorError19 = undefined;\n\n                  try {\n                    for (var _iterator19 = item.modules[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {\n                      var _module4 = _step19.value;\n                      addModuleToChunksInfoMap(item.cacheGroup, chunkInLimit, getKey(chunkInLimit), _module4);\n                    }\n                  } catch (err) {\n                    _didIteratorError19 = true;\n                    _iteratorError19 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion19 && _iterator19.return != null) {\n                        _iterator19.return();\n                      }\n                    } finally {\n                      if (_didIteratorError19) {\n                        throw _iteratorError19;\n                      }\n                    }\n                  }\n                }\n\n                return \"continue\";\n              }\n            } // Create the new chunk if not reusing one\n\n\n            if (!isReused) {\n              newChunk = compilation.addChunk(chunkName);\n            } // Walk through all chunks\n\n\n            var _iteratorNormalCompletion20 = true;\n            var _didIteratorError20 = false;\n            var _iteratorError20 = undefined;\n\n            try {\n              for (var _iterator20 = usedChunks[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {\n                var _chunk4 = _step20.value;\n\n                // Add graph connections for splitted chunk\n                _chunk4.split(newChunk);\n              } // Add a note to the chunk\n\n            } catch (err) {\n              _didIteratorError20 = true;\n              _iteratorError20 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion20 && _iterator20.return != null) {\n                  _iterator20.return();\n                }\n              } finally {\n                if (_didIteratorError20) {\n                  throw _iteratorError20;\n                }\n              }\n            }\n\n            newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n\n            if (item.cacheGroup.key) {\n              newChunk.chunkReason += \" (cache group: \".concat(item.cacheGroup.key, \")\");\n            }\n\n            if (chunkName) {\n              newChunk.chunkReason += \" (name: \".concat(chunkName, \")\"); // If the chosen name is already an entry point we remove the entry point\n\n              var entrypoint = compilation.entrypoints.get(chunkName);\n\n              if (entrypoint) {\n                compilation.entrypoints.delete(chunkName);\n                entrypoint.remove();\n                newChunk.entryModule = undefined;\n              }\n            }\n\n            if (item.cacheGroup.filename) {\n              if (!newChunk.isOnlyInitial()) {\n                throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + \"(cache group: \".concat(item.cacheGroup.key, \")\"));\n              }\n\n              newChunk.filenameTemplate = item.cacheGroup.filename;\n            }\n\n            if (!isReused) {\n              // Add all modules to the new chunk\n              var _iteratorNormalCompletion21 = true;\n              var _didIteratorError21 = false;\n              var _iteratorError21 = undefined;\n\n              try {\n                for (var _iterator21 = item.modules[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {\n                  var _module5 = _step21.value;\n\n                  if (typeof _module5.chunkCondition === \"function\") {\n                    if (!_module5.chunkCondition(newChunk)) continue;\n                  } // Add module to new chunk\n\n\n                  GraphHelpers.connectChunkAndModule(newChunk, _module5); // Remove module from used chunks\n\n                  var _iteratorNormalCompletion22 = true;\n                  var _didIteratorError22 = false;\n                  var _iteratorError22 = undefined;\n\n                  try {\n                    for (var _iterator22 = usedChunks[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {\n                      var _chunk2 = _step22.value;\n\n                      _chunk2.removeModule(_module5);\n\n                      _module5.rewriteChunkInReasons(_chunk2, [newChunk]);\n                    }\n                  } catch (err) {\n                    _didIteratorError22 = true;\n                    _iteratorError22 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion22 && _iterator22.return != null) {\n                        _iterator22.return();\n                      }\n                    } finally {\n                      if (_didIteratorError22) {\n                        throw _iteratorError22;\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError21 = true;\n                _iteratorError21 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion21 && _iterator21.return != null) {\n                    _iterator21.return();\n                  }\n                } finally {\n                  if (_didIteratorError21) {\n                    throw _iteratorError21;\n                  }\n                }\n              }\n            } else {\n              // Remove all modules from used chunks\n              var _iteratorNormalCompletion23 = true;\n              var _didIteratorError23 = false;\n              var _iteratorError23 = undefined;\n\n              try {\n                for (var _iterator23 = item.modules[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {\n                  var _module6 = _step23.value;\n                  var _iteratorNormalCompletion24 = true;\n                  var _didIteratorError24 = false;\n                  var _iteratorError24 = undefined;\n\n                  try {\n                    for (var _iterator24 = usedChunks[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {\n                      var _chunk3 = _step24.value;\n\n                      _chunk3.removeModule(_module6);\n\n                      _module6.rewriteChunkInReasons(_chunk3, [newChunk]);\n                    }\n                  } catch (err) {\n                    _didIteratorError24 = true;\n                    _iteratorError24 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion24 && _iterator24.return != null) {\n                        _iterator24.return();\n                      }\n                    } finally {\n                      if (_didIteratorError24) {\n                        throw _iteratorError24;\n                      }\n                    }\n                  }\n                }\n              } catch (err) {\n                _didIteratorError23 = true;\n                _iteratorError23 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion23 && _iterator23.return != null) {\n                    _iterator23.return();\n                  }\n                } finally {\n                  if (_didIteratorError23) {\n                    throw _iteratorError23;\n                  }\n                }\n              }\n            }\n\n            if (item.cacheGroup.maxSize > 0) {\n              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n              maxSizeQueueMap.set(newChunk, {\n                minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n                maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n                keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n              });\n            } // remove all modules from other entries and update size\n\n\n            var _iteratorNormalCompletion25 = true;\n            var _didIteratorError25 = false;\n            var _iteratorError25 = undefined;\n\n            try {\n              for (var _iterator25 = chunksInfoMap[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {\n                var _step25$value = _slicedToArray(_step25.value, 2),\n                    _key = _step25$value[0],\n                    _info2 = _step25$value[1];\n\n                if (isOverlap(_info2.chunks, item.chunks)) {\n                  if (_info2.validateSize) {\n                    // update modules and total size\n                    // may remove it from the map when < minSize\n                    var oldSize = _info2.modules.size;\n                    var _iteratorNormalCompletion26 = true;\n                    var _didIteratorError26 = false;\n                    var _iteratorError26 = undefined;\n\n                    try {\n                      for (var _iterator26 = item.modules[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {\n                        var _module7 = _step26.value;\n\n                        _info2.modules.delete(_module7);\n                      }\n                    } catch (err) {\n                      _didIteratorError26 = true;\n                      _iteratorError26 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion26 && _iterator26.return != null) {\n                          _iterator26.return();\n                        }\n                      } finally {\n                        if (_didIteratorError26) {\n                          throw _iteratorError26;\n                        }\n                      }\n                    }\n\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap.delete(_key);\n                      continue;\n                    }\n\n                    if (_info2.modules.size !== oldSize) {\n                      _info2.size = getModulesSize(_info2.modules);\n\n                      if (_info2.size < _info2.cacheGroup.minSize) {\n                        chunksInfoMap.delete(_key);\n                      }\n                    }\n                  } else {\n                    // only update the modules\n                    var _iteratorNormalCompletion27 = true;\n                    var _didIteratorError27 = false;\n                    var _iteratorError27 = undefined;\n\n                    try {\n                      for (var _iterator27 = item.modules[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {\n                        var _module8 = _step27.value;\n\n                        _info2.modules.delete(_module8);\n                      }\n                    } catch (err) {\n                      _didIteratorError27 = true;\n                      _iteratorError27 = err;\n                    } finally {\n                      try {\n                        if (!_iteratorNormalCompletion27 && _iterator27.return != null) {\n                          _iterator27.return();\n                        }\n                      } finally {\n                        if (_didIteratorError27) {\n                          throw _iteratorError27;\n                        }\n                      }\n                    }\n\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap.delete(_key);\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _didIteratorError25 = true;\n              _iteratorError25 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion25 && _iterator25.return != null) {\n                  _iterator25.return();\n                }\n              } finally {\n                if (_didIteratorError25) {\n                  throw _iteratorError25;\n                }\n              }\n            }\n          };\n\n          while (chunksInfoMap.size > 0) {\n            var _ret = _loop();\n\n            if (_ret === \"continue\") continue;\n          }\n\n          var incorrectMinMaxSizeSet = new Set(); // Make sure that maxSize is fulfilled\n\n          var _iteratorNormalCompletion13 = true;\n          var _didIteratorError13 = false;\n          var _iteratorError13 = undefined;\n\n          try {\n            var _loop2 = function _loop2() {\n              var chunk = _step13.value;\n\n              var _ref = maxSizeQueueMap.get(chunk) || _this.options.fallbackCacheGroup,\n                  minSize = _ref.minSize,\n                  maxSize = _ref.maxSize,\n                  automaticNameDelimiter = _ref.automaticNameDelimiter,\n                  keys = _ref.keys;\n\n              if (!maxSize) return \"continue\";\n\n              if (minSize > maxSize) {\n                var warningKey = \"\".concat(keys && keys.join(), \" \").concat(minSize, \" \").concat(maxSize);\n\n                if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                  incorrectMinMaxSizeSet.add(warningKey);\n                  compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n                }\n              }\n\n              var results = deterministicGroupingForModules({\n                maxSize: Math.max(minSize, maxSize),\n                minSize: minSize,\n                items: chunk.modulesIterable,\n                getKey: function getKey(module) {\n                  var ident = contextify(compilation.options.context, module.identifier());\n                  var name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n                  var fullKey = name + automaticNameDelimiter + hashFilename(ident);\n                  return fullKey.replace(/[\\\\/?]/g, \"_\");\n                },\n                getSize: function getSize(module) {\n                  return module.size();\n                }\n              });\n              results.sort(function (a, b) {\n                if (a.key < b.key) return -1;\n                if (a.key > b.key) return 1;\n                return 0;\n              });\n\n              for (var i = 0; i < results.length; i++) {\n                var group = results[i];\n                var key = _this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n                var name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n                if (name && name.length > 100) {\n                  name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n                }\n\n                var newPart = void 0;\n\n                if (i !== results.length - 1) {\n                  newPart = compilation.addChunk(name);\n                  chunk.split(newPart);\n                  newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n                  var _iteratorNormalCompletion28 = true;\n                  var _didIteratorError28 = false;\n                  var _iteratorError28 = undefined;\n\n                  try {\n                    for (var _iterator28 = group.items[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {\n                      var _module9 = _step28.value;\n\n                      if (typeof _module9.chunkCondition === \"function\") {\n                        if (!_module9.chunkCondition(newPart)) continue;\n                      } // Add module to new chunk\n\n\n                      GraphHelpers.connectChunkAndModule(newPart, _module9); // Remove module from used chunks\n\n                      chunk.removeModule(_module9);\n\n                      _module9.rewriteChunkInReasons(chunk, [newPart]);\n                    }\n                  } catch (err) {\n                    _didIteratorError28 = true;\n                    _iteratorError28 = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion28 && _iterator28.return != null) {\n                        _iterator28.return();\n                      }\n                    } finally {\n                      if (_didIteratorError28) {\n                        throw _iteratorError28;\n                      }\n                    }\n                  }\n                } else {\n                  // change the chunk to be a part\n                  newPart = chunk;\n                  chunk.name = name;\n                }\n              }\n            };\n\n            for (var _iterator13 = compilation.chunks.slice()[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n              var _ret2 = _loop2();\n\n              if (_ret2 === \"continue\") continue;\n            }\n          } catch (err) {\n            _didIteratorError13 = true;\n            _iteratorError13 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {\n                _iterator13.return();\n              }\n            } finally {\n              if (_didIteratorError13) {\n                throw _iteratorError13;\n              }\n            }\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"normalizeOptions\",\n    value: function normalizeOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n        minSize: options.minSize || 0,\n        maxSize: options.maxSize || 0,\n        minChunks: options.minChunks || 1,\n        maxAsyncRequests: options.maxAsyncRequests || 1,\n        maxInitialRequests: options.maxInitialRequests || 1,\n        hidePathInfo: options.hidePathInfo || false,\n        filename: options.filename || undefined,\n        getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n          cacheGroups: options.cacheGroups,\n          name: options.name,\n          automaticNameDelimiter: options.automaticNameDelimiter\n        }),\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n      };\n    }\n  }, {\n    key: \"normalizeName\",\n    value: function normalizeName(_ref2) {\n      var name = _ref2.name,\n          automaticNameDelimiter = _ref2.automaticNameDelimiter,\n          automaticNamePrefix = _ref2.automaticNamePrefix;\n\n      if (name === true) {\n        /** @type {WeakMap<Chunk[], Record<string, string>>} */\n        var cache = new WeakMap();\n\n        var fn = function fn(module, chunks, cacheGroup) {\n          var cacheEntry = cache.get(chunks);\n\n          if (cacheEntry === undefined) {\n            cacheEntry = {};\n            cache.set(chunks, cacheEntry);\n          } else if (cacheGroup in cacheEntry) {\n            return cacheEntry[cacheGroup];\n          }\n\n          var names = chunks.map(function (c) {\n            return c.name;\n          });\n\n          if (!names.every(Boolean)) {\n            cacheEntry[cacheGroup] = undefined;\n            return;\n          }\n\n          names.sort();\n          var prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n          var namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n          var name = namePrefix + names.join(automaticNameDelimiter); // Filenames and paths can't be too long otherwise an\n          // ENAMETOOLONG error is raised. If the generated name if too\n          // long, it is truncated and a hash is appended. The limit has\n          // been set to 100 to prevent `[name].[chunkhash].[ext]` from\n          // generating a 256+ character string.\n\n          if (name.length > 100) {\n            name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n          }\n\n          cacheEntry[cacheGroup] = name;\n          return name;\n        };\n\n        return fn;\n      }\n\n      if (typeof name === \"string\") {\n        var _fn = function _fn() {\n          return name;\n        };\n\n        return _fn;\n      }\n\n      if (typeof name === \"function\") return name;\n    }\n  }, {\n    key: \"normalizeChunksFilter\",\n    value: function normalizeChunksFilter(chunks) {\n      if (chunks === \"initial\") {\n        return INITIAL_CHUNK_FILTER;\n      }\n\n      if (chunks === \"async\") {\n        return ASYNC_CHUNK_FILTER;\n      }\n\n      if (chunks === \"all\") {\n        return ALL_CHUNK_FILTER;\n      }\n\n      if (typeof chunks === \"function\") return chunks;\n    }\n  }, {\n    key: \"normalizeFallbackCacheGroup\",\n    value: function normalizeFallbackCacheGroup(_ref3, _ref4) {\n      var _ref3$minSize = _ref3.minSize,\n          minSize = _ref3$minSize === void 0 ? undefined : _ref3$minSize,\n          _ref3$maxSize = _ref3.maxSize,\n          maxSize = _ref3$maxSize === void 0 ? undefined : _ref3$maxSize,\n          _ref3$automaticNameDe = _ref3.automaticNameDelimiter,\n          automaticNameDelimiter = _ref3$automaticNameDe === void 0 ? undefined : _ref3$automaticNameDe;\n      var _ref4$minSize = _ref4.minSize,\n          defaultMinSize = _ref4$minSize === void 0 ? undefined : _ref4$minSize,\n          _ref4$maxSize = _ref4.maxSize,\n          defaultMaxSize = _ref4$maxSize === void 0 ? undefined : _ref4$maxSize,\n          _ref4$automaticNameDe = _ref4.automaticNameDelimiter,\n          defaultAutomaticNameDelimiter = _ref4$automaticNameDe === void 0 ? undefined : _ref4$automaticNameDe;\n      return {\n        minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n        maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n        automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n      };\n    }\n  }, {\n    key: \"normalizeCacheGroups\",\n    value: function normalizeCacheGroups(_ref5) {\n      var cacheGroups = _ref5.cacheGroups,\n          name = _ref5.name,\n          automaticNameDelimiter = _ref5.automaticNameDelimiter;\n\n      if (typeof cacheGroups === \"function\") {\n        // TODO webpack 5 remove this\n        if (cacheGroups.length !== 1) {\n          return function (module) {\n            return cacheGroups(module, module.getChunks());\n          };\n        }\n\n        return cacheGroups;\n      }\n\n      if (cacheGroups && typeof cacheGroups === \"object\") {\n        var _fn2 = function _fn2(module) {\n          var results;\n\n          var _arr = Object.keys(cacheGroups);\n\n          for (var _i = 0; _i < _arr.length; _i++) {\n            var key = _arr[_i];\n            var option = cacheGroups[key];\n            if (option === false) continue;\n\n            if (option instanceof RegExp || typeof option === \"string\") {\n              option = {\n                test: option\n              };\n            }\n\n            if (typeof option === \"function\") {\n              var result = option(module);\n\n              if (result) {\n                if (results === undefined) results = [];\n                var _iteratorNormalCompletion29 = true;\n                var _didIteratorError29 = false;\n                var _iteratorError29 = undefined;\n\n                try {\n                  var _loop3 = function _loop3() {\n                    var r = _step29.value;\n                    var result = Object.assign({\n                      key: key\n                    }, r);\n                    if (result.name) result.getName = function () {\n                      return result.name;\n                    };\n\n                    if (result.chunks) {\n                      result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                    }\n\n                    results.push(result);\n                  };\n\n                  for (var _iterator29 = (Array.isArray(result) ? result : [result])[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {\n                    _loop3();\n                  }\n                } catch (err) {\n                  _didIteratorError29 = true;\n                  _iteratorError29 = err;\n                } finally {\n                  try {\n                    if (!_iteratorNormalCompletion29 && _iterator29.return != null) {\n                      _iterator29.return();\n                    }\n                  } finally {\n                    if (_didIteratorError29) {\n                      throw _iteratorError29;\n                    }\n                  }\n                }\n              }\n            } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n              if (results === undefined) results = [];\n              results.push({\n                key: key,\n                priority: option.priority,\n                getName: SplitChunksPlugin.normalizeName({\n                  name: option.name || name,\n                  automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                  automaticNamePrefix: option.automaticNamePrefix\n                }) || function () {},\n                chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n                enforce: option.enforce,\n                minSize: option.minSize,\n                maxSize: option.maxSize,\n                minChunks: option.minChunks,\n                maxAsyncRequests: option.maxAsyncRequests,\n                maxInitialRequests: option.maxInitialRequests,\n                filename: option.filename,\n                reuseExistingChunk: option.reuseExistingChunk\n              });\n            }\n          }\n\n          return results;\n        };\n\n        return _fn2;\n      }\n\n      var fn = function fn() {};\n\n      return fn;\n    }\n  }, {\n    key: \"checkTest\",\n    value: function checkTest(test, module) {\n      if (test === undefined) return true;\n\n      if (typeof test === \"function\") {\n        if (test.length !== 1) {\n          return test(module, module.getChunks());\n        }\n\n        return test(module);\n      }\n\n      if (typeof test === \"boolean\") return test;\n\n      if (typeof test === \"string\") {\n        if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n          return true;\n        }\n\n        var _iteratorNormalCompletion30 = true;\n        var _didIteratorError30 = false;\n        var _iteratorError30 = undefined;\n\n        try {\n          for (var _iterator30 = module.chunksIterable[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {\n            var chunk = _step30.value;\n\n            if (chunk.name && chunk.name.startsWith(test)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError30 = true;\n          _iteratorError30 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion30 && _iterator30.return != null) {\n              _iterator30.return();\n            }\n          } finally {\n            if (_didIteratorError30) {\n              throw _iteratorError30;\n            }\n          }\n        }\n\n        return false;\n      }\n\n      if (test instanceof RegExp) {\n        if (module.nameForCondition && test.test(module.nameForCondition())) {\n          return true;\n        }\n\n        var _iteratorNormalCompletion31 = true;\n        var _didIteratorError31 = false;\n        var _iteratorError31 = undefined;\n\n        try {\n          for (var _iterator31 = module.chunksIterable[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {\n            var _chunk5 = _step31.value;\n\n            if (_chunk5.name && test.test(_chunk5.name)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError31 = true;\n          _iteratorError31 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion31 && _iterator31.return != null) {\n              _iterator31.return();\n            }\n          } finally {\n            if (_didIteratorError31) {\n              throw _iteratorError31;\n            }\n          }\n        }\n\n        return false;\n      }\n\n      return false;\n    }\n  }]);\n\n  return SplitChunksPlugin;\n}();","map":null,"metadata":{},"sourceType":"script"}