{"ast":null,"code":"module.exports = collect;\n\nfunction collect(stream) {\n  if (stream._collected) return;\n  if (stream._paused) return stream.on('resume', collect.bind(null, stream));\n  stream._collected = true;\n  stream.pause();\n  stream.on('data', save);\n  stream.on('end', save);\n  var buf = [];\n\n  function save(b) {\n    if (typeof b === 'string') b = new Buffer(b);\n    if (Buffer.isBuffer(b) && !b.length) return;\n    buf.push(b);\n  }\n\n  stream.on('entry', saveEntry);\n  var entryBuffer = [];\n\n  function saveEntry(e) {\n    collect(e);\n    entryBuffer.push(e);\n  }\n\n  stream.on('proxy', proxyPause);\n\n  function proxyPause(p) {\n    p.pause();\n  } // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n\n\n  stream.pipe = function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0;\n\n      (function unblockEntry() {\n        var entry = entryBuffer[e++]; // console.error(\" ==== unblock entry\", entry && entry.path)\n\n        if (!entry) return resume();\n        entry.on('end', unblockEntry);\n        if (dest) dest.add(entry);else stream.emit('entry', entry);\n      })();\n\n      function resume() {\n        stream.removeListener('entry', saveEntry);\n        stream.removeListener('data', save);\n        stream.removeListener('end', save);\n        stream.pipe = orig;\n        if (dest) stream.pipe(dest);\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b);else stream.emit('end');\n        });\n        stream.resume();\n      }\n\n      return dest;\n    };\n  }(stream.pipe);\n}","map":null,"metadata":{},"sourceType":"script"}