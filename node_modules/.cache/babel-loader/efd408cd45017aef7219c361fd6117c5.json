{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar parseJson = require(\"json-parse-better-errors\");\n\nvar asyncLib = require(\"neo-async\");\n\nvar path = require(\"path\");\n\nvar util = require(\"util\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    SyncHook = _require.SyncHook,\n    SyncBailHook = _require.SyncBailHook,\n    AsyncParallelHook = _require.AsyncParallelHook,\n    AsyncSeriesHook = _require.AsyncSeriesHook;\n\nvar Compilation = require(\"./Compilation\");\n\nvar Stats = require(\"./Stats\");\n\nvar Watching = require(\"./Watching\");\n\nvar NormalModuleFactory = require(\"./NormalModuleFactory\");\n\nvar ContextModuleFactory = require(\"./ContextModuleFactory\");\n\nvar ResolverFactory = require(\"./ResolverFactory\");\n\nvar RequestShortener = require(\"./RequestShortener\");\n\nvar _require2 = require(\"./util/identifier\"),\n    makePathsRelative = _require2.makePathsRelative;\n\nvar ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n/** @typedef {import(\"../declarations/WebpackOptions\").Entry} Entry */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptions} WebpackOptions */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n * @property {Set<string>} compilationDependencies\n */\n\n\nvar Compiler =\n/*#__PURE__*/\nfunction (_Tapable) {\n  _inherits(Compiler, _Tapable);\n\n  function Compiler(context) {\n    var _this;\n\n    _classCallCheck(this, Compiler);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Compiler).call(this));\n    _this.hooks = {\n      /** @type {SyncBailHook<Compilation>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Stats>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n\n      /** @type {AsyncSeriesHook<>} */\n      additionalPass: new AsyncSeriesHook([]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n\n      /** @type {SyncHook<NormalModuleFactory>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\n      /** @type {SyncHook<ContextModuleFactory>}  */\n      contextModuleFactory: new SyncHook([\"contextModulefactory\"]),\n\n      /** @type {AsyncSeriesHook<CompilationParams>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n\n      /** @type {SyncHook<CompilationParams>} */\n      compile: new SyncHook([\"params\"]),\n\n      /** @type {AsyncParallelHook<Compilation>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n      /** @type {AsyncSeriesHook<Compiler>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n\n      /** @type {SyncHook<Error>} */\n      failed: new SyncHook([\"error\"]),\n\n      /** @type {SyncHook<string, string>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n\n      /** @type {SyncHook} */\n      watchClose: new SyncHook([]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n\n      /** @type {SyncHook} */\n      environment: new SyncHook([]),\n\n      /** @type {SyncHook} */\n      afterEnvironment: new SyncHook([]),\n\n      /** @type {SyncHook<Compiler>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncHook<Compiler>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n\n      /** @type {SyncBailHook<string, Entry>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    };\n\n    _this._pluginCompat.tap(\"Compiler\", function (options) {\n      switch (options.name) {\n        case \"additional-pass\":\n        case \"before-run\":\n        case \"run\":\n        case \"emit\":\n        case \"after-emit\":\n        case \"before-compile\":\n        case \"make\":\n        case \"after-compile\":\n        case \"watch-run\":\n          options.async = true;\n          break;\n      }\n    });\n    /** @type {string=} */\n\n\n    _this.name = undefined;\n    /** @type {Compilation=} */\n\n    _this.parentCompilation = undefined;\n    /** @type {string} */\n\n    _this.outputPath = \"\";\n    _this.outputFileSystem = null;\n    _this.inputFileSystem = null;\n    /** @type {string|null} */\n\n    _this.recordsInputPath = null;\n    /** @type {string|null} */\n\n    _this.recordsOutputPath = null;\n    _this.records = {};\n    _this.removedFiles = new Set();\n    /** @type {Map<string, number>} */\n\n    _this.fileTimestamps = new Map();\n    /** @type {Map<string, number>} */\n\n    _this.contextTimestamps = new Map();\n    /** @type {ResolverFactory} */\n\n    _this.resolverFactory = new ResolverFactory(); // TODO remove in webpack 5\n\n    _this.resolvers = {\n      normal: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver normal\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this.resolverFactory.plugin(\"resolver normal\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      loader: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver loader\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          _this.resolverFactory.plugin(\"resolver loader\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      context: {\n        plugins: util.deprecate(function (hook, fn) {\n          _this.resolverFactory.plugin(\"resolver context\", function (resolver) {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate(function () {\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n\n          _this.resolverFactory.plugin(\"resolver context\", function (resolver) {\n            resolver.apply.apply(resolver, args);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      }\n    };\n    /** @type {WebpackOptions} */\n\n    _this.options =\n    /** @type {WebpackOptions} */\n    {};\n    _this.context = context;\n    _this.requestShortener = new RequestShortener(context);\n    /** @type {boolean} */\n\n    _this.running = false;\n    /** @type {boolean} */\n\n    _this.watchMode = false;\n    return _this;\n  }\n\n  _createClass(Compiler, [{\n    key: \"watch\",\n    value: function watch(watchOptions, handler) {\n      if (this.running) return handler(new ConcurrentCompilationError());\n      this.running = true;\n      this.watchMode = true;\n      this.fileTimestamps = new Map();\n      this.contextTimestamps = new Map();\n      this.removedFiles = new Set();\n      return new Watching(this, watchOptions, handler);\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var _this2 = this;\n\n      if (this.running) return callback(new ConcurrentCompilationError());\n\n      var finalCallback = function finalCallback(err, stats) {\n        _this2.running = false;\n        if (callback !== undefined) return callback(err, stats);\n      };\n\n      var startTime = Date.now();\n      this.running = true;\n\n      var onCompiled = function onCompiled(err, compilation) {\n        if (err) return finalCallback(err);\n\n        if (_this2.hooks.shouldEmit.call(compilation) === false) {\n          var stats = new Stats(compilation);\n          stats.startTime = startTime;\n          stats.endTime = Date.now();\n\n          _this2.hooks.done.callAsync(stats, function (err) {\n            if (err) return finalCallback(err);\n            return finalCallback(null, stats);\n          });\n\n          return;\n        }\n\n        _this2.emitAssets(compilation, function (err) {\n          if (err) return finalCallback(err);\n\n          if (compilation.hooks.needAdditionalPass.call()) {\n            compilation.needAdditionalPass = true;\n\n            var _stats = new Stats(compilation);\n\n            _stats.startTime = startTime;\n            _stats.endTime = Date.now();\n\n            _this2.hooks.done.callAsync(_stats, function (err) {\n              if (err) return finalCallback(err);\n\n              _this2.hooks.additionalPass.callAsync(function (err) {\n                if (err) return finalCallback(err);\n\n                _this2.compile(onCompiled);\n              });\n            });\n\n            return;\n          }\n\n          _this2.emitRecords(function (err) {\n            if (err) return finalCallback(err);\n            var stats = new Stats(compilation);\n            stats.startTime = startTime;\n            stats.endTime = Date.now();\n\n            _this2.hooks.done.callAsync(stats, function (err) {\n              if (err) return finalCallback(err);\n              return finalCallback(null, stats);\n            });\n          });\n        });\n      };\n\n      this.hooks.beforeRun.callAsync(this, function (err) {\n        if (err) return finalCallback(err);\n\n        _this2.hooks.run.callAsync(_this2, function (err) {\n          if (err) return finalCallback(err);\n\n          _this2.readRecords(function (err) {\n            if (err) return finalCallback(err);\n\n            _this2.compile(onCompiled);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"runAsChild\",\n    value: function runAsChild(callback) {\n      var _this3 = this;\n\n      this.compile(function (err, compilation) {\n        if (err) return callback(err);\n\n        _this3.parentCompilation.children.push(compilation);\n\n        var _arr = Object.keys(compilation.assets);\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var name = _arr[_i];\n          _this3.parentCompilation.assets[name] = compilation.assets[name];\n        }\n\n        var entries = Array.from(compilation.entrypoints.values(), function (ep) {\n          return ep.chunks;\n        }).reduce(function (array, chunks) {\n          return array.concat(chunks);\n        }, []);\n        return callback(null, entries, compilation);\n      });\n    }\n  }, {\n    key: \"purgeInputFileSystem\",\n    value: function purgeInputFileSystem() {\n      if (this.inputFileSystem && this.inputFileSystem.purge) {\n        this.inputFileSystem.purge();\n      }\n    }\n  }, {\n    key: \"emitAssets\",\n    value: function emitAssets(compilation, callback) {\n      var _this4 = this;\n\n      var outputPath;\n\n      var emitFiles = function emitFiles(err) {\n        if (err) return callback(err);\n        asyncLib.forEach(compilation.assets, function (source, file, callback) {\n          var targetFile = file;\n          var queryStringIdx = targetFile.indexOf(\"?\");\n\n          if (queryStringIdx >= 0) {\n            targetFile = targetFile.substr(0, queryStringIdx);\n          }\n\n          var writeOut = function writeOut(err) {\n            if (err) return callback(err);\n\n            var targetPath = _this4.outputFileSystem.join(outputPath, targetFile);\n\n            if (source.existsAt === targetPath) {\n              source.emitted = false;\n              return callback();\n            }\n\n            var content = source.source();\n\n            if (!Buffer.isBuffer(content)) {\n              content = Buffer.from(content, \"utf8\");\n            }\n\n            source.existsAt = targetPath;\n            source.emitted = true;\n\n            _this4.outputFileSystem.writeFile(targetPath, content, callback);\n          };\n\n          if (targetFile.match(/\\/|\\\\/)) {\n            var dir = path.dirname(targetFile);\n\n            _this4.outputFileSystem.mkdirp(_this4.outputFileSystem.join(outputPath, dir), writeOut);\n          } else {\n            writeOut();\n          }\n        }, function (err) {\n          if (err) return callback(err);\n\n          _this4.hooks.afterEmit.callAsync(compilation, function (err) {\n            if (err) return callback(err);\n            return callback();\n          });\n        });\n      };\n\n      this.hooks.emit.callAsync(compilation, function (err) {\n        if (err) return callback(err);\n        outputPath = compilation.getPath(_this4.outputPath);\n\n        _this4.outputFileSystem.mkdirp(outputPath, emitFiles);\n      });\n    }\n  }, {\n    key: \"emitRecords\",\n    value: function emitRecords(callback) {\n      var _this5 = this;\n\n      if (!this.recordsOutputPath) return callback();\n      var idx1 = this.recordsOutputPath.lastIndexOf(\"/\");\n      var idx2 = this.recordsOutputPath.lastIndexOf(\"\\\\\");\n      var recordsOutputPathDirectory = null;\n\n      if (idx1 > idx2) {\n        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);\n      } else if (idx1 < idx2) {\n        recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);\n      }\n\n      var writeFile = function writeFile() {\n        _this5.outputFileSystem.writeFile(_this5.recordsOutputPath, JSON.stringify(_this5.records, undefined, 2), callback);\n      };\n\n      if (!recordsOutputPathDirectory) {\n        return writeFile();\n      }\n\n      this.outputFileSystem.mkdirp(recordsOutputPathDirectory, function (err) {\n        if (err) return callback(err);\n        writeFile();\n      });\n    }\n  }, {\n    key: \"readRecords\",\n    value: function readRecords(callback) {\n      var _this6 = this;\n\n      if (!this.recordsInputPath) {\n        this.records = {};\n        return callback();\n      }\n\n      this.inputFileSystem.stat(this.recordsInputPath, function (err) {\n        // It doesn't exist\n        // We can ignore this.\n        if (err) return callback();\n\n        _this6.inputFileSystem.readFile(_this6.recordsInputPath, function (err, content) {\n          if (err) return callback(err);\n\n          try {\n            _this6.records = parseJson(content.toString(\"utf-8\"));\n          } catch (e) {\n            e.message = \"Cannot parse records: \" + e.message;\n            return callback(e);\n          }\n\n          return callback();\n        });\n      });\n    }\n  }, {\n    key: \"createChildCompiler\",\n    value: function createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n      var childCompiler = new Compiler(this.context);\n\n      if (Array.isArray(plugins)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var plugin = _step.value;\n            plugin.apply(childCompiler);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      for (var name in this.hooks) {\n        if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n          if (childCompiler.hooks[name]) {\n            childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n          }\n        }\n      }\n\n      childCompiler.name = compilerName;\n      childCompiler.outputPath = this.outputPath;\n      childCompiler.inputFileSystem = this.inputFileSystem;\n      childCompiler.outputFileSystem = null;\n      childCompiler.resolverFactory = this.resolverFactory;\n      childCompiler.fileTimestamps = this.fileTimestamps;\n      childCompiler.contextTimestamps = this.contextTimestamps;\n      var relativeCompilerName = makePathsRelative(this.context, compilerName);\n\n      if (!this.records[relativeCompilerName]) {\n        this.records[relativeCompilerName] = [];\n      }\n\n      if (this.records[relativeCompilerName][compilerIndex]) {\n        childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n      } else {\n        this.records[relativeCompilerName].push(childCompiler.records = {});\n      }\n\n      childCompiler.options = Object.create(this.options);\n      childCompiler.options.output = Object.create(childCompiler.options.output);\n\n      for (var _name in outputOptions) {\n        childCompiler.options.output[_name] = outputOptions[_name];\n      }\n\n      childCompiler.parentCompilation = compilation;\n      compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n      return childCompiler;\n    }\n  }, {\n    key: \"isChild\",\n    value: function isChild() {\n      return !!this.parentCompilation;\n    }\n  }, {\n    key: \"createCompilation\",\n    value: function createCompilation() {\n      return new Compilation(this);\n    }\n  }, {\n    key: \"newCompilation\",\n    value: function newCompilation(params) {\n      var compilation = this.createCompilation();\n      compilation.fileTimestamps = this.fileTimestamps;\n      compilation.contextTimestamps = this.contextTimestamps;\n      compilation.name = this.name;\n      compilation.records = this.records;\n      compilation.compilationDependencies = params.compilationDependencies;\n      this.hooks.thisCompilation.call(compilation, params);\n      this.hooks.compilation.call(compilation, params);\n      return compilation;\n    }\n  }, {\n    key: \"createNormalModuleFactory\",\n    value: function createNormalModuleFactory() {\n      var normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolverFactory, this.options.module || {});\n      this.hooks.normalModuleFactory.call(normalModuleFactory);\n      return normalModuleFactory;\n    }\n  }, {\n    key: \"createContextModuleFactory\",\n    value: function createContextModuleFactory() {\n      var contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n      this.hooks.contextModuleFactory.call(contextModuleFactory);\n      return contextModuleFactory;\n    }\n  }, {\n    key: \"newCompilationParams\",\n    value: function newCompilationParams() {\n      var params = {\n        normalModuleFactory: this.createNormalModuleFactory(),\n        contextModuleFactory: this.createContextModuleFactory(),\n        compilationDependencies: new Set()\n      };\n      return params;\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(callback) {\n      var _this7 = this;\n\n      var params = this.newCompilationParams();\n      this.hooks.beforeCompile.callAsync(params, function (err) {\n        if (err) return callback(err);\n\n        _this7.hooks.compile.call(params);\n\n        var compilation = _this7.newCompilation(params);\n\n        _this7.hooks.make.callAsync(compilation, function (err) {\n          if (err) return callback(err);\n          compilation.finish();\n          compilation.seal(function (err) {\n            if (err) return callback(err);\n\n            _this7.hooks.afterCompile.callAsync(compilation, function (err) {\n              if (err) return callback(err);\n              return callback(null, compilation);\n            });\n          });\n        });\n      });\n    }\n  }]);\n\n  return Compiler;\n}(Tapable);\n\nmodule.exports = Compiler;","map":null,"metadata":{},"sourceType":"script"}