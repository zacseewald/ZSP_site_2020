{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n    REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n    REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n    REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n    REGEXP_NAME = /\\[name\\]/gi,\n    REGEXP_ID = /\\[id\\]/gi,\n    REGEXP_MODULEID = /\\[moduleid\\]/gi,\n    REGEXP_FILE = /\\[file\\]/gi,\n    REGEXP_QUERY = /\\[query\\]/gi,\n    REGEXP_FILEBASE = /\\[filebase\\]/gi; // Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\n\nvar REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n    REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n    REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n    REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nvar withHashLength = function withHashLength(replacer, handlerFn) {\n  var fn = function fn(match, hashLength) {\n    var length = hashLength && parseInt(hashLength, 10);\n\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var hash = replacer.apply(void 0, [match, hashLength].concat(args));\n    return length ? hash.slice(0, length) : hash;\n  };\n\n  return fn;\n};\n\nvar getReplacer = function getReplacer(value, allowEmpty) {\n  var fn = function fn(match) {\n    var _ref;\n\n    // last argument in replacer is the entire input string\n    var input = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);\n\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(\"Path variable \".concat(match, \" not implemented in this context: \").concat(input));\n      }\n\n      return \"\";\n    } else {\n      return \"\".concat(value);\n    }\n  };\n\n  return fn;\n};\n\nvar replacePathVariables = function replacePathVariables(path, data) {\n  var chunk = data.chunk;\n  var chunkId = chunk && chunk.id;\n  var chunkName = chunk && (chunk.name || chunk.id);\n  var chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  var chunkHashWithLength = chunk && chunk.hashWithLength;\n  var contentHashType = data.contentHashType;\n  var contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  var contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  var module = data.module;\n  var moduleId = module && module.id;\n  var moduleHash = module && (module.renderedHash || module.hash);\n  var moduleHashWithLength = module && module.hashWithLength;\n\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(\"Cannot use [chunkhash] or [contenthash] for chunk in '\".concat(path, \"' (use [hash] instead)\"));\n  }\n\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename)) // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true));\n};\n\nvar TemplatedPathPlugin =\n/*#__PURE__*/\nfunction () {\n  function TemplatedPathPlugin() {\n    _classCallCheck(this, TemplatedPathPlugin);\n  }\n\n  _createClass(TemplatedPathPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", function (compilation) {\n        var mainTemplate = compilation.mainTemplate;\n        mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n        mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", function (chunk, paths) {\n          var outputOptions = mainTemplate.outputOptions;\n          var publicPath = outputOptions.publicPath || \"\";\n          var filename = outputOptions.filename || \"\";\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n          if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n        });\n        mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", function (hash, chunk) {\n          var outputOptions = mainTemplate.outputOptions;\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n\n          if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n          }\n\n          if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n          }\n\n          if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n          }\n        });\n      });\n    }\n  }]);\n\n  return TemplatedPathPlugin;\n}();\n\nmodule.exports = TemplatedPathPlugin;","map":null,"metadata":{},"sourceType":"script"}