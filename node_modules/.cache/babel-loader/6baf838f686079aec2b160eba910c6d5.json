{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar util = require(\"util\");\n\nvar DependenciesBlock = require(\"./DependenciesBlock\");\n\nvar ModuleReason = require(\"./ModuleReason\");\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar Template = require(\"./Template\");\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n\nvar EMPTY_RESOLVE_OPTIONS = {};\nvar debugId = 1000;\n\nvar sortById = function sortById(a, b) {\n  return a.id - b.id;\n};\n\nvar sortByDebugId = function sortByDebugId(a, b) {\n  return a.debugId - b.debugId;\n};\n/** @typedef {(requestShortener: RequestShortener) => string} OptimizationBailoutFunction */\n\n\nvar Module =\n/*#__PURE__*/\nfunction (_DependenciesBlock) {\n  _inherits(Module, _DependenciesBlock);\n\n  function Module(type) {\n    var _this;\n\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, Module);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Module).call(this));\n    /** @type {string} */\n\n    _this.type = type;\n    /** @type {string} */\n\n    _this.context = context; // Unique Id\n\n    /** @type {number} */\n\n    _this.debugId = debugId++; // Hash\n\n    /** @type {string} */\n\n    _this.hash = undefined;\n    /** @type {string} */\n\n    _this.renderedHash = undefined; // Info from Factory\n\n    /** @type {TODO} */\n\n    _this.resolveOptions = EMPTY_RESOLVE_OPTIONS;\n    /** @type {object} */\n\n    _this.factoryMeta = {}; // Info from Build\n\n    /** @type {WebpackError[]} */\n\n    _this.warnings = [];\n    /** @type {WebpackError[]} */\n\n    _this.errors = [];\n    /** @type {object} */\n\n    _this.buildMeta = undefined;\n    /** @type {object} */\n\n    _this.buildInfo = undefined; // Graph (per Compilation)\n\n    /** @type {ModuleReason[]} */\n\n    _this.reasons = [];\n    /** @type {SortableSet<Chunk>} */\n\n    _this._chunks = new SortableSet(undefined, sortById); // Info from Compilation (per Compilation)\n\n    /** @type {number|string} */\n\n    _this.id = null;\n    /** @type {number} */\n\n    _this.index = null;\n    /** @type {number} */\n\n    _this.index2 = null;\n    /** @type {number} */\n\n    _this.depth = null;\n    /** @type {Module} */\n\n    _this.issuer = null;\n    /** @type {undefined | object} */\n\n    _this.profile = undefined;\n    /** @type {boolean} */\n\n    _this.prefetched = false;\n    /** @type {boolean} */\n\n    _this.built = false; // Info from Optimization (per Compilation)\n\n    /** @type {null | boolean} */\n\n    _this.used = null;\n    /** @type {false | true | string[]} */\n\n    _this.usedExports = null;\n    /** @type {(string | OptimizationBailoutFunction)[]} */\n\n    _this.optimizationBailout = []; // delayed operations\n\n    /** @type {undefined | {oldChunk: Chunk, newChunks: Chunk[]}[] } */\n\n    _this._rewriteChunkInReasons = undefined;\n    /** @type {boolean} */\n\n    _this.useSourceMap = false; // info from build\n\n    _this._source = null;\n    return _this;\n  }\n\n  _createClass(Module, [{\n    key: \"disconnect\",\n    value: function disconnect() {\n      this.hash = undefined;\n      this.renderedHash = undefined;\n      this.reasons.length = 0;\n      this._rewriteChunkInReasons = undefined;\n\n      this._chunks.clear();\n\n      this.id = null;\n      this.index = null;\n      this.index2 = null;\n      this.depth = null;\n      this.issuer = null;\n      this.profile = undefined;\n      this.prefetched = false;\n      this.built = false;\n      this.used = null;\n      this.usedExports = null;\n      this.optimizationBailout.length = 0;\n\n      _get(_getPrototypeOf(Module.prototype), \"disconnect\", this).call(this);\n    }\n  }, {\n    key: \"unseal\",\n    value: function unseal() {\n      this.id = null;\n      this.index = null;\n      this.index2 = null;\n      this.depth = null;\n\n      this._chunks.clear();\n\n      _get(_getPrototypeOf(Module.prototype), \"unseal\", this).call(this);\n    }\n  }, {\n    key: \"setChunks\",\n    value: function setChunks(chunks) {\n      this._chunks = new SortableSet(chunks, sortById);\n    }\n  }, {\n    key: \"addChunk\",\n    value: function addChunk(chunk) {\n      if (this._chunks.has(chunk)) return false;\n\n      this._chunks.add(chunk);\n\n      return true;\n    }\n  }, {\n    key: \"removeChunk\",\n    value: function removeChunk(chunk) {\n      if (this._chunks.delete(chunk)) {\n        chunk.removeModule(this);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isInChunk\",\n    value: function isInChunk(chunk) {\n      return this._chunks.has(chunk);\n    }\n  }, {\n    key: \"isEntryModule\",\n    value: function isEntryModule() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var chunk = _step.value;\n          if (chunk.entryModule === this) return true;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getChunks\",\n\n    /**\n     * @returns {Chunk[]} all chunks which contain the module\n     */\n    value: function getChunks() {\n      return Array.from(this._chunks);\n    }\n  }, {\n    key: \"getNumberOfChunks\",\n    value: function getNumberOfChunks() {\n      return this._chunks.size;\n    }\n  }, {\n    key: \"hasEqualsChunks\",\n    value: function hasEqualsChunks(otherModule) {\n      if (this._chunks.size !== otherModule._chunks.size) return false;\n\n      this._chunks.sortWith(sortByDebugId);\n\n      otherModule._chunks.sortWith(sortByDebugId);\n\n      var a = this._chunks[Symbol.iterator]();\n\n      var b = otherModule._chunks[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n\n      while (true) {\n        var aItem = a.next();\n        var bItem = b.next();\n        if (aItem.done) return true;\n        if (aItem.value !== bItem.value) return false;\n      }\n    }\n  }, {\n    key: \"addReason\",\n    value: function addReason(module, dependency, explanation) {\n      this.reasons.push(new ModuleReason(module, dependency, explanation));\n    }\n  }, {\n    key: \"removeReason\",\n    value: function removeReason(module, dependency) {\n      for (var i = 0; i < this.reasons.length; i++) {\n        var r = this.reasons[i];\n\n        if (r.module === module && r.dependency === dependency) {\n          this.reasons.splice(i, 1);\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasReasonForChunk\",\n    value: function hasReasonForChunk(chunk) {\n      if (this._rewriteChunkInReasons) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this._rewriteChunkInReasons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var operation = _step2.value;\n\n            this._doRewriteChunkInReasons(operation.oldChunk, operation.newChunks);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        this._rewriteChunkInReasons = undefined;\n      }\n\n      for (var i = 0; i < this.reasons.length; i++) {\n        if (this.reasons[i].hasChunk(chunk)) return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasReasons\",\n    value: function hasReasons() {\n      return this.reasons.length > 0;\n    }\n  }, {\n    key: \"rewriteChunkInReasons\",\n    value: function rewriteChunkInReasons(oldChunk, newChunks) {\n      // This is expensive. Delay operation until we really need the data\n      if (this._rewriteChunkInReasons === undefined) {\n        this._rewriteChunkInReasons = [];\n      }\n\n      this._rewriteChunkInReasons.push({\n        oldChunk: oldChunk,\n        newChunks: newChunks\n      });\n    }\n  }, {\n    key: \"_doRewriteChunkInReasons\",\n    value: function _doRewriteChunkInReasons(oldChunk, newChunks) {\n      for (var i = 0; i < this.reasons.length; i++) {\n        this.reasons[i].rewriteChunks(oldChunk, newChunks);\n      }\n    }\n    /**\n     * @param {string=} exportName the name of the export\n     * @returns {boolean|string} false if the export isn't used, true if no exportName is provided and the module is used, or the name to access it if the export is used\n     */\n\n  }, {\n    key: \"isUsed\",\n    value: function isUsed(exportName) {\n      if (!exportName) return this.used !== false;\n      if (this.used === null || this.usedExports === null) return exportName;\n      if (!this.used) return false;\n      if (!this.usedExports) return false;\n      if (this.usedExports === true) return exportName;\n      var idx = this.usedExports.indexOf(exportName);\n      if (idx < 0) return false; // Mangle export name if possible\n\n      if (this.isProvided(exportName)) {\n        if (this.buildMeta.exportsType === \"namespace\") {\n          return Template.numberToIdentifer(idx);\n        }\n\n        if (this.buildMeta.exportsType === \"named\" && !this.usedExports.includes(\"default\")) {\n          return Template.numberToIdentifer(idx);\n        }\n      }\n\n      return exportName;\n    }\n  }, {\n    key: \"isProvided\",\n    value: function isProvided(exportName) {\n      if (!Array.isArray(this.buildMeta.providedExports)) return null;\n      return this.buildMeta.providedExports.includes(exportName);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Module[\".concat(this.id || this.debugId, \"]\");\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      return true;\n    }\n    /**\n     * @param {Hash} hash the hash used to track dependencies\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"\".concat(this.id));\n      hash.update(JSON.stringify(this.usedExports));\n\n      _get(_getPrototypeOf(Module.prototype), \"updateHash\", this).call(this, hash);\n    }\n  }, {\n    key: \"sortItems\",\n    value: function sortItems(sortChunks) {\n      _get(_getPrototypeOf(Module.prototype), \"sortItems\", this).call(this);\n\n      if (sortChunks) this._chunks.sort();\n      this.reasons.sort(function (a, b) {\n        if (a.module === b.module) return 0;\n        if (!a.module) return -1;\n        if (!b.module) return 1;\n        return sortById(a.module, b.module);\n      });\n\n      if (Array.isArray(this.usedExports)) {\n        this.usedExports.sort();\n      }\n    }\n  }, {\n    key: \"unbuild\",\n    value: function unbuild() {\n      this.dependencies.length = 0;\n      this.blocks.length = 0;\n      this.variables.length = 0;\n      this.buildMeta = undefined;\n      this.buildInfo = undefined;\n      this.disconnect();\n    }\n  }, {\n    key: \"exportsArgument\",\n    get: function get() {\n      return this.buildInfo && this.buildInfo.exportsArgument || \"exports\";\n    }\n  }, {\n    key: \"moduleArgument\",\n    get: function get() {\n      return this.buildInfo && this.buildInfo.moduleArgument || \"module\";\n    }\n  }, {\n    key: \"optional\",\n    get: function get() {\n      return this.reasons.length > 0 && this.reasons.every(function (r) {\n        return r.dependency && r.dependency.optional;\n      });\n    }\n  }, {\n    key: \"chunksIterable\",\n    get: function get() {\n      return this._chunks;\n    }\n  }, {\n    key: \"arguments\",\n    get: function get() {\n      throw new Error(\"Module.arguments was removed, there is no replacement.\");\n    },\n    set: function set(value) {\n      throw new Error(\"Module.arguments was removed, there is no replacement.\");\n    }\n  }]);\n\n  return Module;\n}(DependenciesBlock); // TODO remove in webpack 5\n\n\nObject.defineProperty(Module.prototype, \"forEachChunk\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any, Set<any>): void} fn callback function\n   * @returns {void}\n   * @this {Module}\n   */\n  function (fn) {\n    this._chunks.forEach(fn);\n  }, \"Module.forEachChunk: Use for(const chunk of module.chunksIterable) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Module.prototype, \"mapChunks\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any): void} fn Mapper function\n   * @returns {Array<TODO>} Array of chunks mapped\n   * @this {Module}\n   */\n  function (fn) {\n    return Array.from(this._chunks, fn);\n  }, \"Module.mapChunks: Use Array.from(module.chunksIterable, fn) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Module.prototype, \"entry\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  },\n  set: function set() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Module.prototype, \"meta\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @returns {void}\n   * @this {Module}\n   */\n  function () {\n    return this.buildMeta;\n  }, \"Module.meta was renamed to Module.buildMeta\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} value Value\n   * @returns {void}\n   * @this {Module}\n   */\n  function (value) {\n    this.buildMeta = value;\n  }, \"Module.meta was renamed to Module.buildMeta\")\n});\n/** @type {function(): string} */\n\nModule.prototype.identifier = null;\n/** @type {function(RequestShortener): string} */\n\nModule.prototype.readableIdentifier = null;\nModule.prototype.build = null;\nModule.prototype.source = null;\nModule.prototype.size = null;\nModule.prototype.nameForCondition = null;\n/** @type {null | function(Chunk): boolean} */\n\nModule.prototype.chunkCondition = null;\nModule.prototype.updateCacheModule = null;\nmodule.exports = Module;","map":null,"metadata":{},"sourceType":"script"}