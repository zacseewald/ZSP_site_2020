{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createClass = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/get\");\n\nvar _classCallCheck = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/zs/Desktop/ZSP_site_2020/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar NativeModule = require(\"module\");\n\nvar _require = require(\"webpack-sources\"),\n    CachedSource = _require.CachedSource,\n    LineToLineMappedSource = _require.LineToLineMappedSource,\n    OriginalSource = _require.OriginalSource,\n    RawSource = _require.RawSource,\n    SourceMapSource = _require.SourceMapSource;\n\nvar _require2 = require(\"loader-runner\"),\n    getContext = _require2.getContext,\n    runLoaders = _require2.runLoaders;\n\nvar WebpackError = require(\"./WebpackError\");\n\nvar Module = require(\"./Module\");\n\nvar ModuleParseError = require(\"./ModuleParseError\");\n\nvar ModuleBuildError = require(\"./ModuleBuildError\");\n\nvar ModuleError = require(\"./ModuleError\");\n\nvar ModuleWarning = require(\"./ModuleWarning\");\n\nvar createHash = require(\"./util/createHash\");\n\nvar contextify = require(\"./util/identifier\").contextify;\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n\nvar asString = function asString(buf) {\n  if (Buffer.isBuffer(buf)) {\n    return buf.toString(\"utf-8\");\n  }\n\n  return buf;\n};\n\nvar asBuffer = function asBuffer(str) {\n  if (!Buffer.isBuffer(str)) {\n    return Buffer.from(str, \"utf-8\");\n  }\n\n  return str;\n};\n\nvar NonErrorEmittedError =\n/*#__PURE__*/\nfunction (_WebpackError) {\n  _inherits(NonErrorEmittedError, _WebpackError);\n\n  function NonErrorEmittedError(error) {\n    var _this;\n\n    _classCallCheck(this, NonErrorEmittedError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NonErrorEmittedError).call(this));\n    _this.name = \"NonErrorEmittedError\";\n    _this.message = \"(Emitted value instead of an instance of Error) \" + error;\n    Error.captureStackTrace(_assertThisInitialized(_assertThisInitialized(_this)), _this.constructor);\n    return _this;\n  }\n\n  return NonErrorEmittedError;\n}(WebpackError);\n/**\n * @typedef {Object} CachedSourceEntry\n * @property {TODO} source the generated source\n * @property {string} hash the hash value\n */\n\n\nvar NormalModule =\n/*#__PURE__*/\nfunction (_Module) {\n  _inherits(NormalModule, _Module);\n\n  function NormalModule(_ref) {\n    var _this2;\n\n    var type = _ref.type,\n        request = _ref.request,\n        userRequest = _ref.userRequest,\n        rawRequest = _ref.rawRequest,\n        loaders = _ref.loaders,\n        resource = _ref.resource,\n        matchResource = _ref.matchResource,\n        parser = _ref.parser,\n        generator = _ref.generator,\n        resolveOptions = _ref.resolveOptions;\n\n    _classCallCheck(this, NormalModule);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(NormalModule).call(this, type, getContext(resource))); // Info from Factory\n\n    _this2.request = request;\n    _this2.userRequest = userRequest;\n    _this2.rawRequest = rawRequest;\n    _this2.binary = type.startsWith(\"webassembly\");\n    _this2.parser = parser;\n    _this2.generator = generator;\n    _this2.resource = resource;\n    _this2.matchResource = matchResource;\n    _this2.loaders = loaders;\n    if (resolveOptions !== undefined) _this2.resolveOptions = resolveOptions; // Info from Build\n\n    _this2.error = null;\n    _this2._source = null;\n    _this2._buildHash = \"\";\n    _this2.buildTimestamp = undefined;\n    /** @private @type {Map<string, CachedSourceEntry>} */\n\n    _this2._cachedSources = new Map(); // Options for the NormalModule set by plugins\n    // TODO refactor this -> options object filled from Factory\n\n    _this2.useSourceMap = false;\n    _this2.lineToLine = false; // Cache\n\n    _this2._lastSuccessfulBuildMeta = {};\n    return _this2;\n  }\n\n  _createClass(NormalModule, [{\n    key: \"identifier\",\n    value: function identifier() {\n      return this.request;\n    }\n  }, {\n    key: \"readableIdentifier\",\n    value: function readableIdentifier(requestShortener) {\n      return requestShortener.shorten(this.userRequest);\n    }\n  }, {\n    key: \"libIdent\",\n    value: function libIdent(options) {\n      return contextify(options.context, this.userRequest);\n    }\n  }, {\n    key: \"nameForCondition\",\n    value: function nameForCondition() {\n      var resource = this.matchResource || this.resource;\n      var idx = resource.indexOf(\"?\");\n      if (idx >= 0) return resource.substr(0, idx);\n      return resource;\n    }\n  }, {\n    key: \"updateCacheModule\",\n    value: function updateCacheModule(module) {\n      this.type = module.type;\n      this.request = module.request;\n      this.userRequest = module.userRequest;\n      this.rawRequest = module.rawRequest;\n      this.parser = module.parser;\n      this.generator = module.generator;\n      this.resource = module.resource;\n      this.matchResource = module.matchResource;\n      this.loaders = module.loaders;\n      this.resolveOptions = module.resolveOptions;\n    }\n  }, {\n    key: \"createSourceForAsset\",\n    value: function createSourceForAsset(name, content, sourceMap) {\n      if (!sourceMap) {\n        return new RawSource(content);\n      }\n\n      if (typeof sourceMap === \"string\") {\n        return new OriginalSource(content, sourceMap);\n      }\n\n      return new SourceMapSource(content, name, sourceMap);\n    }\n  }, {\n    key: \"createLoaderContext\",\n    value: function createLoaderContext(resolver, options, compilation, fs) {\n      var _this3 = this;\n\n      var requestShortener = compilation.runtimeTemplate.requestShortener;\n      var loaderContext = {\n        version: 2,\n        emitWarning: function emitWarning(warning) {\n          if (!(warning instanceof Error)) {\n            warning = new NonErrorEmittedError(warning);\n          }\n\n          var currentLoader = _this3.getCurrentLoader(loaderContext);\n\n          _this3.warnings.push(new ModuleWarning(_this3, warning, {\n            from: requestShortener.shorten(currentLoader.loader)\n          }));\n        },\n        emitError: function emitError(error) {\n          if (!(error instanceof Error)) {\n            error = new NonErrorEmittedError(error);\n          }\n\n          var currentLoader = _this3.getCurrentLoader(loaderContext);\n\n          _this3.errors.push(new ModuleError(_this3, error, {\n            from: requestShortener.shorten(currentLoader.loader)\n          }));\n        },\n        // TODO remove in webpack 5\n        exec: function exec(code, filename) {\n          // @ts-ignore Argument of type 'this' is not assignable to parameter of type 'Module'.\n          var module = new NativeModule(filename, _this3); // @ts-ignore _nodeModulePaths is deprecated and undocumented Node.js API\n\n          module.paths = NativeModule._nodeModulePaths(_this3.context);\n          module.filename = filename;\n\n          module._compile(code, filename);\n\n          return module.exports;\n        },\n        resolve: function resolve(context, request, callback) {\n          resolver.resolve({}, context, request, {}, callback);\n        },\n        getResolve: function getResolve(options) {\n          var child = options ? resolver.withOptions(options) : resolver;\n          return function (context, request, callback) {\n            if (callback) {\n              child.resolve({}, context, request, {}, callback);\n            } else {\n              return new Promise(function (resolve, reject) {\n                child.resolve({}, context, request, {}, function (err, result) {\n                  if (err) reject(err);else resolve(result);\n                });\n              });\n            }\n          };\n        },\n        emitFile: function emitFile(name, content, sourceMap) {\n          if (!_this3.buildInfo.assets) {\n            _this3.buildInfo.assets = Object.create(null);\n          }\n\n          _this3.buildInfo.assets[name] = _this3.createSourceForAsset(name, content, sourceMap);\n        },\n        rootContext: options.context,\n        webpack: true,\n        sourceMap: !!this.useSourceMap,\n        _module: this,\n        _compilation: compilation,\n        _compiler: compilation.compiler,\n        fs: fs\n      };\n      compilation.hooks.normalModuleLoader.call(loaderContext, this);\n\n      if (options.loader) {\n        Object.assign(loaderContext, options.loader);\n      }\n\n      return loaderContext;\n    }\n  }, {\n    key: \"getCurrentLoader\",\n    value: function getCurrentLoader(loaderContext) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : loaderContext.loaderIndex;\n\n      if (this.loaders && this.loaders.length && index < this.loaders.length && index >= 0 && this.loaders[index]) {\n        return this.loaders[index];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createSource\",\n    value: function createSource(source, resourceBuffer, sourceMap) {\n      // if there is no identifier return raw source\n      if (!this.identifier) {\n        return new RawSource(source);\n      } // from here on we assume we have an identifier\n\n\n      var identifier = this.identifier();\n\n      if (this.lineToLine && resourceBuffer) {\n        return new LineToLineMappedSource(source, identifier, asString(resourceBuffer));\n      }\n\n      if (this.useSourceMap && sourceMap) {\n        return new SourceMapSource(source, identifier, sourceMap);\n      }\n\n      if (Buffer.isBuffer(source)) {\n        // @ts-ignore\n        // TODO We need to fix @types/webpack-sources to allow RawSource to take a Buffer | string\n        return new RawSource(source);\n      }\n\n      return new OriginalSource(source, identifier);\n    }\n  }, {\n    key: \"doBuild\",\n    value: function doBuild(options, compilation, resolver, fs, callback) {\n      var _this4 = this;\n\n      var loaderContext = this.createLoaderContext(resolver, options, compilation, fs);\n      runLoaders({\n        resource: this.resource,\n        loaders: this.loaders,\n        context: loaderContext,\n        readResource: fs.readFile.bind(fs)\n      }, function (err, result) {\n        if (result) {\n          _this4.buildInfo.cacheable = result.cacheable;\n          _this4.buildInfo.fileDependencies = new Set(result.fileDependencies);\n          _this4.buildInfo.contextDependencies = new Set(result.contextDependencies);\n        }\n\n        if (err) {\n          if (!(err instanceof Error)) {\n            err = new NonErrorEmittedError(err);\n          }\n\n          var currentLoader = _this4.getCurrentLoader(loaderContext);\n\n          var error = new ModuleBuildError(_this4, err, {\n            from: currentLoader && compilation.runtimeTemplate.requestShortener.shorten(currentLoader.loader)\n          });\n          return callback(error);\n        }\n\n        var resourceBuffer = result.resourceBuffer;\n        var source = result.result[0];\n        var sourceMap = result.result.length >= 1 ? result.result[1] : null;\n        var extraInfo = result.result.length >= 2 ? result.result[2] : null;\n\n        if (!Buffer.isBuffer(source) && typeof source !== \"string\") {\n          var _currentLoader = _this4.getCurrentLoader(loaderContext, 0);\n\n          var _err = new Error(\"Final loader (\".concat(_currentLoader ? compilation.runtimeTemplate.requestShortener.shorten(_currentLoader.loader) : \"unknown\", \") didn't return a Buffer or String\"));\n\n          var _error = new ModuleBuildError(_this4, _err);\n\n          return callback(_error);\n        }\n\n        _this4._source = _this4.createSource(_this4.binary ? asBuffer(source) : asString(source), resourceBuffer, sourceMap);\n        _this4._ast = typeof extraInfo === \"object\" && extraInfo !== null && extraInfo.webpackAST !== undefined ? extraInfo.webpackAST : null;\n        return callback();\n      });\n    }\n  }, {\n    key: \"markModuleAsErrored\",\n    value: function markModuleAsErrored(error) {\n      // Restore build meta from successful build to keep importing state\n      this.buildMeta = Object.assign({}, this._lastSuccessfulBuildMeta);\n      this.error = error;\n      this.errors.push(this.error);\n      this._source = new RawSource(\"throw new Error(\" + JSON.stringify(this.error.message) + \");\");\n      this._ast = null;\n    }\n  }, {\n    key: \"applyNoParseRule\",\n    value: function applyNoParseRule(rule, content) {\n      // must start with \"rule\" if rule is a string\n      if (typeof rule === \"string\") {\n        return content.indexOf(rule) === 0;\n      }\n\n      if (typeof rule === \"function\") {\n        return rule(content);\n      } // we assume rule is a regexp\n\n\n      return rule.test(content);\n    } // check if module should not be parsed\n    // returns \"true\" if the module should !not! be parsed\n    // returns \"false\" if the module !must! be parsed\n\n  }, {\n    key: \"shouldPreventParsing\",\n    value: function shouldPreventParsing(noParseRule, request) {\n      // if no noParseRule exists, return false\n      // the module !must! be parsed.\n      if (!noParseRule) {\n        return false;\n      } // we only have one rule to check\n\n\n      if (!Array.isArray(noParseRule)) {\n        // returns \"true\" if the module is !not! to be parsed\n        return this.applyNoParseRule(noParseRule, request);\n      }\n\n      for (var i = 0; i < noParseRule.length; i++) {\n        var rule = noParseRule[i]; // early exit on first truthy match\n        // this module is !not! to be parsed\n\n        if (this.applyNoParseRule(rule, request)) {\n          return true;\n        }\n      } // no match found, so this module !should! be parsed\n\n\n      return false;\n    }\n  }, {\n    key: \"_initBuildHash\",\n    value: function _initBuildHash(compilation) {\n      var hash = createHash(compilation.outputOptions.hashFunction);\n\n      if (this._source) {\n        hash.update(\"source\");\n\n        this._source.updateHash(hash);\n      }\n\n      hash.update(\"meta\");\n      hash.update(JSON.stringify(this.buildMeta));\n      this._buildHash = hash.digest(\"hex\");\n    }\n  }, {\n    key: \"build\",\n    value: function build(options, compilation, resolver, fs, callback) {\n      var _this5 = this;\n\n      this.buildTimestamp = Date.now();\n      this.built = true;\n      this._source = null;\n      this._ast = null;\n      this._buildHash = \"\";\n      this.error = null;\n      this.errors.length = 0;\n      this.warnings.length = 0;\n      this.buildMeta = {};\n      this.buildInfo = {\n        cacheable: false,\n        fileDependencies: new Set(),\n        contextDependencies: new Set()\n      };\n      return this.doBuild(options, compilation, resolver, fs, function (err) {\n        _this5._cachedSources.clear(); // if we have an error mark module as failed and exit\n\n\n        if (err) {\n          _this5.markModuleAsErrored(err);\n\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        } // check if this module should !not! be parsed.\n        // if so, exit here;\n\n\n        var noParseRule = options.module && options.module.noParse;\n\n        if (_this5.shouldPreventParsing(noParseRule, _this5.request)) {\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        }\n\n        var handleParseError = function handleParseError(e) {\n          var source = _this5._source.source();\n\n          var error = new ModuleParseError(_this5, source, e);\n\n          _this5.markModuleAsErrored(error);\n\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        };\n\n        var handleParseResult = function handleParseResult(result) {\n          _this5._lastSuccessfulBuildMeta = _this5.buildMeta;\n\n          _this5._initBuildHash(compilation);\n\n          return callback();\n        };\n\n        try {\n          var result = _this5.parser.parse(_this5._ast || _this5._source.source(), {\n            current: _this5,\n            module: _this5,\n            compilation: compilation,\n            options: options\n          }, function (err, result) {\n            if (err) {\n              handleParseError(err);\n            } else {\n              handleParseResult(result);\n            }\n          });\n\n          if (result !== undefined) {\n            // parse is sync\n            handleParseResult(result);\n          }\n        } catch (e) {\n          handleParseError(e);\n        }\n      });\n    }\n  }, {\n    key: \"getHashDigest\",\n    value: function getHashDigest(dependencyTemplates) {\n      // TODO webpack 5 refactor\n      var dtHash = dependencyTemplates.get(\"hash\");\n      return \"\".concat(this.hash, \"-\").concat(dtHash);\n    }\n  }, {\n    key: \"source\",\n    value: function source(dependencyTemplates, runtimeTemplate) {\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"javascript\";\n      var hashDigest = this.getHashDigest(dependencyTemplates);\n\n      var cacheEntry = this._cachedSources.get(type);\n\n      if (cacheEntry !== undefined && cacheEntry.hash === hashDigest) {\n        // We can reuse the cached source\n        return cacheEntry.source;\n      }\n\n      var source = this.generator.generate(this, dependencyTemplates, runtimeTemplate, type);\n      var cachedSource = new CachedSource(source);\n\n      this._cachedSources.set(type, {\n        source: cachedSource,\n        hash: hashDigest\n      });\n\n      return cachedSource;\n    }\n  }, {\n    key: \"originalSource\",\n    value: function originalSource() {\n      return this._source;\n    }\n  }, {\n    key: \"needRebuild\",\n    value: function needRebuild(fileTimestamps, contextTimestamps) {\n      // always try to rebuild in case of an error\n      if (this.error) return true; // always rebuild when module is not cacheable\n\n      if (!this.buildInfo.cacheable) return true; // Check timestamps of all dependencies\n      // Missing timestamp -> need rebuild\n      // Timestamp bigger than buildTimestamp -> need rebuild\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.buildInfo.fileDependencies[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var file = _step.value;\n          var timestamp = fileTimestamps.get(file);\n          if (!timestamp) return true;\n          if (timestamp >= this.buildTimestamp) return true;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.buildInfo.contextDependencies[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _file = _step2.value;\n\n          var _timestamp = contextTimestamps.get(_file);\n\n          if (!_timestamp) return true;\n          if (_timestamp >= this.buildTimestamp) return true;\n        } // elsewise -> no rebuild needed\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"size\",\n    value: function size() {\n      return this._source ? this._source.size() : -1;\n    }\n    /**\n     * @param {Hash} hash the hash used to track dependencies\n     * @returns {void}\n     */\n\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(this._buildHash);\n\n      _get(_getPrototypeOf(NormalModule.prototype), \"updateHash\", this).call(this, hash);\n    }\n  }]);\n\n  return NormalModule;\n}(Module);\n\nmodule.exports = NormalModule;","map":null,"metadata":{},"sourceType":"script"}