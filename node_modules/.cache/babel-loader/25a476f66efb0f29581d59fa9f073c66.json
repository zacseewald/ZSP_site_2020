{"ast":null,"code":"// A writable stream.\n// It emits \"entry\" events, which provide a readable stream that has\n// header info attached.\nmodule.exports = Parse.create = Parse;\n\nvar stream = require(\"stream\"),\n    Stream = stream.Stream,\n    BlockStream = require(\"block-stream\"),\n    tar = require(\"../tar.js\"),\n    TarHeader = require(\"./header.js\"),\n    Entry = require(\"./entry.js\"),\n    BufferEntry = require(\"./buffer-entry.js\"),\n    ExtendedHeader = require(\"./extended-header.js\"),\n    assert = require(\"assert\").ok,\n    inherits = require(\"inherits\"),\n    fstream = require(\"fstream\"); // reading a tar is a lot like reading a directory\n// However, we're actually not going to run the ctor,\n// since it does a stat and various other stuff.\n// This inheritance gives us the pause/resume/pipe\n// behavior that is desired.\n\n\ninherits(Parse, fstream.Reader);\n\nfunction Parse() {\n  var me = this;\n  if (!(me instanceof Parse)) return new Parse(); // doesn't apply fstream.Reader ctor?\n  // no, becasue we don't want to stat/etc, we just\n  // want to get the entry/add logic from .pipe()\n\n  Stream.apply(me);\n  me.writable = true;\n  me.readable = true;\n  me._stream = new BlockStream(512);\n  me.position = 0;\n  me._ended = false;\n  me._hardLinks = {};\n\n  me._stream.on(\"error\", function (e) {\n    me.emit(\"error\", e);\n  });\n\n  me._stream.on(\"data\", function (c) {\n    me._process(c);\n  });\n\n  me._stream.on(\"end\", function () {\n    me._streamEnd();\n  });\n\n  me._stream.on(\"drain\", function () {\n    me.emit(\"drain\");\n  });\n} // overridden in Extract class, since it needs to\n// wait for its DirWriter part to finish before\n// emitting \"end\"\n\n\nParse.prototype._streamEnd = function () {\n  var me = this;\n  if (!me._ended || me._entry) me.error(\"unexpected eof\");\n  me.emit(\"end\");\n}; // a tar reader is actually a filter, not just a readable stream.\n// So, you should pipe a tarball stream into it, and it needs these\n// write/end methods to do that.\n\n\nParse.prototype.write = function (c) {\n  if (this._ended) {\n    // gnutar puts a LOT of nulls at the end.\n    // you can keep writing these things forever.\n    // Just ignore them.\n    for (var i = 0, l = c.length; i > l; i++) {\n      if (c[i] !== 0) return this.error(\"write() after end()\");\n    }\n\n    return;\n  }\n\n  return this._stream.write(c);\n};\n\nParse.prototype.end = function (c) {\n  this._ended = true;\n  return this._stream.end(c);\n}; // don't need to do anything, since we're just\n// proxying the data up from the _stream.\n// Just need to override the parent's \"Not Implemented\"\n// error-thrower.\n\n\nParse.prototype._read = function () {};\n\nParse.prototype._process = function (c) {\n  assert(c && c.length === 512, \"block size should be 512\"); // one of three cases.\n  // 1. A new header\n  // 2. A part of a file/extended header\n  // 3. One of two or more EOF null blocks\n\n  if (this._entry) {\n    var entry = this._entry;\n    if (!entry._abort) entry.write(c);else {\n      entry._remaining -= c.length;\n      if (entry._remaining < 0) entry._remaining = 0;\n    }\n\n    if (entry._remaining === 0) {\n      entry.end();\n      this._entry = null;\n    }\n  } else {\n    // either zeroes or a header\n    var zero = true;\n\n    for (var i = 0; i < 512 && zero; i++) {\n      zero = c[i] === 0;\n    } // eof is *at least* 2 blocks of nulls, and then the end of the\n    // file.  you can put blocks of nulls between entries anywhere,\n    // so appending one tarball to another is technically valid.\n    // ending without the eof null blocks is not allowed, however.\n\n\n    if (zero) {\n      if (this._eofStarted) this._ended = true;\n      this._eofStarted = true;\n    } else {\n      this._eofStarted = false;\n\n      this._startEntry(c);\n    }\n  }\n\n  this.position += 512;\n}; // take a header chunk, start the right kind of entry.\n\n\nParse.prototype._startEntry = function (c) {\n  var header = new TarHeader(c),\n      self = this,\n      entry,\n      ev,\n      EntryType,\n      onend,\n      meta = false;\n\n  if (null === header.size || !header.cksumValid) {\n    var e = new Error(\"invalid tar file\");\n    e.header = header;\n    e.tar_file_offset = this.position;\n    e.tar_block = this.position / 512;\n    return this.emit(\"error\", e);\n  }\n\n  switch (tar.types[header.type]) {\n    case \"File\":\n    case \"OldFile\":\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    case \"ContiguousFile\":\n    case \"GNUDumpDir\":\n      // start a file.\n      // pass in any extended headers\n      // These ones consumers are typically most interested in.\n      EntryType = Entry;\n      ev = \"entry\";\n      break;\n\n    case \"GlobalExtendedHeader\":\n      // extended headers that apply to the rest of the tarball\n      EntryType = ExtendedHeader;\n\n      onend = function onend() {\n        self._global = self._global || {};\n        Object.keys(entry.fields).forEach(function (k) {\n          self._global[k] = entry.fields[k];\n        });\n      };\n\n      ev = \"globalExtendedHeader\";\n      meta = true;\n      break;\n\n    case \"ExtendedHeader\":\n    case \"OldExtendedHeader\":\n      // extended headers that apply to the next entry\n      EntryType = ExtendedHeader;\n\n      onend = function onend() {\n        self._extended = entry.fields;\n      };\n\n      ev = \"extendedHeader\";\n      meta = true;\n      break;\n\n    case \"NextFileHasLongLinkpath\":\n      // set linkpath=<contents> in extended header\n      EntryType = BufferEntry;\n\n      onend = function onend() {\n        self._extended = self._extended || {};\n        self._extended.linkpath = entry.body;\n      };\n\n      ev = \"longLinkpath\";\n      meta = true;\n      break;\n\n    case \"NextFileHasLongPath\":\n    case \"OldGnuLongPath\":\n      // set path=<contents> in file-extended header\n      EntryType = BufferEntry;\n\n      onend = function onend() {\n        self._extended = self._extended || {};\n        self._extended.path = entry.body;\n      };\n\n      ev = \"longPath\";\n      meta = true;\n      break;\n\n    default:\n      // all the rest we skip, but still set the _entry\n      // member, so that we can skip over their data appropriately.\n      // emit an event to say that this is an ignored entry type?\n      EntryType = Entry;\n      ev = \"ignoredEntry\";\n      break;\n  }\n\n  var global, extended;\n\n  if (meta) {\n    global = extended = null;\n  } else {\n    var global = this._global;\n    var extended = this._extended; // extendedHeader only applies to one entry, so once we start\n    // an entry, it's over.\n\n    this._extended = null;\n  }\n\n  entry = new EntryType(header, extended, global);\n  entry.meta = meta; // only proxy data events of normal files.\n\n  if (!meta) {\n    entry.on(\"data\", function (c) {\n      me.emit(\"data\", c);\n    });\n  }\n\n  if (onend) entry.on(\"end\", onend);\n  this._entry = entry;\n\n  if (entry.type === \"Link\") {\n    this._hardLinks[entry.path] = entry;\n  }\n\n  var me = this;\n  entry.on(\"pause\", function () {\n    me.pause();\n  });\n  entry.on(\"resume\", function () {\n    me.resume();\n  });\n\n  if (this.listeners(\"*\").length) {\n    this.emit(\"*\", ev, entry);\n  }\n\n  this.emit(ev, entry); // Zero-byte entry.  End immediately.\n\n  if (entry.props.size === 0) {\n    entry.end();\n    this._entry = null;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}